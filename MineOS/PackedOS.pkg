ARCHF.ospropreturn {name = "OpenOS"}
DMineOS/DMineOS/Applications/D"MineOS/Applications/AppMarket.app/F/MineOS/Applications/AppMarket.app/AppMarket.lua8o
-- package.loaded.GUI = nil
-- _G.GUI = nil

local advancedLua = require("advancedLua")
local buffer = require("doubleBuffering")
local MineOSCore = require("MineOSCore")
local image = require("image")
local GUI = require("GUI")
local fs = require("filesystem")
local component = require("component")
local unicode = require("unicode")
local event = require("event")
local ecs = require("ECSAPI")

------------------------------------------------------------------------------------------------------------------

local obj = {}
local sizes = {}
local colors = {
	main = 0xFFFFFF,
	topBar = 0xDDDDDD,
	topBarText = 0x555555,
	topBarElement = 0xCCCCCC,
	topBarElementText = 0x555555,
	statusBar = 0xDDDDDD,
	statusBarText = 0x888888,
	appName = 0x262626,
	version = 0x555555,
	description = 0x888888,
	downloadButton = 0xAAAAAA,
	downloadButtonText = 0xFFFFFF,
	downloading = 0x009240,
	downloadingText = 0xFFFFFF,
	downloaded = 0xCCCCCC,
	downloadedText = 0xFFFFFF,
}

local typeFilters = {
	"Application",
	"Library",
	"Wallpaper",
	"Script",
}

local localization = table.fromFile("MineOS/Applications/AppMarket.app/Resources/Localization/" .. _G.OSSettings.language .. ".lang")
local appMarketConfigPath = "MineOS/System/AppMarket/"
local pathToApplications = "MineOS/System/OS/Applications.txt"
local pathToNewApplications = appMarketConfigPath .. "NewApplications.txt"
local updateImage = image.load(MineOSCore.paths.icons .. "Update.pic")
local topBarElements = {localization.applications, localization.libraries, localization.wallpapers, localization.other, localization.updates}
local oldApplications, newApplications, currentApps, changes = {}, {}, {}, {}

local currentTopBarElement = 1
local from, limit, fromY = 1, 8

------------------------------------------------------------------------------------------------------------------

local function correctDouble(number)
	return string.format("%.2f", number)
end

local function status(text)
	text = unicode.sub(text, 1, sizes.width - 2)
	local y = sizes.y + sizes.height - 1
	buffer.square(sizes.x, y, sizes.width, 1, colors.statusBar, colors.statusBarText, " ")
	buffer.text(sizes.x + 1, y, colors.statusBarText, text)
	buffer.draw()
end

local function calculateSizes()
	sizes.width, sizes.height = math.floor(buffer.screen.width * 0.6), math.floor(buffer.screen.height * 0.7)
	sizes.x, sizes.y = math.floor(buffer.screen.width / 2 - sizes.width / 2), math.floor(buffer.screen.height / 2 - sizes.height / 2)
	sizes.topBarHeight = 3
	obj.main = GUI.object(sizes.x, sizes.y + sizes.topBarHeight, sizes.width, sizes.height - sizes.topBarHeight)
	sizes.downloadButtonWidth = 17
	sizes.descriptionTruncateSize = sizes.width - 6 - MineOSCore.iconWidth - sizes.downloadButtonWidth
	sizes.searchFieldWidth = math.floor(sizes.width * 0.3)
	obj.searchTextField = GUI.inputTextBox(math.floor(sizes.x + sizes.width / 2 - sizes.searchFieldWidth / 2), 1, sizes.searchFieldWidth, 1, 0xEEEEEE, 0x555555, 0xEEEEEE, 0x262626, "", localization.search, true)
end

local function drawTopBar()
	obj.topBarButtons = GUI.tabBar(sizes.x, sizes.y, sizes.width, sizes.topBarHeight, 2, colors.topBar, colors.topBarText, colors.topBarElement, colors.topBarElementText, table.unpack(topBarElements))
	obj.topBarButtons.selectedTab = currentTopBarElement
	obj.topBarButtons:draw()
	obj.windowActionButtons = GUI.windowActionButtons(sizes.x + 1, sizes.y):draw()
end

local function getIcon(url)
	local success, response = ecs.internetRequest(url)
	local path = appMarketConfigPath .. "TempIcon.pic"
	if success then
		local file = io.open(path, "w")
		file:write(response)
		file:close()
	else
		GUI.error(tostring(response), {title = {color = 0xFFDB40, text = localization.errorWhileLoadingIcon}})
	end
	return image.load(path)
end

local function getDescription(url)
	local success, response = ecs.internetRequest(url)
	if success then
		return response
	else
		GUI.error(tostring(response), {title = {color = 0xFFDB40, text = localization.errorWhileLoadingDescription}})
	end
end

local function getApplication(i)
	currentApps[i] = {}
	currentApps[i].name = fs.name(newApplications[i].name)

	if newApplications[i].icon then
		currentApps[i].icon = getIcon(newApplications.GitHubUserURL .. newApplications[i].icon)
	else
		if newApplications[i].type == "Application" then
			currentApps[i].icon = failureIcon
		elseif newApplications[i].type == "Wallpaper" then
			currentApps[i].icon = MineOSCore.icons.image
		elseif newApplications[i].type == "Library" then
			currentApps[i].icon = MineOSCore.icons.lua
		else
			currentApps[i].icon = MineOSCore.icons.script
		end
	end

	if newApplications[i].about then
		currentApps[i].description = getDescription(newApplications.GitHubUserURL .. newApplications[i].about .. _G.OSSettings.language .. ".txt")
		currentApps[i].description = string.wrap({currentApps[i].description}, sizes.descriptionTruncateSize )
	else
		currentApps[i].description = {localization.descriptionNotAvailable}
	end

	if newApplications[i].version then
		currentApps[i].version = localization.version .. correctDouble(newApplications[i].version)
	else
		currentApps[i].version = localization.versionNotAvailable
	end
end

local function checkAppExists(name, type)
	if type == "Application" then
		name = name .. ".app"
	end
	return fs.exists(name)
end

local function drawApplication(x, y, i, doNotDrawButton)
	buffer.image(x, y, currentApps[i].icon)
	buffer.text(x + 10, y, colors.appName, currentApps[i].name)
	buffer.text(x + 10, y + 1, colors.version, currentApps[i].version)
	local appExists = checkAppExists(newApplications[i].name, newApplications[i].type)
	local text = appExists and localization.update or localization.download
	
	if not doNotDrawButton then
		local xButton, yButton = sizes.x + sizes.width - sizes.downloadButtonWidth - 2, y + 1
		if currentApps[i].buttonObject then
			currentApps[i].buttonObject.x, currentApps[i].buttonObject.y = xButton, yButton
			currentApps[i].buttonObject:draw()
		else
			currentApps[i].buttonObject = GUI.button(xButton, yButton, sizes.downloadButtonWidth, 1, colors.downloadButton, colors.downloadButtonText, 0x555555, 0xFFFFFF, text):draw()
		end
	end

	for j = 1, #currentApps[i].description do
		buffer.text(x + 10, y + j + 1, colors.description, currentApps[i].description[j])
	end
	y = y + (#currentApps[i].description > 2 and #currentApps[i].description - 2 or 0)
	y = y + 5

	return x, y
end

local function drawPageSwitchButtons(y)
	local text = localization.applicationsFrom .. from .. localization.applicationsTo .. from + limit - 1
	local textLength = unicode.len(text)
	local buttonWidth = 5
	local width = buttonWidth * 2 + textLength + 2
	local x = math.floor(sizes.x + sizes.width / 2 - width / 2)
	obj.prevPageButton = GUI.button(x, y, buttonWidth, 1, colors.downloadButton, colors.downloadButtonText, 0x262626, 0xFFFFFF, "<"):draw()
	x = x + obj.prevPageButton.width + 1
	buffer.text(x, y, colors.version, text)
	x = x + textLength + 1
	obj.nextPageButton = GUI.button(x, y, buttonWidth, 1, colors.downloadButton, colors.downloadButtonText, 0x262626, 0xFFFFFF, ">"):draw()
end

local function clearMainZone()
	buffer.square(sizes.x, obj.main.y, sizes.width, obj.main.height, 0xFFFFFF)
end

local function drawMain(refreshData)
	clearMainZone()
	local x, y = sizes.x + 2, fromY

	buffer.setDrawLimit(sizes.x, obj.main.y, sizes.width, obj.main.height)

	obj.searchTextField.y, obj.searchTextField.isHidden = y, false
	obj.searchTextField:draw()
	y = y + 2

	local matchCount = 1
	for i = 1, #newApplications do
		if newApplications[i].type == typeFilters[currentTopBarElement] then
			if obj.searchTextField.text == "" or (string.find(unicode.lower(fs.name(newApplications[i].name)), unicode.lower(obj.searchTextField.text))) then
				if matchCount >= from and matchCount <= from + limit - 1 then
					if refreshData and not currentApps[i] then
						status(localization.downloadingInfoAboutApplication .. " \"" .. newApplications[i].name .. "\"")
						getApplication(i)
					end
					x, y = drawApplication(x, y, i)
				end
				matchCount = matchCount + 1
			end
		end
	end

	if matchCount > limit then
		drawPageSwitchButtons(y)
	end

	buffer.resetDrawLimit()
end

local function getNewApplications()
	ecs.getFileFromUrl(oldApplications.GitHubApplicationListURL, pathToNewApplications)
	newApplications = table.fromFile(pathToNewApplications)
end

local function getChanges()
	changes = {}
	for j = 1, #newApplications do
		local matchFound = false
		for i = 1, #oldApplications do	
			if oldApplications[i].name == newApplications[j].name then
				if oldApplications[i].version < newApplications[j].version then table.insert(changes, j) end
				matchFound = true
				break
			end
		end
		if not matchFound then table.insert(changes, j) end
	end
end

local function updates()
	clearMainZone()

	obj.searchTextField.isHidden = true

	if #changes > 0 then
		buffer.setDrawLimit(sizes.x, obj.main.y, sizes.width, obj.main.height)
		local x, y = sizes.x + 2, fromY
		obj.updateAllButton = GUI.button(math.floor(sizes.x + sizes.width / 2 - sizes.downloadButtonWidth / 2), y, 20, 1, colors.downloadButton, colors.downloadButtonText, 0x555555, 0xFFFFFF, "–û–±–Ω–æ–≤–∏—Ç—å –≤—Å–µ"):draw()
		y = y + 2

		for i = from, (from + limit) do
			if not changes[i] then break end
			if not currentApps[changes[i]] then
				status(localization.downloadingInfoAboutApplication .. " \"" .. fs.name(newApplications[changes[i]].name) .. "\"")
				getApplication(changes[i])
			end
			x, y = drawApplication(x, y, changes[i], true)
		end

		if #changes > limit then
			drawPageSwitchButtons(y)
		end
		buffer.resetDrawLimit()
	else
		local text = localization.youHaveNewestApps
		buffer.text(math.floor(sizes.x + sizes.width / 2 - unicode.len(text) / 2), math.floor(obj.main.y + obj.main.height / 2 - 1), colors.description, text)
	end
end

local function flush()
	fromY = obj.main.y + 1
	from = 1
	currentApps = {}
end

local function loadOldApplications()
	oldApplications = table.fromFile(pathToApplications)
end

local function saveOldApplications()
	table.toFile(pathToApplications, oldApplications)
end

local function drawAll(refreshIcons, force)
	drawTopBar()
	if currentTopBarElement == 5 then
		updates()
	else
		drawMain(refreshIcons)
	end
	buffer.draw(force)
end

local function updateImageWindow()
	clearMainZone()
	local x, y = math.floor(sizes.x + sizes.width / 2 - updateImage.width / 2), math.floor(obj.main.y + obj.main.height / 2 - updateImage.height / 2 - 2)
	buffer.image(x, y, updateImage)
	return y + updateImage.height
end

local function updateImageWindowWithText(text)
	local y = updateImageWindow() + 2
	local x = math.floor(sizes.x + sizes.width / 2 - unicode.len(text) / 2)
	buffer.text(x, y, colors.description, text)
end

local function updateAll()
	local y = updateImageWindow()
	local barWidth = math.floor(sizes.width * 0.6)
	local xBar = math.floor(sizes.x + sizes.width / 2 - barWidth / 2)
	y = y + 2
	for i = 1, #changes do
		local text = localization.updating .. " " .. fs.name(newApplications[changes[i]].name)
		local xText = math.floor(sizes.x + sizes.width / 2 - unicode.len(text) / 2)
		buffer.square(sizes.x, y + 1, sizes.width, 1, 0xFFFFFF)
		buffer.text(xText, y + 1, colors.description, text)
		GUI.progressBar(xBar, y, barWidth, 0x0092FF, 0xCCCCCC, 0x0, math.ceil(i / #changes * 100), true, false):draw()
		buffer.draw()
		ecs.getOSApplication(newApplications[changes[i]], true)
	end
	changes = {}
	oldApplications = newApplications
	saveOldApplications()
	fs.remove(pathToNewApplications)
	require("computer").shutdown(true)
end

------------------------------------------------------------------------------------------------------------------

-- buffer.start()
-- buffer.clear(0xFF8888)

local args = {...}
if args[1] == "updateCheck" then
	currentTopBarElement = 5
end

fs.makeDirectory(appMarketConfigPath)
calculateSizes()
flush()
loadOldApplications()
drawTopBar()
GUI.windowShadow(sizes.x, sizes.y, sizes.width, sizes.height, 50)
updateImageWindowWithText(localization.downloadingApplicationsList)
buffer.draw()
getNewApplications()
getChanges()
drawAll(true, false)

while true do
	local e = {event.pull()}
	if e[1] == "touch" then

		if obj.main:isClicked(e[3], e[4]) then
			if obj.searchTextField:isClicked(e[3], e[4]) then
				obj.searchTextField:input()
				flush()
				drawAll(true, false)
			end

			if currentTopBarElement < 5 then
				for appIndex, app in pairs(currentApps) do
					if app.buttonObject:isClicked(e[3], e[4]) then
						app.buttonObject:pressAndRelease(0.3)
						if app.buttonObject.text == localization.update or app.buttonObject.text == localization.download then
							app.buttonObject.text = localization.downloading
							app.buttonObject.disabled = true
							app.buttonObject.colors.disabled.button, app.buttonObject.colors.disabled.text = colors.downloading, colors.downloadingText
							app.buttonObject:draw()
							buffer.draw()
							ecs.getOSApplication(newApplications[appIndex], true)
							app.buttonObject.text = localization.downloaded
							app.buttonObject.colors.disabled.button, app.buttonObject.colors.disabled.text = colors.downloaded, colors.downloadedText
							app.buttonObject:draw()
							buffer.draw()
						end
						break
					end	
				end
			else
				if obj.updateAllButton and obj.updateAllButton:isClicked(e[3], e[4]) then
					obj.updateAllButton:pressAndRelease()
					updateAll()
					flush()
					drawAll()
				end
			end

			if obj.nextPageButton then
				if obj.nextPageButton:isClicked(e[3], e[4]) then
					obj.nextPageButton:pressAndRelease()
					fromY = obj.main.y + 1
					from = from + limit
					currentApps = {}
					drawAll(true, false)
				elseif obj.prevPageButton:isClicked(e[3], e[4]) then
					if from > limit then
						fromY = obj.main.y + 1
						from = from - limit
						currentApps = {}
						drawAll(true, false)
					end
				end
			end
		end


		if obj.windowActionButtons.close:isClicked(e[3], e[4]) then
			obj.windowActionButtons.close:pressAndRelease()
			return
		end

		for key, button in pairs(obj.topBarButtons.tabs.children) do
			if button:isClicked(e[3], e[4]) then
				currentTopBarElement = key
				flush()
				drawAll(true, false)
				break
			end
		end
	elseif e[1] == "scroll" then
		if e[5] == 1 then
			if (fromY < obj.main.y) then
				fromY = fromY + 2
				drawAll(false, false)
			end
		else
			fromY = fromY - 2
			drawAll(false, false)
		end
	end
end








D,MineOS/Applications/AppMarket.app/Resources/D2MineOS/Applications/AppMarket.app/Resources/About/F=MineOS/Applications/AppMarket.app/Resources/About/Russian.txt.–û–¥–Ω–æ –∏–∑ –≥–ª–∞–≤–Ω—ã—Ö —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π, –ø–æ–∑–≤–æ–ª—è—é—â–µ–µ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –Ω–∞–ª–∏—á–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π, –∞ —Ç–∞–∫–∂–µ –∑–∞–≥—Ä—É–∂–∞—Ç—å –∫—Ä–∞—Å–∏–≤–µ–π—à–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã, —Å–æ–∑–¥–∞–Ω–Ω—ã–µ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ –¥–ª—è MineOS.F4MineOS/Applications/AppMarket.app/Resources/Icon.picßOCIFAˇS‚óèF¨B  YS‚ïöF÷B  YF’B  YS F B  YYYS‚ïìF◊B  YS‚ïùF÷B  YF’B  YS‚ï¨F÷B  YF’B  YD9MineOS/Applications/AppMarket.app/Resources/Localization/FEMineOS/Applications/AppMarket.app/Resources/Localization/English.lang¸{
	applications = "Applications",
	libraries = "Libraries",
	wallpapers = "Wallpapers",
	other = "Other",
	updates = "Updates",
	downloadingApplicationsList = "Downloading applications list",
	version = "Version: ",
	descriptionNotAvailable = "No description",
	versionNotAvailable = "No version",
	update = "Update",
	download = "Install",
	downloading = "Installing",
	downloaded = "Installed",
	search = "Search",
	errorWhileLoadingIcon = "Error while downloading icon",
	errorWhileLoadingDescription = "Error while downloading description",
	applicationsFrom = "Application from ",
	applicationsTo = " to ",
	youHaveNewestApps = "You have no updates.",
	downloadingInfoAboutApplication = "Downloading information about application",
	updating = "Installing",
}FEMineOS/Applications/AppMarket.app/Resources/Localization/Russian.lang{
	applications = "–ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è",
	libraries = "–ë–∏–±–ª–∏–æ—Ç–µ–∫–∏",
	wallpapers = "–û–±–æ–∏",
	other = "–î—Ä—É–≥–æ–µ",
	updates = "–û–±–Ω–æ–≤–ª–µ–Ω–∏—è",
	downloadingApplicationsList = "–ó–∞–≥—Ä—É–∑–∫–∞ —Å–ø–∏—Å–∫–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π",
	version = "–í–µ—Ä—Å–∏—è: ",
	descriptionNotAvailable = "–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç",
	versionNotAvailable = "–í–µ—Ä—Å–∏—è –Ω–µ —É–∫–∞–∑–∞–Ω–∞",
	update = "–û–±–Ω–æ–≤–∏—Ç—å",
	download = "–ó–∞–≥—Ä—É–∑–∏—Ç—å",
	downloading = "–ó–∞–≥—Ä—É–∑–∫–∞",
	downloaded = "–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ",
	search = "–ü–æ–∏—Å–∫",
	errorWhileLoadingIcon = "–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–∫–æ–Ω–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è",
	errorWhileLoadingDescription = "–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –æ–ø–∏—Å–∞–Ω–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è",
	applicationsFrom = "–ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Å ",
	applicationsTo = " –ø–æ ",
	youHaveNewestApps = "–£ –≤–∞—Å —Å–∞–º–æ–µ –Ω–æ–≤–æ–µ –ü–û",
	downloadingInfoAboutApplication = "–ó–∞–≥—Ä—É–∑–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏",
	updating = "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ",
}D%MineOS/Applications/MineCode IDE.app/F5MineOS/Applications/MineCode IDE.app/MineCode IDE.lua‰Å
---------------------------------------------------- Libraries ----------------------------------------------------

-- "/MineOS/Applications/MineCode IDE.app/MineCode IDE.lua" open OS.lua

package.loaded.syntax = nil
-- package.loaded.ECSAPI = nil
-- package.loaded.GUI = nil
-- package.loaded.windows = nil
-- package.loaded.MineOSCore = nil

require("advancedLua")
local computer = require("computer")
local component = require("component")
local fs = require("filesystem")
local buffer = require("doubleBuffering")
local GUI = require("GUI")
local windows = require("windows")
local MineOSCore = require("MineOSCore")
local event = require("event")
local syntax = require("syntax")
local unicode = require("unicode")
local ecs = require("ECSAPI")
local image = require("image")
local keyboard = require("keyboard")
local palette = require("palette")
local term = require("term")

---------------------------------------------------- Constants ----------------------------------------------------

local args = {...}

local about = {
	"MineCode IDE",
	"Copyright ¬© 2014-2017 ECS Inc.",
	" ",
	"Developers:",
	" ",
	"Timofeev Igor, vk.com/id7799889",
	"Trifonov Gleb, vk.com/id88323331",
	" ",
	"Testers:",
	" ",
	"Semyonov Semyon, vk.com/id92656626",
	"Prosin Mihail, vk.com/id75667079",
	"Shestakov Timofey, vk.com/id113499693",
	"Bogushevich Victoria, vk.com/id171497518",
	"Vitvitskaya Yana, vk.com/id183425349",
	"Golovanova Polina, vk.com/id226251826",
}

local config = {
	syntaxColorScheme = syntax.colorScheme,
	scrollSpeed = 8,
	cursorColor = 0x00A8FF,
	cursorSymbol = "‚îÉ",
	cursorBlinkDelay = 0.5,
	doubleClickDelay = 0.4,
	screenScale = 1,
	enableAutoBrackets = true,
	highlightLuaSyntax = true,
}

local colors = {
	topToolBar = 0xDDDDDD,
	bottomToolBar = {
		background = 0x3C3C3C,
		buttons = 0x2D2D2D,
		buttonsText = 0xFFFFFF,
	},
	topMenu = {
		backgroundColor = 0xEEEEEE,
		textColor = 0x444444,
		backgroundPressedColor = 0x3366CC,
		textPressedColor = 0xFFFFFF,
	},
	title = {
		default = {
			sides = 0x555555,
			background = 0x3C3C3C,
			text = 0xEEEEEE,
		},
		onError = {
			sides = 0xCC4940,
			background = 0x880000,
			text = 0xEEEEEE,
		},
	},
	leftTreeView = {
		background = 0xCCCCCC,
	},
	highlights = {
		onError = 0xFF4940,
		onBreakpoint = 0x990000,
	}
}

local possibleBrackets = {
	openers = {
		["{"] = "}",
		["["] = "]",
		["("] = ")",
		["\""] = "\"",
		["\'"] = "\'"
	},
	closers = {
		["}"] = "{",
		["]"] = "[",
		[")"] = "(",
		["\""] = "\"",
		["\'"] = "\'"
	}
}

local cursor = {
	position = {
		symbol = 1,
		line = 1
	},
	blinkState = false
}

local resourcesPath = MineOSCore.getCurrentApplicationResourcesDirectory() 
local configPath = resourcesPath .. "Config.cfg"
local localization = MineOSCore.getLocalization(resourcesPath .. "Localization/")
local findStartFrom
local clipboard
local lastErrorLine
local breakpointLine = 5
local lastClickUptime = computer.uptime()
local mainWindow = {}

---------------------------------------------------- Functions ----------------------------------------------------

local function saveConfig()
	table.toFile(configPath, config)
end

local function loadConfig()
	if fs.exists(configPath) then
		config = table.fromFile(configPath)
		syntax.colorScheme = config.syntaxColorScheme
	else
		saveConfig()
	end
end

local function calculateSizes()
	mainWindow.width, mainWindow.height = buffer.screen.width, buffer.screen.height
	mainWindow.leftTreeView.width = math.floor(mainWindow.width * 0.16)

	if mainWindow.leftTreeView.isHidden then
		mainWindow.codeView.localPosition.x, mainWindow.codeView.width = 1, mainWindow.width
		mainWindow.bottomToolBar.localPosition.x, mainWindow.bottomToolBar.width = mainWindow.codeView.localPosition.x, mainWindow.codeView.width
	else
		mainWindow.codeView.localPosition.x, mainWindow.codeView.width = mainWindow.leftTreeView.width + 1, mainWindow.width - mainWindow.leftTreeView.width
		mainWindow.bottomToolBar.localPosition.x, mainWindow.bottomToolBar.width = mainWindow.codeView.localPosition.x, mainWindow.codeView.width
	end

	if mainWindow.topToolBar.isHidden then
		mainWindow.leftTreeView.localPosition.y, mainWindow.leftTreeView.height = 2, mainWindow.height - 1
		mainWindow.codeView.localPosition.y, mainWindow.codeView.height = 2, mainWindow.height - 1
		mainWindow.errorMessage.localPosition.y = 2
	else
		mainWindow.leftTreeView.localPosition.y, mainWindow.leftTreeView.height = 5, mainWindow.height - 4
		mainWindow.codeView.localPosition.y, mainWindow.codeView.height = 5, mainWindow.height - 4
		mainWindow.errorMessage.localPosition.y = 5
	end

	if mainWindow.bottomToolBar.isHidden then

	else
		mainWindow.codeView.height = mainWindow.codeView.height - 3
	end

	mainWindow.settingsContainer.width, mainWindow.settingsContainer.height = mainWindow.width, mainWindow.height
	mainWindow.settingsContainer.backgroundPanel.width, mainWindow.settingsContainer.backgroundPanel.height = mainWindow.settingsContainer.width, mainWindow.settingsContainer.height

	mainWindow.bottomToolBar.localPosition.y = mainWindow.height - 2
	mainWindow.bottomToolBar.findButton.localPosition.x = mainWindow.bottomToolBar.width - mainWindow.bottomToolBar.findButton.width + 1
	mainWindow.bottomToolBar.inputTextBox.width = mainWindow.bottomToolBar.width - mainWindow.bottomToolBar.inputTextBox.localPosition.x - mainWindow.bottomToolBar.findButton.width + 1

	mainWindow.topToolBar.width, mainWindow.topToolBar.backgroundPanel.width = mainWindow.width, mainWindow.width
	mainWindow.titleTextBox.width = math.floor(mainWindow.topToolBar.width * 0.32)
	mainWindow.titleTextBox.localPosition.x = math.floor(mainWindow.topToolBar.width / 2 - mainWindow.titleTextBox.width / 2)
	mainWindow.runButton.localPosition.x = mainWindow.titleTextBox.localPosition.x - mainWindow.runButton.width - 2
	mainWindow.toggleSyntaxHighlightingButton.localPosition.x = mainWindow.runButton.localPosition.x - mainWindow.toggleSyntaxHighlightingButton.width - 2
	mainWindow.addBreakpointButton.localPosition.x = mainWindow.toggleSyntaxHighlightingButton.localPosition.x - mainWindow.addBreakpointButton.width - 2
	mainWindow.toggleLeftToolBarButton.localPosition.x = mainWindow.titleTextBox.localPosition.x + mainWindow.titleTextBox.width + 2
	mainWindow.toggleBottomToolBarButton.localPosition.x = mainWindow.toggleLeftToolBarButton.localPosition.x + mainWindow.toggleLeftToolBarButton.width + 2
	mainWindow.toggleTopToolBarButton.localPosition.x = mainWindow.toggleBottomToolBarButton.localPosition.x + mainWindow.toggleBottomToolBarButton.width + 2

	mainWindow.RAMUsageProgressBar.localPosition.x = mainWindow.toggleTopToolBarButton.localPosition.x + mainWindow.toggleTopToolBarButton.width + 3
	mainWindow.RAMUsageProgressBar.width = mainWindow.topToolBar.width - mainWindow.RAMUsageProgressBar.localPosition.x - 3

	mainWindow.errorMessage.localPosition.x, mainWindow.errorMessage.width = mainWindow.titleTextBox.localPosition.x, mainWindow.titleTextBox.width
	mainWindow.errorMessage.backgroundPanel.width, mainWindow.errorMessage.errorTextBox.width = mainWindow.errorMessage.width, mainWindow.errorMessage.width - 4

	mainWindow.topMenu.width = mainWindow.width
end

local function changeScale(newScale)
	buffer.changeResolution(ecs.getScaledResolution(newScale))
	calculateSizes()
	mainWindow:draw()
	buffer.draw()
	config.screenScale = newScale
end

local function scalePlus()
	if config.screenScale > 0.3 then changeScale(config.screenScale - 0.1); saveConfig() end
end

local function scaleMinus()
	if config.screenScale < 1 then changeScale(config.screenScale + 0.1); saveConfig() end
end

local function updateTitle()
	if not mainWindow.topToolBar.isHidden then
		if mainWindow.errorMessage.isHidden then
			mainWindow.titleTextBox.lines[1] = string.limit(localization.file .. ": " .. (mainWindow.leftTreeView.currentFile or localization.none), mainWindow.titleTextBox.width - 4)
			mainWindow.titleTextBox.lines[2] = string.limit(localization.cursor .. cursor.position.line .. localization.line .. cursor.position.symbol .. localization.symbol, mainWindow.titleTextBox.width - 4)
			if mainWindow.codeView.selections[1] then
				local countOfSelectedLines = mainWindow.codeView.selections[1].to.line - mainWindow.codeView.selections[1].from.line + 1
				local countOfSelectedSymbols
				if mainWindow.codeView.selections[1].from.line == mainWindow.codeView.selections[1].to.line then
					countOfSelectedSymbols = unicode.len(unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].from.line], mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].to.symbol))
				else
					countOfSelectedSymbols = unicode.len(unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].from.line], mainWindow.codeView.selections[1].from.symbol, -1))
					for line = mainWindow.codeView.selections[1].from.line + 1, mainWindow.codeView.selections[1].to.line - 1 do
						countOfSelectedSymbols = countOfSelectedSymbols + unicode.len(mainWindow.codeView.lines[line])
					end
					countOfSelectedSymbols = countOfSelectedSymbols + unicode.len(unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].to.line], 1, mainWindow.codeView.selections[1].to.symbol))
				end
				mainWindow.titleTextBox.lines[3] = string.limit(localization.selection .. countOfSelectedLines .. localization.lines .. countOfSelectedSymbols .. localization.symbols, mainWindow.titleTextBox.width - 4)
			else
				mainWindow.titleTextBox.lines[3] = string.limit(localization.selection .. localization.none, mainWindow.titleTextBox.width - 4)
			end
		else
			mainWindow.titleTextBox.lines[1], mainWindow.titleTextBox.lines[3] = " ", " "
			if breakpointLine then
				mainWindow.titleTextBox.lines[2] = localization.debugging .. cursor.position.line
			else
				mainWindow.titleTextBox.lines[2] = localization.runtimeError
			end
		end
	end
end

local function calculateErrorMessageSizeAndBeep()
	mainWindow.errorMessage.height = 2 + #mainWindow.errorMessage.errorTextBox.lines
	mainWindow.errorMessage.backgroundPanel.height = mainWindow.errorMessage.height
	mainWindow.errorMessage.errorTextBox.height = mainWindow.errorMessage.height - 2

	updateTitle()
	mainWindow:draw()
	buffer.draw()

	for i = 1, 3 do component.computer.beep(1500, 0.08) end
end

local function showBreakpointMessage(variables)
	mainWindow.titleTextBox.colors.background, mainWindow.titleTextBox.colors.text = colors.title.onError.background, colors.title.onError.text
	mainWindow.errorMessage.isHidden = false

	mainWindow.errorMessage.errorTextBox:setAlignment(GUI.alignment.horizontal.center, GUI.alignment.vertical.top)
	mainWindow.errorMessage.errorTextBox.lines = {}

	for variable, value in pairs(variables) do
		table.insert(mainWindow.errorMessage.errorTextBox.lines, variable .. " = " .. value)
	end

	if #mainWindow.errorMessage.errorTextBox.lines > 0 then
		table.insert(mainWindow.errorMessage.errorTextBox.lines, 1, " ")
		table.insert(mainWindow.errorMessage.errorTextBox.lines, 1, {text = localization.variables, color = 0x0})
	else
		table.insert(mainWindow.errorMessage.errorTextBox.lines, 1, {text = localization.variablesNotAvailable, color = 0x0})
	end

	calculateErrorMessageSizeAndBeep()
end

local function showErrorMessage(text)
	mainWindow.titleTextBox.colors.background, mainWindow.titleTextBox.colors.text = colors.title.onError.background, colors.title.onError.text
	mainWindow.errorMessage.isHidden = false

	mainWindow.errorMessage.errorTextBox:setAlignment(GUI.alignment.horizontal.left, GUI.alignment.vertical.top)
	mainWindow.errorMessage.errorTextBox.lines = string.wrap({text}, mainWindow.errorMessage.errorTextBox.width)	
	
	calculateErrorMessageSizeAndBeep()
end

local function hideErrorMessage()
	mainWindow.titleTextBox.colors.background, mainWindow.titleTextBox.colors.text = colors.title.default.background, colors.title.default.text
	mainWindow.errorMessage.isHidden = true
end

local function hideSettingsContainer()
	for childIndex = 2, #mainWindow.settingsContainer.children do mainWindow.settingsContainer.children[childIndex] = nil end
	mainWindow.settingsContainer.isHidden = true
	mainWindow:draw()
	buffer.draw()
end

local function clearHighlights()
	if lastErrorLine then
		mainWindow.codeView.highlights[lastErrorLine] = nil
		lastErrorLine = nil
	end

	if breakpointLine then
		mainWindow.codeView.highlights[breakpointLine] = nil
		breakpointLine = nil
	end
end

local function clearSelection()
	mainWindow.codeView.selections[1] = nil
end

local function fixFromLineByCursorPosition()
	if mainWindow.codeView.fromLine > cursor.position.line then
		mainWindow.codeView.fromLine = cursor.position.line
	elseif mainWindow.codeView.fromLine + mainWindow.codeView.height - 2 < cursor.position.line then
		mainWindow.codeView.fromLine = cursor.position.line - mainWindow.codeView.height + 2
	end
end

local function fixFromSymbolByCursorPosition()
	if mainWindow.codeView.fromSymbol > cursor.position.symbol then
		mainWindow.codeView.fromSymbol = cursor.position.symbol
	elseif mainWindow.codeView.fromSymbol + mainWindow.codeView.codeAreaWidth - 3 < cursor.position.symbol then
		mainWindow.codeView.fromSymbol = cursor.position.symbol - mainWindow.codeView.codeAreaWidth + 3
	end
end

local function fixCursorPosition(symbol, line)
	if line < 1 then
		line = 1
	elseif line > #mainWindow.codeView.lines then
		line = #mainWindow.codeView.lines
	end

	local lineLength = unicode.len(mainWindow.codeView.lines[line])
	if symbol < 1 or lineLength == 0 then
		symbol = 1
	elseif symbol > lineLength then
		symbol = lineLength + 1
	end

	return symbol, line
end

local function setCursorPosition(symbol, line)
	cursor.position.symbol, cursor.position.line = fixCursorPosition(symbol, line)
	fixFromLineByCursorPosition()
	fixFromSymbolByCursorPosition()
	clearHighlights()
	hideErrorMessage()
end

local function setCursorPositionAndClearSelection(symbol, line)
	setCursorPosition(symbol, line)
	clearSelection()
end

local function convertScreenCoordinatesToCursorPosition(x, y)
	return x - mainWindow.codeView.codeAreaPosition + mainWindow.codeView.fromSymbol - 1, y - mainWindow.codeView.y + mainWindow.codeView.fromLine
end

local function isClickedOnCodeArea(x, y)
	return
		x >= mainWindow.codeView.codeAreaPosition and
		y >= mainWindow.codeView.y and
		x < mainWindow.width and
		y < mainWindow.codeView.y + mainWindow.codeView.height - 1
end

local function moveCursor(symbolOffset, lineOffset)
	if mainWindow.codeView.selections[1] then
		if symbolOffset < 0 or lineOffset < 0 then
			setCursorPositionAndClearSelection(mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].from.line)
		else
			setCursorPositionAndClearSelection(mainWindow.codeView.selections[1].to.symbol, mainWindow.codeView.selections[1].to.line)
		end
	else
		local newSymbol, newLine = cursor.position.symbol + symbolOffset, cursor.position.line + lineOffset
		
		if symbolOffset < 0 and newSymbol < 1 then
			newLine, newSymbol = newLine - 1, math.huge
		elseif symbolOffset > 0 and newSymbol > unicode.len(mainWindow.codeView.lines[newLine] or "") + 1 then
			newLine, newSymbol = newLine + 1, 1
		end

		setCursorPositionAndClearSelection(newSymbol, newLine)
	end
end

local function setCursorPositionToHome()
	setCursorPositionAndClearSelection(1, 1)
end

local function setCursorPositionToEnd()
	setCursorPositionAndClearSelection(unicode.len(mainWindow.codeView.lines[#mainWindow.codeView.lines]) + 1, #mainWindow.codeView.lines)
end

local function scroll(direction, speed)
	if direction == 1 then
		if mainWindow.codeView.fromLine > speed then
			mainWindow.codeView.fromLine = mainWindow.codeView.fromLine - speed
		else
			mainWindow.codeView.fromLine = 1
		end
	else
		if mainWindow.codeView.fromLine < #mainWindow.codeView.lines - speed then
			mainWindow.codeView.fromLine = mainWindow.codeView.fromLine + speed
		else
			mainWindow.codeView.fromLine = #mainWindow.codeView.lines
		end
	end
end

local function pageUp()
	scroll(1, mainWindow.codeView.height - 2)
end

local function pageDown()
	scroll(-1, mainWindow.codeView.height - 2)
end

local function gotoLine(line)
	mainWindow.codeView.fromLine = math.floor(line - mainWindow.codeView.height / 2) + 1
	if mainWindow.codeView.fromLine < 1 then
		mainWindow.codeView.fromLine = 1
	elseif mainWindow.codeView.fromLine > #mainWindow.codeView.lines then
		mainWindow.codeView.fromLine = #mainWindow.codeView.lines
	end
end

local function selectWord()
	local shittySymbolsRegexp, from, to = "[%s%c%p]"

	for i = cursor.position.symbol, 1, -1 do
		if unicode.sub(mainWindow.codeView.lines[cursor.position.line], i, i):match(shittySymbolsRegexp) then break end
		from = i
	end

	for i = cursor.position.symbol, unicode.len(mainWindow.codeView.lines[cursor.position.line]) do
		if unicode.sub(mainWindow.codeView.lines[cursor.position.line], i, i):match(shittySymbolsRegexp) then break end
		to = i
	end

	if from and to then
		mainWindow.codeView.selections[1] = {
			from = {symbol = from, line = cursor.position.line},
			to = {symbol = to, line = cursor.position.line},
		}
		cursor.position.symbol = to
	end
end

------------------------------------------------------------------------------------------------------------------

local function removeTabs(text)
	local result = text:gsub("\t", string.rep(" ", mainWindow.codeView.indentationWidth))
	return result
end

local function removeWindowsLineEndings(text)
	local result = text:gsub("\r\n", "\n")
	return result
end

local function createInputTextBoxForSettingsWindow(title, placeholder)
	mainWindow.settingsContainer.isHidden = false
	local elementWidth = math.floor(mainWindow.width * 0.3)
	local x, y = math.floor(mainWindow.width / 2 - elementWidth / 2), math.floor(mainWindow.height / 2) - 3
	mainWindow.settingsContainer:addLabel(1, y, mainWindow.settingsContainer.width, 1, 0xFFFFFF, title):setAlignment(GUI.alignment.horizontal.center, GUI.alignment.vertical.top); y = y + 3
	return mainWindow.settingsContainer:addInputTextBox(x, y, elementWidth, 3, 0xCCCCCC, 0x777777, 0xCCCCCC, 0x2D2D2D, "", placeholder)
end

local function newFile()
	mainWindow.codeView.lines = {""}
	mainWindow.codeView.maximumLineLength = 1
	mainWindow.leftTreeView.currentFile = nil
	setCursorPositionAndClearSelection(1, 1)
end

local function loadFile(path)
	newFile()
	local file = io.open(path, "r")
	for line in file:lines() do
		line = removeWindowsLineEndings(removeTabs(line))
		table.insert(mainWindow.codeView.lines, line)
		mainWindow.codeView.maximumLineLength = math.max(mainWindow.codeView.maximumLineLength, unicode.len(line))
	end
	file:close()
	mainWindow.leftTreeView.currentFile = path
end

local function saveFile(path)
	fs.makeDirectory(fs.path(path))
	local file = io.open(path, "w")
	for line = 1, #mainWindow.codeView.lines do
		file:write(mainWindow.codeView.lines[line], "\n")
	end
	file:close()
end

local function open()
	local inputTextBox = createInputTextBoxForSettingsWindow(localization.openFile, localization.pathToFile)
	inputTextBox.validator = function(text)
		if fs.exists(text) then return true end
	end
	inputTextBox.onInputFinished = function()
		loadFile(inputTextBox.text)
		hideSettingsContainer()
	end
end

local function saveAs()
	local inputTextBox = createInputTextBoxForSettingsWindow(localization.saveAs, localization.pathToFile)
	inputTextBox.onInputFinished = function()
		saveFile(inputTextBox.text)
		mainWindow.leftTreeView.currentFile = inputTextBox.text
		mainWindow.leftTreeView:updateFileList()
		hideSettingsContainer()
	end
end

local function save()
	saveFile(mainWindow.leftTreeView.currentFile)
end

local function splitStringIntoLines(s)
	s = removeWindowsLineEndings(removeTabs(s))

	local lines, searchLineEndingFrom, maximumLineLength, lineEndingFoundAt, line = {}, 1, 0
	repeat
		lineEndingFoundAt = string.unicodeFind(s, "\n", searchLineEndingFrom)
		if lineEndingFoundAt then
			line = unicode.sub(s, searchLineEndingFrom, lineEndingFoundAt - 1)
			searchLineEndingFrom = lineEndingFoundAt + 1
		else
			line = unicode.sub(s, searchLineEndingFrom, -1)
		end

		table.insert(lines, line)
		maximumLineLength = math.max(maximumLineLength, unicode.len(line))
	until not lineEndingFoundAt

	return lines, maximumLineLength
end

local function downloadFromWeb()
	local inputTextBox = createInputTextBoxForSettingsWindow(localization.getFromWeb, localization.url)
	inputTextBox.onInputFinished = function()
		local success, reason = ecs.internetRequest(inputTextBox.text)
		if success then
			newFile()
			mainWindow.codeView.lines, mainWindow.codeView.maximumLineLength = splitStringIntoLines(reason)
			hideSettingsContainer()
		else
			GUI.error(reason, {title = {color = 0xFFDB40, text = "Failed to connect to URL"}})
		end
	end
end

------------------------------------------------------------------------------------------------------------------

local function addErrorLine(line)
	lastErrorLine = line
	mainWindow.codeView.highlights[line] = colors.highlights.onError
end

local function addBreakpoint()
	clearHighlights()
	breakpointLine = cursor.position.line
	mainWindow.codeView.highlights[breakpointLine] = colors.highlights.onBreakpoint
end

local function getVariables(codePart)
	local variables = {}
	-- –°–Ω–∞—á–∞–ª–∞ –º—ã –ø—Ä–æ–≤–µ—Ä—è–µ–º —É—á–∞—Å—Ç–æ–∫ –∫–æ–¥–∞ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤
	if
		not codePart:match("^%-%-") and
		not codePart:match("^[\t%s]+%-%-")
	then
		-- –ó–∞—Ç–µ–º –∑–∞–º–µ–Ω—è–µ–º –≤—Å–µ —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –∫—É—Å–∫–∏ –≤ —É—á–∞—Å—Ç–∫–µ –∫–æ–¥–∞ –Ω–∞ "–Ω–∏—á–µ–≥–æ", —á—Ç–æ–±—ã –Ω–∞—à "–ø—Ä–µ–∫—Ä–∞—Å–Ω—ã–π" –ø–∞—Ä—Å–µ—Ä –Ω–µ –∏—Å–∫–∞–ª –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –≤ —Å—Ç—Ä–æ–∫–∞—Ö
		codePart = codePart:gsub("\"[^\"]+\"", "")
		-- –ü–æ—Ç–æ–º —Ä–∞–∑–±–∏–≤–∞–µ–º –∫–æ–¥ –Ω–∞ –æ—Ç–¥–µ–ª—å–Ω—ã–µ –±—É–∫–≤–µ–Ω–Ω–æ-—Ü–∏—Ñ—Ä–æ–≤—ã–µ —Å–ª–æ–≤–∞, –Ω–µ –∑–∞–±—ã–≤ —Ç–æ—á–µ—á–∫—É —Å –¥–≤–æ–µ—Ç–æ—á–∏–µ–º
		for word in codePart:gmatch("[%a%d%.%:%_]+") do
			-- –î–∞–ª–µ–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç –ª–∏ —ç—Ç–æ —Å–ª–æ–≤–æ —Å –æ–¥–Ω–∏–º –∏–∑ –ª—É–∞-—à–∞–±–ª–æ–Ω–æ–≤, —Ç–æ –±–∏—à—å, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ–Ω–æ —á–∞—Å—Ç—å—é —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞
			if
				word ~= "local" and
				word ~= "return" and
				word ~= "while" and
				word ~= "repeat" and
				word ~= "until" and
				word ~= "for" and
				word ~= "in" and
				word ~= "do" and
				word ~= "if" and
				word ~= "then" and
				word ~= "else" and
				word ~= "elseif" and
				word ~= "end" and
				word ~= "function" and
				word ~= "true" and
				word ~= "false" and
				word ~= "nil" and
				word ~= "not" and
				word ~= "and" and
				word ~= "or"  and
				-- –¢–∞–∫–∂–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —á–∏—Å–ª–æ –ª–∏ —ç—Ç–æ –≤ —á–∏—Å—Ç–æ–º –≤–∏–¥–µ
				not word:match("^%d+$") and
				not word:match("^0x%x+$") and
				-- –ò–ª–∏ —Å–∏–º–≤–æ–ª –∫–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä
				not word:match("^%.+$")
			then
				variables[word] = true
			end
		end
	end

	return variables
end

local function createBreakpointError(variables)
	local errorMessage = "error({variables={"

	for variable in pairs(variables) do
		errorMessage = errorMessage .. "[\"" .. variable .. "\"] = type(" .. variable .. ") == \"string\" and \"\\\"\" .. " .. variable .. " .. \"\\\"\" or tostring(" .. variable .. "),"
	end

	return errorMessage .. "}})"
end

local function run()
	if breakpointLine then
		table.insert(mainWindow.codeView.lines, breakpointLine, createBreakpointError(getVariables(mainWindow.codeView.lines[breakpointLine])))
	end

	local loadSuccess, loadReason = load(table.concat(mainWindow.codeView.lines, "\n"))
	if loadSuccess then
		local oldResolutionX, oldResolutionY = component.gpu.getResolution()
		component.gpu.setBackground(0x1B1B1B)
		component.gpu.setForeground(0xFFFFFF)
		component.gpu.fill(1, 1, oldResolutionX, oldResolutionY, " ")
		term.setCursor(1, 1)
		
		local xpcallSuccess, xpcallReason = xpcall(loadSuccess, debug.traceback)
		local xpcallReasonType = type(xpcallReason)

		if breakpointLine then
			table.remove(mainWindow.codeView.lines, breakpointLine)
		end

		if xpcallSuccess or (xpcallReasonType == "table" and xpcallReason.terminated == true) then
			MineOSCore.waitForPressingAnyKey()
		end

		buffer.changeResolution(oldResolutionX, oldResolutionY)	

		if not xpcallSuccess then
			if xpcallReasonType == "table" then
				if xpcallReason.variables then
					gotoLine(breakpointLine)
					showBreakpointMessage(xpcallReason.variables)
				end
			else
				showErrorMessage(xpcallReason)
			end
		end

		mainWindow:draw()
		buffer:draw()		
	else
		addErrorLine(tonumber(loadReason:match("^%[.+%]%:(%d+)%:")))
		gotoLine(lastErrorLine)
		showErrorMessage(loadReason)
	end
end

local function deleteLine(line)
	if #mainWindow.codeView.lines > 1 then
		table.remove(mainWindow.codeView.lines, line)
		setCursorPositionAndClearSelection(1, cursor.position.line)
	end
end

local function deleteSpecifiedData(fromSymbol, fromLine, toSymbol, toLine)
	local upperLine = unicode.sub(mainWindow.codeView.lines[fromLine], 1, fromSymbol - 1)
	local lowerLine = unicode.sub(mainWindow.codeView.lines[toLine], toSymbol + 1, -1)
	for line = fromLine + 1, toLine do
		table.remove(mainWindow.codeView.lines, fromLine + 1)
	end
	mainWindow.codeView.lines[fromLine] = upperLine .. lowerLine
	setCursorPositionAndClearSelection(fromSymbol, fromLine)
end

local function deleteSelectedData()
	if mainWindow.codeView.selections[1] then
		deleteSpecifiedData(
			mainWindow.codeView.selections[1].from.symbol,
			mainWindow.codeView.selections[1].from.line,
			mainWindow.codeView.selections[1].to.symbol,
			mainWindow.codeView.selections[1].to.line
		)
		clearSelection()
	end
end

local function copy()
	if mainWindow.codeView.selections[1] then
		if mainWindow.codeView.selections[1].to.line == mainWindow.codeView.selections[1].from.line then
			clipboard = { unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].from.line], mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].to.symbol) }
		else
			clipboard = { unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].from.line], mainWindow.codeView.selections[1].from.symbol, -1) }
			for line = mainWindow.codeView.selections[1].from.line + 1, mainWindow.codeView.selections[1].to.line - 1 do
				table.insert(clipboard, mainWindow.codeView.lines[line])
			end
			table.insert(clipboard, unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].to.line], 1, mainWindow.codeView.selections[1].to.symbol))
		end
	end
end

local function cut()
	if mainWindow.codeView.selections[1] then
		copy()
		deleteSelectedData()
	end
end

local function paste(pasteLines)
	if pasteLines then
		if mainWindow.codeView.selections[1] then
			deleteSelectedData()
		end

		local firstPart = unicode.sub(mainWindow.codeView.lines[cursor.position.line], 1, cursor.position.symbol - 1)
		local secondPart = unicode.sub(mainWindow.codeView.lines[cursor.position.line], cursor.position.symbol, -1)

		if #pasteLines == 1 then
			mainWindow.codeView.lines[cursor.position.line] = firstPart .. pasteLines[1] .. secondPart
			setCursorPositionAndClearSelection(cursor.position.symbol + unicode.len(pasteLines[1]), cursor.position.line)
		else
			mainWindow.codeView.lines[cursor.position.line] = firstPart .. pasteLines[1]
			for pasteLine = #pasteLines - 1, 2, -1 do
				table.insert(mainWindow.codeView.lines, cursor.position.line + 1, pasteLines[pasteLine])
			end
			table.insert(mainWindow.codeView.lines, cursor.position.line + #pasteLines - 1, pasteLines[#pasteLines] .. secondPart)
			setCursorPositionAndClearSelection(unicode.len(pasteLines[#pasteLines]) + 1, cursor.position.line + #pasteLines - 1)
		end
	end
end

local function pasteRegularChar(unicodeByte, char)
	if not keyboard.isControl(unicodeByte) then
		deleteSelectedData()
		paste({char})
	end
end

local function pasteAutoBrackets(unicodeByte)
	local char = unicode.char(unicodeByte)
	local currentSymbol = unicode.sub(mainWindow.codeView.lines[cursor.position.line], cursor.position.symbol, cursor.position.symbol)

	-- –ï—Å–ª–∏ —É –Ω–∞—Å –≤–æ–æ–±—â–µ –≤—Ä—É–±–ª–µ–Ω —Ä–µ–∂–∏–º –∞–≤—Ç–æ—Å–∫–æ–±–æ–∫, —Ç–æ —á–µ–∫–∞–µ–º –∏—Ö
	if config.enableAutoBrackets then
		-- –°–∏—Ç—É–∞—Ü–∏—è, –∫–æ–≥–¥–∞ –∫—É—Ä—Å–æ—Ä –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–∞ –∑–∞–∫—Ä—ã–≤–∞—é—â–µ–π —Å–∫–æ–±–∫–µ, –∏ –Ω–µ—Ö—É–π –µ–µ –µ—â–µ —Ä–∞–∑ –≤—Å—Ç–∞–≤–ª—è—Ç—å
		if possibleBrackets.closers[char] and currentSymbol == char then
			deleteSelectedData()
			setCursorPosition(cursor.position.symbol + 1, cursor.position.line)
		-- –ï—Å–ª–∏ –Ω–∞–∂–∞—Ç–∞ –æ—Ç–∫—Ä—ã–≤–∞—é—â–∞—è —Å–∫–æ–±–∫–∞
		elseif possibleBrackets.openers[char] then
			-- –ê –≤–æ—Ç —Ç—É—Ç –º—ã –±–µ—Ä–µ–º –≤ —Å–∫–æ–±–æ—á–∫–∏ —É–∂–µ –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç
			if mainWindow.codeView.selections[1] then
				local firstPart = unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].from.line], 1, mainWindow.codeView.selections[1].from.symbol - 1)
				local secondPart = unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].from.line], mainWindow.codeView.selections[1].from.symbol, -1)
				mainWindow.codeView.lines[mainWindow.codeView.selections[1].from.line] = firstPart .. char .. secondPart
				mainWindow.codeView.selections[1].from.symbol = mainWindow.codeView.selections[1].from.symbol + 1

				if mainWindow.codeView.selections[1].to.line == mainWindow.codeView.selections[1].from.line then
					mainWindow.codeView.selections[1].to.symbol = mainWindow.codeView.selections[1].to.symbol + 1
				end

				firstPart = unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].to.line], 1, mainWindow.codeView.selections[1].to.symbol)
				secondPart = unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].to.line], mainWindow.codeView.selections[1].to.symbol + 1, -1)
				mainWindow.codeView.lines[mainWindow.codeView.selections[1].to.line] = firstPart .. possibleBrackets.openers[char] .. secondPart
			-- –ê —Ç—É—Ç –º—ã –¥–µ–ª–∞–µ–º –¥–≤–æ–π–Ω—É—é –∞–≤—Ç–æ—Å–∫–æ–±–∫—É, –µ—Å–ª–∏ –º–æ–∂–µ–º
			elseif possibleBrackets.openers[char] and not currentSymbol:match("[%a%d%_]") then
				paste({char .. possibleBrackets.openers[char]})
				setCursorPosition(cursor.position.symbol - 1, cursor.position.line)
				cursor.blinkState = false
			-- –ù—É, –∏ –µ—Å–ª–∏ –Ω–µ—Ç –Ω–∏ –≤—ã–¥–µ–ª–µ–Ω–∏–π, –Ω–∏ –º–æ–∂–µ–º –µ–±–∞–Ω—É—Ç—å –∞–≤—Ç–æ—Å–∫–æ–±–æ—á–∫—É –ø–æ —Ä–µ–≥—É–ª—è—Ä–∫–µ
			else
				pasteRegularChar(unicodeByte, char)
			end
		-- –ï—Å–ª–∏ –º—ã –≤–æ–æ–±—â–µ –Ω–∞ —Å–∫–æ–±–∫—É –Ω–µ –Ω–∞–∂–∏–º–∞–ª–∏
		else
			pasteRegularChar(unicodeByte, char)
		end
	-- –ï—Å–ª–∏ –æ—Ñ—Ñ–Ω—É—Ç—ã –∞—Ñ—Ç–æ—Å–∫–æ–±–∫–∏
	else
		pasteRegularChar(unicodeByte, char)
	end
end

local function backspaceAutoBrackets()	
	local previousSymbol = unicode.sub(mainWindow.codeView.lines[cursor.position.line], cursor.position.symbol - 1, cursor.position.symbol - 1)
	local currentSymbol = unicode.sub(mainWindow.codeView.lines[cursor.position.line], cursor.position.symbol, cursor.position.symbol)
	if config.enableAutoBrackets and possibleBrackets.openers[previousSymbol] and possibleBrackets.openers[previousSymbol] == currentSymbol then
		deleteSpecifiedData(cursor.position.symbol, cursor.position.line, cursor.position.symbol, cursor.position.line)
	end
end

local function delete()
	if mainWindow.codeView.selections[1] then
		deleteSelectedData()
	else
		if cursor.position.symbol < unicode.len(mainWindow.codeView.lines[cursor.position.line]) + 1 then
			deleteSpecifiedData(cursor.position.symbol, cursor.position.line, cursor.position.symbol, cursor.position.line)
		else
			if cursor.position.line > 1 then
				deleteSpecifiedData(unicode.len(mainWindow.codeView.lines[cursor.position.line]) + 1, cursor.position.line, 0, cursor.position.line + 1)
			end
		end
	end
end

local function backspace()
	if mainWindow.codeView.selections[1] then
		deleteSelectedData()
	else
		if cursor.position.symbol > 1 then
			backspaceAutoBrackets()
			deleteSpecifiedData(cursor.position.symbol - 1, cursor.position.line, cursor.position.symbol - 1, cursor.position.line)
		else
			if cursor.position.line > 1 then
				deleteSpecifiedData(unicode.len(mainWindow.codeView.lines[cursor.position.line - 1]) + 1, cursor.position.line - 1, 0, cursor.position.line)
			end
		end
	end
end

local function enter()
	local firstPart = unicode.sub(mainWindow.codeView.lines[cursor.position.line], 1, cursor.position.symbol - 1)
	local secondPart = unicode.sub(mainWindow.codeView.lines[cursor.position.line], cursor.position.symbol, -1)
	mainWindow.codeView.lines[cursor.position.line] = firstPart
	table.insert(mainWindow.codeView.lines, cursor.position.line + 1, secondPart)
	setCursorPositionAndClearSelection(1, cursor.position.line + 1)
end

local function selectAll()
	mainWindow.codeView.selections[1] = {
		from = {
			symbol = 1, line = 1
		},
		to = {
			symbol = unicode.len(mainWindow.codeView.lines[#mainWindow.codeView.lines]), line = #mainWindow.codeView.lines
		}
	}
end

local function isLineCommented(line)
	return mainWindow.codeView.lines[line]:match("%-%-[^%-]")
end

local function commentLine(line)
	mainWindow.codeView.lines[line] = "-- " .. mainWindow.codeView.lines[line]
end

local function uncommentLine(line)
	mainWindow.codeView.lines[line], countOfReplaces = mainWindow.codeView.lines[line]:gsub("%-%-%s", "", 1)
	return countOfReplaces
end

local function toggleComment()
	if mainWindow.codeView.selections[1] then
		local allLinesAreCommented = true
		
		for line = mainWindow.codeView.selections[1].from.line, mainWindow.codeView.selections[1].to.line do
			if not isLineCommented(line) then
				allLinesAreCommented = false
			end
		end
		
		for line = mainWindow.codeView.selections[1].from.line, mainWindow.codeView.selections[1].to.line do
			if allLinesAreCommented then
				uncommentLine(line)
			else
				commentLine(line)
			end
		end

		local modifyer = 3
		if allLinesAreCommented then
			modifyer = -3
		end
		setCursorPosition(cursor.position.symbol + modifyer, cursor.position.line)
		mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].to.symbol = mainWindow.codeView.selections[1].from.symbol + modifyer, mainWindow.codeView.selections[1].to.symbol + modifyer
	else
		if isLineCommented(cursor.position.line) then
			if uncommentLine(cursor.position.line) > 0 then
				setCursorPositionAndClearSelection(cursor.position.symbol - 3, cursor.position.line)
			end
		else
			commentLine(cursor.position.line)
			setCursorPositionAndClearSelection(cursor.position.symbol + 3, cursor.position.line)
		end
	end
end

local function indentLine(line)
	mainWindow.codeView.lines[line] = string.rep(" ", mainWindow.codeView.indentationWidth) .. mainWindow.codeView.lines[line]
end

local function unindentLine(line)
	mainWindow.codeView.lines[line], countOfReplaces = string.gsub(mainWindow.codeView.lines[line], "^" .. string.rep("%s", mainWindow.codeView.indentationWidth), "")
	return countOfReplaces
end

local function indentOrUnindent(isIndent)
	if mainWindow.codeView.selections[1] then
		local countOfReplacesInFirstLine, countOfReplacesInLastLine
		
		for line = mainWindow.codeView.selections[1].from.line, mainWindow.codeView.selections[1].to.line do
			if isIndent then
				indentLine(line)
			else
				local countOfReplaces = unindentLine(line)
				if line == mainWindow.codeView.selections[1].from.line then
					countOfReplacesInFirstLine = countOfReplaces
				elseif line == mainWindow.codeView.selections[1].to.line then
					countOfReplacesInLastLine = countOfReplaces
				end
			end
		end		

		if isIndent then
			setCursorPosition(cursor.position.symbol + mainWindow.codeView.indentationWidth, cursor.position.line)
			mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].to.symbol = mainWindow.codeView.selections[1].from.symbol + mainWindow.codeView.indentationWidth, mainWindow.codeView.selections[1].to.symbol + mainWindow.codeView.indentationWidth
		else
			if countOfReplacesInFirstLine > 0 then
				mainWindow.codeView.selections[1].from.symbol = mainWindow.codeView.selections[1].from.symbol - mainWindow.codeView.indentationWidth
				if cursor.position.line == mainWindow.codeView.selections[1].from.line then
					setCursorPosition(cursor.position.symbol - mainWindow.codeView.indentationWidth, cursor.position.line)
				end
			end

			if countOfReplacesInLastLine > 0 then
				mainWindow.codeView.selections[1].to.symbol = mainWindow.codeView.selections[1].to.symbol - mainWindow.codeView.indentationWidth
				if cursor.position.line == mainWindow.codeView.selections[1].to.line then
					setCursorPosition(cursor.position.symbol - mainWindow.codeView.indentationWidth, cursor.position.line)
				end
			end
		end
	else
		if isIndent then
			indentLine(cursor.position.line)
			setCursorPositionAndClearSelection(cursor.position.symbol + mainWindow.codeView.indentationWidth, cursor.position.line)
		else
			if unindentLine(cursor.position.line) > 0 then
				setCursorPositionAndClearSelection(cursor.position.symbol - mainWindow.codeView.indentationWidth, cursor.position.line)
			end
		end
	end
end

local function updateRAMProgressBar()
	if not mainWindow.topToolBar.isHidden then
		local totalMemory = computer.totalMemory()
		mainWindow.RAMUsageProgressBar.value = math.ceil((totalMemory - computer.freeMemory()) / totalMemory * 100)
	end
end

local function find()
	if not mainWindow.bottomToolBar.isHidden and mainWindow.bottomToolBar.inputTextBox.text ~= "" then
		findStartFrom = findStartFrom + 1
	
		for line = findStartFrom, #mainWindow.codeView.lines do
			local whereToFind, whatToFind = mainWindow.codeView.lines[line], mainWindow.bottomToolBar.inputTextBox.text
			if not mainWindow.bottomToolBar.caseSensitiveButton.pressed then
				whereToFind, whatToFind = unicode.lower(whereToFind), unicode.lower(whatToFind)
			end

			local success, starting, ending = pcall(string.unicodeFind, whereToFind, whatToFind)
			if success then
				if starting then
					mainWindow.codeView.selections[1] = {
						from = {symbol = starting, line = line},
						to = {symbol = ending, line = line},
						color = 0xCC9200
					}
					findStartFrom = line
					gotoLine(line)
					return
				end
			else
				GUI.error("Wrong searching regex", {title = {color = 0xFFDB40, text = "Warning"}})
			end
		end

		findStartFrom = 0
	end
end

local function findFromFirstDisplayedLine()
	findStartFrom = mainWindow.codeView.fromLine
	find()
end

local function toggleBottomToolBar()
	mainWindow.bottomToolBar.isHidden = not mainWindow.bottomToolBar.isHidden
	mainWindow.toggleBottomToolBarButton.pressed = not mainWindow.bottomToolBar.isHidden
	calculateSizes()
		
	if not mainWindow.bottomToolBar.isHidden then
		mainWindow:draw()
		mainWindow.bottomToolBar.inputTextBox:input()
		findFromFirstDisplayedLine()
	end
end

local function toggleTopToolBar()
	mainWindow.topToolBar.isHidden = not mainWindow.topToolBar.isHidden
	mainWindow.toggleTopToolBarButton.pressed = not mainWindow.topToolBar.isHidden
	calculateSizes()
end

local function toggleLeftToolBar()
	mainWindow.leftTreeView.isHidden = not mainWindow.leftTreeView.isHidden
	mainWindow.toggleLeftToolBarButton.pressed = not mainWindow.leftTreeView.isHidden
	calculateSizes()
end

local function createWindow()
	mainWindow = windows.fullScreen()

	mainWindow.codeView = mainWindow:addCodeView(1, 1, 1, 1, {""}, 1, 1, 1, {}, {}, config.highlightLuaSyntax, 2)
	mainWindow.codeView.scrollBars.vertical.onTouch = function()
		mainWindow.codeView.fromLine = mainWindow.codeView.scrollBars.vertical.value
	end
	mainWindow.codeView.scrollBars.horizontal.onTouch = function()
		mainWindow.codeView.fromSymbol = mainWindow.codeView.scrollBars.horizontal.value
	end
	mainWindow.topMenu = mainWindow:addMenu(1, 1, 1, colors.topMenu.backgroundColor, colors.topMenu.textColor, colors.topMenu.backgroundPressedColor, colors.topMenu.textPressedColor)
	
	local item1 = mainWindow.topMenu:addItem("MineCode", 0x0)
	item1.onTouch = function()
		local menu = GUI.contextMenu(item1.x, item1.y + 1)
		menu:addItem(localization.about).onTouch = function()
			mainWindow.settingsContainer.isHidden = false
			local y = math.floor(mainWindow.settingsContainer.height / 2 - #about / 2)
			mainWindow.settingsContainer:addTextBox(1, y, mainWindow.settingsContainer.width, #about, nil, 0xEEEEEE, about, 1):setAlignment(GUI.alignment.horizontal.center, GUI.alignment.vertical.top)
		end
		menu:addItem(localization.quit, false, "^W").onTouch = function()
			mainWindow:close()
		end
		menu:show()
	end

	local item2 = mainWindow.topMenu:addItem(localization.file)
	item2.onTouch = function()
		local menu = GUI.contextMenu(item2.x, item2.y + 1)
		menu:addItem(localization.new, false, "^N").onTouch = function()
			newFile()
		end
		menu:addItem(localization.open, false, "^O").onTouch = function()
			open()
		end
		menu:addItem(localization.getFromWeb, false, "^U").onTouch = function()
			downloadFromWeb()
		end
		menu:addSeparator()
		menu:addItem(localization.save, not mainWindow.leftTreeView.currentFile, "^S").onTouch = function()
			save()
		end
		menu:addItem(localization.saveAs, false, "^‚áßS").onTouch = function()
			saveAs()
		end
		menu:show()
	end

	local item3 = mainWindow.topMenu:addItem(localization.edit)
	item3.onTouch = function()
		local menu = GUI.contextMenu(item3.x, item3.y + 1)
		menu:addItem(localization.cut, not mainWindow.codeView.selections[1], "^X").onTouch = function()
			cut()
		end
		menu:addItem(localization.copy, not mainWindow.codeView.selections[1], "^C").onTouch = function()
			copy()
		end
		menu:addItem(localization.paste, not clipboard, "^V").onTouch = function()
			paste(clipboard)
		end
		menu:addSeparator()
		menu:addItem(localization.comment, false, "^/").onTouch = function()
			toggleComment()
		end
		menu:addItem(localization.indent, false, "Tab").onTouch = function()
			indentOrUnindent(true)
		end
		menu:addItem(localization.unindent, false, "‚áßTab").onTouch = function()
			indentOrUnindent(false)
		end
		menu:addItem(localization.deleteLine, false, "^Del").onTouch = function()
			deleteLine(cursor.position.line)
		end
		menu:addSeparator()
		menu:addItem(localization.selectWord).onTouch = function()
			selectWord()
		end
		menu:addItem(localization.selectAll, false, "^A").onTouch = function()
			selectAll()
		end
		menu:show()
	end

	local item4 = mainWindow.topMenu:addItem(localization.view)
	item4.onTouch = function()
		local menu = GUI.contextMenu(item4.x, item4.y + 1)
		menu:addItem(localization.colorScheme).onTouch = function()
			mainWindow.settingsContainer.isHidden = false
			
			local colorSelectorsCount, colorSelectorCountX = 0, 4; for key in pairs(config.syntaxColorScheme) do colorSelectorsCount = colorSelectorsCount + 1 end
			local colorSelectorCountY = math.ceil(colorSelectorsCount / colorSelectorCountX)
			local colorSelectorWidth, colorSelectorHeight, colorSelectorSpaceX, colorSelectorSpaceY = math.floor(mainWindow.settingsContainer.width / colorSelectorCountX * 0.8), 3, 2, 1
			
			local startX, y = math.floor(mainWindow.settingsContainer.width / 2 - (colorSelectorCountX * (colorSelectorWidth + colorSelectorSpaceX) - colorSelectorSpaceX) / 2), math.floor(mainWindow.settingsContainer.height / 2 - (colorSelectorCountY * (colorSelectorHeight + colorSelectorSpaceY) - colorSelectorSpaceY + 3) / 2)
			mainWindow.settingsContainer:addLabel(1, y, mainWindow.settingsContainer.width, 1, 0xFFFFFF, localization.colorScheme):setAlignment(GUI.alignment.horizontal.center, GUI.alignment.vertical.top); y = y + 3
			local x, counter = startX, 1

			for key in pairs(config.syntaxColorScheme) do
				local colorSelector = mainWindow.settingsContainer:addColorSelector(x, y, colorSelectorWidth, colorSelectorHeight, config.syntaxColorScheme[key], key)
				colorSelector.onTouch = function()
					config.syntaxColorScheme[key] = colorSelector.color
					syntax.colorScheme = config.syntaxColorScheme
					saveConfig()
				end

				x, counter = x + colorSelectorWidth + colorSelectorSpaceX, counter + 1
				if counter > colorSelectorCountX then
					x, y, counter = startX, y + colorSelectorHeight + colorSelectorSpaceY, 1
				end
			end
		end
		menu:addItem(localization.cursorProperties).onTouch = function()
			mainWindow.settingsContainer.isHidden = false

			local elementWidth = math.floor(mainWindow.width * 0.3)
			local x, y = math.floor(mainWindow.width / 2 - elementWidth / 2), math.floor(mainWindow.height / 2) - 7
			mainWindow.settingsContainer:addLabel(1, y, mainWindow.settingsContainer.width, 1, 0xFFFFFF, localization.cursorProperties):setAlignment(GUI.alignment.horizontal.center, GUI.alignment.vertical.top); y = y + 3
			local inputTextBox = mainWindow.settingsContainer:addInputTextBox(x, y, elementWidth, 3, 0xCCCCCC, 0x777777, 0xCCCCCC, 0x2D2D2D, config.cursorSymbol, localization.cursorSymbol); y = y + 5
			inputTextBox.validator = function(text)
				if unicode.len(text) == 1 then return true end
			end
			inputTextBox.onInputFinished = function()
				config.cursorSymbol = inputTextBox.text; saveConfig()
			end
			local colorSelector = mainWindow.settingsContainer:addColorSelector(x, y, elementWidth, 3, config.cursorColor, localization.cursorColor); y = y + 5
			colorSelector.onTouch = function()
				config.cursorColor = colorSelector.color; saveConfig()
			end
			local horizontalSlider = mainWindow.settingsContainer:addHorizontalSlider(x, y, elementWidth, 0xFFDB80, 0x000000, 0xFFDB40, 0xDDDDDD, 1, 1000, config.cursorBlinkDelay * 1000, false, localization.cursorBlinkDelay .. ": ", " ms")
			horizontalSlider.onValueChanged = function()
				config.cursorBlinkDelay = horizontalSlider.value / 1000; saveConfig()
			end
		end

		if mainWindow.topToolBar.isHidden then
			menu:addItem(localization.toggleTopToolBar).onTouch = function()
				toggleTopToolBar()
			end
		end
		if config.enableAutoBrackets then
			menu:addItem(localization.disableAutoBrackets, false, "^]").onTouch = function()
				config.enableAutoBrackets = false
				saveConfig()
			end
		else
			menu:addItem(localization.enableAutoBrackets, false, "^]").onTouch = function()
				config.enableAutoBrackets = true
				saveConfig()
			end
		end

		menu:addSeparator()
		menu:addItem(localization.scalePlus, false, "^+").onTouch = function()
			scalePlus()
		end
		menu:addItem(localization.scaleMinus, false, "^-").onTouch = function()
			scaleMinus()
		end
		menu:show()
	end

	local item5 = mainWindow.topMenu:addItem(localization.gotoCyka)
	item5.onTouch = function()
		local menu = GUI.contextMenu(item5.x, item5.y + 1)
		menu:addItem(localization.pageUp, false, "PgUp").onTouch = function()
			pageUp()
		end
		menu:addItem(localization.pageDown, false, "PgDn").onTouch = function()
			pageDown()
		end
		menu:addItem(localization.gotoStart, false, "Home").onTouch = function()
			setCursorPositionToHome()
		end
		menu:addItem(localization.gotoEnd, false, "End").onTouch = function()
			setCursorPositionToEnd()
		end
		menu:show()
	end

	mainWindow.topToolBar = mainWindow:addContainer(1, 2, 1, 3)
	mainWindow.topToolBar.backgroundPanel = mainWindow.topToolBar:addPanel(1, 1, 1, 3, colors.topToolBar)
	mainWindow.titleTextBox = mainWindow.topToolBar:addTextBox(1, 1, 1, 3, 0x0, 0x0, {}, 1):setAlignment(GUI.alignment.horizontal.center, GUI.alignment.vertical.top)
	local titleTextBoxOldDraw = mainWindow.titleTextBox.draw
	mainWindow.titleTextBox.draw = function(titleTextBox)
		titleTextBoxOldDraw(titleTextBox)
		local sidesColor = mainWindow.errorMessage.isHidden and colors.title.default.sides or colors.title.onError.sides
		buffer.square(titleTextBox.x, titleTextBox.y, 1, titleTextBox.height, sidesColor, titleTextBox.colors.text, " ")
		buffer.square(titleTextBox.x + titleTextBox.width - 1, titleTextBox.y, 1, titleTextBox.height, sidesColor, titleTextBox.colors.text, " ")
	end

	mainWindow.RAMUsageProgressBar = mainWindow.topToolBar:addProgressBar(1, 2, 1, 0x777777, 0xBBBBBB, 0xAAAAAA, 50, true, true, "RAM: ", "%")

	--‚òØ‚óå‚ò∫
	mainWindow.addBreakpointButton = mainWindow.topToolBar:addAdaptiveButton(1, 1, 3, 1, 0x878787, 0xEEEEEE, 0xCCCCCC, 0x444444, "x")
	mainWindow.addBreakpointButton.onTouch = function()
		addBreakpoint()
	end

	mainWindow.toggleSyntaxHighlightingButton = mainWindow.topToolBar:addAdaptiveButton(1, 1, 3, 1, 0xCCCCCC, 0x444444, 0x696969, 0xEEEEEE, "‚óå")
	mainWindow.toggleSyntaxHighlightingButton.switchMode, mainWindow.toggleSyntaxHighlightingButton.pressed = true, true
	mainWindow.toggleSyntaxHighlightingButton.onTouch = function()
		mainWindow.codeView.highlightLuaSyntax = not mainWindow.codeView.highlightLuaSyntax
		config.highlightLuaSyntax = mainWindow.codeView.highlightLuaSyntax
		saveConfig()
	end

	mainWindow.runButton = mainWindow.topToolBar:addAdaptiveButton(1, 1, 3, 1, 0x4B4B4B, 0xEEEEEE, 0xCCCCCC, 0x444444, "‚ñ∑")
	mainWindow.runButton.onTouch = function()
		run()
	end

	mainWindow.toggleLeftToolBarButton = mainWindow.topToolBar:addAdaptiveButton(1, 1, 3, 1, 0xCCCCCC, 0x444444, 0x4B4B4B, 0xEEEEEE, "‚á¶")
	mainWindow.toggleLeftToolBarButton.switchMode, mainWindow.toggleLeftToolBarButton.pressed = true, true
	mainWindow.toggleLeftToolBarButton.onTouch = function()
		mainWindow.leftTreeView.isHidden = not mainWindow.toggleLeftToolBarButton.pressed
		calculateSizes()
	end

	mainWindow.toggleBottomToolBarButton = mainWindow.topToolBar:addAdaptiveButton(1, 1, 3, 1, 0xCCCCCC, 0x444444, 0x696969, 0xEEEEEE, "‚á©")
	mainWindow.toggleBottomToolBarButton.switchMode, mainWindow.toggleBottomToolBarButton.pressed = true, false
	mainWindow.toggleBottomToolBarButton.onTouch = function()
		mainWindow.bottomToolBar.isHidden = not mainWindow.toggleBottomToolBarButton.pressed
		calculateSizes()
	end

	mainWindow.toggleTopToolBarButton = mainWindow.topToolBar:addAdaptiveButton(1, 1, 3, 1, 0xCCCCCC, 0x444444, 0x878787, 0xEEEEEE, "‚áß")
	mainWindow.toggleTopToolBarButton.switchMode, mainWindow.toggleTopToolBarButton.pressed = true, true
	mainWindow.toggleTopToolBarButton.onTouch = function()
		mainWindow.topToolBar.isHidden = not mainWindow.toggleTopToolBarButton.pressed
		calculateSizes()
	end

	mainWindow.bottomToolBar = mainWindow:addContainer(1, 1, 1, 1)
	mainWindow.bottomToolBar.caseSensitiveButton = mainWindow.bottomToolBar:addAdaptiveButton(1, 1, 2, 1, 0x3C3C3C, 0xEEEEEE, 0xBBBBBB, 0x2D2D2D, "Aa")
	mainWindow.bottomToolBar.caseSensitiveButton.switchMode = true
	mainWindow.bottomToolBar.onTouch = function()
		find()
	end
	mainWindow.bottomToolBar.inputTextBox = mainWindow.bottomToolBar:addInputTextBox(7, 1, 10, 3, 0xCCCCCC, 0x999999, 0xCCCCCC, 0x2D2D2D, "", localization.findSomeShit)
	mainWindow.bottomToolBar.inputTextBox.onInputFinished = function()
		findFromFirstDisplayedLine()
	end
	mainWindow.bottomToolBar.findButton = mainWindow.bottomToolBar:addAdaptiveButton(1, 1, 3, 1, 0x3C3C3C, 0xEEEEEE, 0xBBBBBB, 0x2D2D2D, localization.find)
	mainWindow.bottomToolBar.findButton.onTouch = function()
		find()
	end
	mainWindow.bottomToolBar.isHidden = true

	mainWindow.leftTreeView = mainWindow:addTreeView(1, 1, 1, 1, colors.leftTreeView.background, 0x3C3C3C, 0x3C3C3C, 0xEEEEEE, 0x888888, 0x444444, 0x00DBFF, "/")
	mainWindow.leftTreeView.onFileSelected = function(path)
		loadFile(path)
	end

	mainWindow.errorMessage = mainWindow:addContainer(1, 1, 1, 1)
	mainWindow.errorMessage.backgroundPanel = mainWindow.errorMessage:addPanel(1, 1, 1, 1, 0xFFFFFF, 30)
	mainWindow.errorMessage.errorTextBox = mainWindow.errorMessage:addTextBox(3, 2, 1, 1, nil, 0x4B4B4B, {}, 1)
	hideErrorMessage()

	mainWindow.settingsContainer = mainWindow:addContainer(1, 1, 1, 1)
	mainWindow.settingsContainer.backgroundPanel = mainWindow.settingsContainer:addPanel(1, 1, mainWindow.settingsContainer.width, mainWindow.settingsContainer.height, 0x0, 30)
	mainWindow.settingsContainer.backgroundPanel.onTouch = hideSettingsContainer
	mainWindow.settingsContainer.isHidden = true

	mainWindow.onAnyEvent = function(eventData)		
		if eventData[1] == "touch" and isClickedOnCodeArea(eventData[3], eventData[4]) then
			cursor.blinkState = true
			
			if eventData[5] == 1 then
				local menu = GUI.contextMenu(eventData[3], eventData[4])
				menu:addItem(localization.cut, not mainWindow.codeView.selections[1], "^X").onTouch = function()
					cut()
				end
				menu:addItem(localization.copy, not mainWindow.codeView.selections[1], "^C").onTouch = function()
					copy()
				end
				menu:addItem(localization.paste, not clipboard, "^V").onTouch = function()
					paste(clipboard)
				end
				menu:addSeparator()
				menu:addItem(localization.selectWord).onTouch = function()
					selectWord()
				end
				menu:addItem(localization.selectAll, false, "^A").onTouch = function()
					selectAll()
				end
				menu:show()
			else
				setCursorPositionAndClearSelection(convertScreenCoordinatesToCursorPosition(eventData[3], eventData[4]))

				local newUptime = computer.uptime()
				if newUptime - lastClickUptime <= config.doubleClickDelay then selectWord() end
				lastClickUptime = newUptime
			end
		elseif eventData[1] == "drag" and isClickedOnCodeArea(eventData[3], eventData[4]) then
			cursor.blinkState = true
			
			if eventData[5] ~= 1 then
				mainWindow.codeView.selections[1] = mainWindow.codeView.selections[1] or {from = {}, to = {}}
				mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].from.line = cursor.position.symbol, cursor.position.line
				mainWindow.codeView.selections[1].to.symbol, mainWindow.codeView.selections[1].to.line = fixCursorPosition(convertScreenCoordinatesToCursorPosition(eventData[3], eventData[4]))
				
				if mainWindow.codeView.selections[1].from.line > mainWindow.codeView.selections[1].to.line then
					mainWindow.codeView.selections[1].from.line, mainWindow.codeView.selections[1].to.line = swap(mainWindow.codeView.selections[1].from.line, mainWindow.codeView.selections[1].to.line)
					mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].to.symbol = swap(mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].to.symbol)
				elseif mainWindow.codeView.selections[1].from.line == mainWindow.codeView.selections[1].to.line then
					if mainWindow.codeView.selections[1].from.symbol > mainWindow.codeView.selections[1].to.symbol then
						mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].to.symbol = swap(mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].to.symbol)
					end
				end
			end
		elseif eventData[1] == "key_down" then
			cursor.blinkState = true

			-- Ctrl or CMD
			if keyboard.isKeyDown(29) or keyboard.isKeyDown(219) then
				-- Slash
				if eventData[4] == 53 then
					toggleComment()
				-- ]
				elseif eventData[4] == 27 then
					config.enableAutoBrackets = not config.enableAutoBrackets
					saveConfig()
				-- A
				elseif eventData[4] == 30 then
					selectAll()
				-- C
				elseif eventData[4] == 46 then
					copy()
				-- V
				elseif eventData[4] == 47 then
					paste(clipboard)
				-- X
				elseif eventData[4] == 45 then
					cut()
				-- W
				elseif eventData[4] == 17 then
					mainWindow:close()
				-- N
				elseif eventData[4] == 49 then
					newFile()
				-- O
				elseif eventData[4] == 24 then
					open()
				-- U
				elseif eventData[4] == 22 then
					downloadFromWeb()
				-- S
				elseif eventData[4] == 31 then
					-- Shift
					if mainWindow.leftTreeView.currentFile and not keyboard.isKeyDown(42) then
						save()
					else
						saveAs()
					end
				-- F
				elseif eventData[4] == 33 then
					toggleBottomToolBar()
				-- G
				elseif eventData[4] == 34 then
					find()
				-- Backspace
				elseif eventData[4] == 14 then
					deleteLine(cursor.position.line)
				-- Delete
				elseif eventData[4] == 211 then
					deleteLine(cursor.position.line)
				-- +
				elseif eventData[4] == 13 then
					scalePlus()
				-- -
				elseif eventData[4] == 12 then
					scaleMinus()
				end
			-- Arrows up, down, left, right
			elseif eventData[4] == 200 then
				moveCursor(0, -1)
			elseif eventData[4] == 208 then
				moveCursor(0, 1)
			elseif eventData[4] == 203 then
				moveCursor(-1, 0)
			elseif eventData[4] == 205 then
				moveCursor(1, 0)
			-- Backspace
			elseif eventData[4] == 14 then
				backspace()
			-- Tab
			elseif eventData[4] == 15 then
				if keyboard.isKeyDown(42) then
					indentOrUnindent(false)
				else
					indentOrUnindent(true)
				end
			-- Enter
			elseif eventData[4] == 28 then
				enter()
			-- F5
			elseif eventData[4] == 63 then
				run()
			-- Home
			elseif eventData[4] == 199 then
				setCursorPositionToHome()
			-- End
			elseif eventData[4] == 207 then
				setCursorPositionToEnd()
			-- Page Up
			elseif eventData[4] == 201 then
				pageUp()
			-- Page Down
			elseif eventData[4] == 209 then
				pageDown()
			-- Delete
			elseif eventData[4] == 211 then
				delete()
			else
				pasteAutoBrackets(eventData[3])
			end
		elseif eventData[1] == "clipboard" then
			paste(splitStringIntoLines(eventData[3]))
		elseif eventData[1] == "scroll" then
			if isClickedOnCodeArea(eventData[3], eventData[4]) then
				scroll(eventData[5], config.scrollSpeed)
			end
		elseif eventData[1] == "component_added" or eventData[1] == "component_removed" then
			if eventData[3] == "screen" then
				os.sleep(0.5)
				changeScale(config.screenScale)
			end
		elseif not eventData[1] then
			cursor.blinkState = not cursor.blinkState
		end

		updateTitle()
		updateRAMProgressBar()
		mainWindow:draw()
		if cursor.blinkState then
			local x, y = mainWindow.codeView.codeAreaPosition + cursor.position.symbol - mainWindow.codeView.fromSymbol + 1, mainWindow.codeView.y + cursor.position.line - mainWindow.codeView.fromLine
			if 
				x >= mainWindow.codeView.codeAreaPosition + 1 and
				x <= mainWindow.codeView.codeAreaPosition + mainWindow.codeView.codeAreaWidth - 2 and
				y >= mainWindow.codeView.y and
				y <= mainWindow.codeView.y + mainWindow.codeView.height - 2
			then
				buffer.text(x, y, config.cursorColor, config.cursorSymbol)
			end
		end
		buffer.draw()
	end
end

---------------------------------------------------- RUSH B! ----------------------------------------------------

loadConfig()
createWindow()
changeScale(config.screenScale)
updateTitle()
updateRAMProgressBar()
mainWindow:draw()

if args[1] == "open" and fs.exists(args[2] or "") then
	loadFile(args[2])
else
	newFile()
end

mainWindow:draw()
buffer.draw()
mainWindow:handleEvents(config.cursorBlinkDelay)


D/MineOS/Applications/MineCode IDE.app/Resources/D5MineOS/Applications/MineCode IDE.app/Resources/About/F@MineOS/Applications/MineCode IDE.app/Resources/About/Russian.txtΩMineCode IDE - —ç—Ç–æ –º–æ—â–Ω—ã–π –∏–Ω—Å—Ç—É—Ä–º–µ–Ω—Ç –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π —Å –±–æ–≥–∞—Ç—ã–º —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–æ–º: –æ—Ç –ø–æ–¥—Å–≤–µ—Ç–∫–∏ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ Lua, –≤—ã–¥–µ–ª–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ –∏ —Ä–∞–±–æ—Ç—ã —Å –±—É—Ñ–µ—Ä–æ–º –æ–±–º–µ–Ω–∞ –¥–æ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö —Ü–≤–µ—Ç–æ–≤—ã—Ö —Å—Ö–µ–º. –£–¥–æ–±–Ω—ã–π —Ñ–∞–π–ª–æ–≤—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä —Ç–∞–∫–∂–µ –ø—Ä–∏–ª–∞–≥–∞–µ—Ç—Å—è.F7MineOS/Applications/MineCode IDE.app/Resources/Icon.picOCIFA SbF˛B )YScFUB )YSdF¯B )YSeF¯B )YYFUB )YSwF¯B )YShF¯B )YS‚ñÄF÷B )YFˇB )YSiF¯B )YSmFUB )YSlF¯B )YS-FUB )YSnF¯B )YSoFUB )YS F B )YYYSaF˛B )YD<MineOS/Applications/MineCode IDE.app/Resources/Localization/FHMineOS/Applications/MineCode IDE.app/Resources/Localization/English.langf{	
	enableAutoBrackets = "Enable autobrackets",
	disableAutoBrackets = "Disable autobrackets",
	url = "http://example.com/something.lua",
	getFromWeb = "Download from URL",
	debugging = "Debugger on line ",
	runtimeError = "Runtime error",
	variablesNotAvailable = "No variables found",
	variables = "Values of the variables:",
	scalePlus = "Increase scale",
	scaleMinus = "Decrease scale",
	pathToFile = "Path to file",
	selectWord = "Select current word",
	gotoCyka = "Goto",
	gotoEnd = "Scroll to end",
	gotoStart = "Scroll to start",
	pageDown = "Page down",
	pageUp = "Page up",
	deleteLine = "Delete current line",
	cursorProperties = "Cursor properties",
	cursorSymbol = "Symbol",
	cursorColor = "Color",
	cursorBlinkDelay = "Blink delay",
	selection = "Selection: ",
	none = "none",
	view = "View",
	about = "About",
	quit = "Quit from MineCode",
	line = " line, ",
	symbol = " symbol",
	lines = " lines, ",
	symbols = " symbols",
	file = "File",
	cursor = "Cursor: ",
	new = "New",
	open = "Open",
	openFile = "Open file",
	save = "Save",
	saveAs = "Save as",
	colorScheme = "Color scheme",
	color = "Color",
	toggleTopToolBar = "Show top toolbar",
	find = "Find",
	findSomeShit = "Let's find some shit‚Ä¶",
	cut = "Cut",
	copy = "Copy",
	paste = "Paste",
	selectAll = "Select all",
	edit = "Edit",
	comment = "Toggle comment",
	indent = "Indent",
	unindent = "Unindent",
}FHMineOS/Applications/MineCode IDE.app/Resources/Localization/Russian.lang3{
	enableAutoBrackets = "–í–∫–ª—é—á–∏—Ç—å –∞–≤—Ç–æ-—Å–∫–æ–±–∫–∏",
	disableAutoBrackets = "–û—Ç–∫–ª—é—á–∏—Ç—å –∞–≤—Ç–æ-—Å–∫–æ–±–∫–∏",
	url = "http://example.com/something.lua",
	getFromWeb = "–ó–∞–≥—Ä—É–∑–∏—Ç—å –ø–æ URL",
	debugging = "–û—Ç–ª–∞–¥—á–∏–∫ –Ω–∞ —Å—Ç—Ä–æ–∫–µ ",
	runtimeError = "–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã",
	variablesNotAvailable = "–ù–µ –Ω–∞–π–¥–µ–Ω–æ –≤–æ–∑–º–æ–∂–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö",
	variables = "–ó–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö:",
	scalePlus = "–£–≤–µ–ª–∏—á–∏—Ç—å –º–∞—Å—à—Ç–∞–±",
	scaleMinus = "–£–º–µ–Ω—å—à–∏—Ç—å –º–∞—Å—à—Ç–∞–±",
	pathToFile = "–ü—É—Ç—å –∫ —Ñ–∞–π–ª—É",
	selectWord = "–í—ã–¥–µ–ª–∏—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–ª–æ–≤–æ",
	gotoCyka = "–ü–µ—Ä–µ—Ö–æ–¥",
	gotoEnd = "–í –∫–æ–Ω–µ—Ü",
	gotoStart = "–í –Ω–∞—á–∞–ª–æ",
	pageDown = "–ù–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É –Ω–∏–∂–µ",
	pageUp = "–ù–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É –≤—ã—à–µ",
	deleteLine = "–£–¥–∞–ª–∏—Ç—å —Ç–µ–∫—É—â—É—é —Å—Ç—Ä–æ–∫—É",
	cursorProperties = "–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∫—É—Ä—Å–æ—Ä–∞",
	cursorSymbol = "–°–∏–º–≤–æ–ª",
	cursorColor = "–¶–≤–µ—Ç",
	cursorBlinkDelay = "–í—Ä–µ–º—è –º–∏–≥–∞–Ω–∏—è",
	selection = "–í—ã–¥–µ–ª–µ–Ω–∏–µ: ",
	none = "–Ω–µ—Ç",
	view = "–í–∏–¥",
	about = "–û –ø—Ä–æ–≥—Ä–∞–º–º–µ",
	quit = "–í—ã–π—Ç–∏ –∏–∑ MineCode",
	line = " —Å—Ç—Ä–æ–∫–∞, ",
	symbol = " —Å–∏–º–≤–æ–ª",
	lines = " —Å—Ç—Ä–æ–∫, ",
	symbols = " —Å–∏–º–≤–æ–ª–æ–≤",
	file = "–§–∞–π–ª",
	cursor = "–ö—É—Ä—Å–æ—Ä: ",
	new = "–ù–æ–≤—ã–π",
	open = "–û—Ç–∫—Ä—ã—Ç—å",
	openFile = "–û—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª",
	save = "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
	saveAs = "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫",
	colorScheme = "–¶–≤–µ—Ç–æ–≤–∞—è —Å—Ö–µ–º–∞",
	color = "–¶–≤–µ—Ç",
	toggleTopToolBar = "–ü–æ–∫–∞–∑–∞—Ç—å –ø–∞–Ω–µ–ª—å –∏–Ω—Å—Ç—É—Ä–º–µ–Ω—Ç–æ–≤",
	find = "–ù–∞–π—Ç–∏",
	findSomeShit = "–î–∞–≤–∞–π –Ω–∞–π–¥–µ–º –∫–∞–∫—É—é-–Ω–∏–±—É–¥—å —Ö—É–π–Ω—é‚Ä¶",
	cut = "–í—ã—Ä–µ–∑–∞—Ç—å",
	copy = "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å",
	paste = "–í—Å—Ç–∞–≤–∏—Ç—å",
	selectAll = "–í—ã–¥–µ–ª–∏—Ç—å –≤—Å–µ",
	edit = "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å",
	comment = "–ö–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å",
	indent = "–¢–∞–±—É–ª–∏—Ä–æ–≤–∞—Ç—å",
	unindent = "–î–µ—Ç–∞–±—É–ª–∏—Ä–æ–≤–∞—Ç—å",
}D"MineOS/Applications/Photoshop.app/F/MineOS/Applications/Photoshop.app/Photoshop.lua‚

------------------------------------------------ –ò–Ω—Ñ–æ—Ä–º–µ—à–π–Ω, –µ–ø—Ç–∞ --------------------------------------------------------------

local photoshopVersion = "Photoshop v6.5"

local copyright = [[
	
	Photoshop v6.5 –¥–ª—è OpenComputers

	–ê–≤—Ç–æ—Ä: ECS
		–ö–æ–Ω—Ç–∞–∫—Ç—ã–π –∞–¥—Ä–µ—Å: https://vk.com/id7799889
	–°–æ–∞–≤—Ç–æ—Ä: Pornogion
		–ö–æ–Ω—Ç–∞–∫—Ç—ã–π –∞–¥—Ä–µ—Å: https://vk.com/id88323331

	–ß—Ç–æ –Ω–æ–≤–æ–≥–æ –≤ –≤–µ—Ä—Å–∏–∏ 6.5:
		- –ü–∞–ª–∏—Ç—Ä–∞ –∑–∞–º–µ–Ω–µ–Ω–∞ –Ω–∞ –±–æ–ª–µ–µ –±—ã—Å—Ç—Ä—É—é –∏ —Å—Ç–∏–ª—å–Ω—É—é, —Ä–∞–±–æ—Ç–∞—é—â—É—é –Ω–∞ —Ç—Ä–æ–π–Ω–æ–º –±—É—Ñ–µ—Ä–µ
		- –î–æ–±–∞–≤–ª–µ–Ω–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–∑ —Å—Ç—Ä–æ–∫–∏, —Å–æ–∑–¥–∞–Ω–Ω–æ–π –º–µ—Ç–æ–¥–æ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è OCIFString

	–ß—Ç–æ –Ω–æ–≤–æ–≥–æ –≤ –≤–µ—Ä—Å–∏–∏ 6.4:
		- –î–æ–±–∞–≤–ª–µ–Ω–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –≤—ã–±–æ—Ä–∞ —Ü–≤–µ—Ç–∞ —Å–µ—Ç–∫–∏ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ –≤–æ –≤–∫–ª–∞–¥–∫–µ "–í–∏–¥"

	–ß—Ç–æ –Ω–æ–≤–æ–≥–æ –≤ –≤–µ—Ä—Å–∏–∏ 6.3:
		- –î–æ–±–∞–≤–ª–µ–Ω–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∞ —è–∑—ã–∫–æ–≤—ã—Ö –ø–∞–∫–µ—Ç–æ–≤

	–ß—Ç–æ –Ω–æ–≤–æ–≥–æ –≤ –≤–µ—Ä—Å–∏–∏ 6.2:
		- –î–æ–±–∞–≤–ª–µ–Ω —Å—É–±-–∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç "–ü–æ–ª–∏–≥–æ–Ω"
		- –£–ª—É—á—à–µ–Ω –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç "–í—ã–¥–µ–ª–µ–Ω–∏–µ", —Ç–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –≤—ã–¥–µ–ª—è—Ç—å –æ–±–ª–∞—Å—Ç–∏ —Å —à–∏—Ä–∏–Ω–æ–π –∏–ª–∏ –≤—ã—Å–æ—Ç–æ–π, —Ä–∞–≤–Ω—ã–º–∏ 1

	–ß—Ç–æ –Ω–æ–≤–æ–≥–æ –≤ –≤–µ—Ä—Å–∏–∏ 6.1:
		- –î–æ–±–∞–≤–ª–µ–Ω —Å—É–±-–∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç "–≠–ª–ª–∏–ø—Å"

	–ß—Ç–æ –Ω–æ–≤–æ–≥–æ –≤ –≤–µ—Ä—Å–∏–∏ 6.0:
		- –î–æ–±–∞–≤–ª–µ–Ω –∏—Å—Ç—Ä—É–º–µ–Ω—Ç "–§–∏–≥—É—Ä–∞", –≤–∫–ª—é—á–∞—é—â–∏–π –≤ —Å–µ–±—è –ª–∏–Ω–∏—é, –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –∏ —Ä–∞–º–∫—É
		- –î–æ–±–∞–≤–ª–µ–Ω —Ñ–∏–ª—å—Ç—Ä —Ä–∞–∑–º—ã—Ç–∏—è –ø–æ –ì–∞—É—Å—Å—É
		- –ü–µ—Ä–µ—Ä–∞–±–æ—Ç–∞–Ω–∞ –∫–æ–Ω—Ü–µ–ø—Ü–∏—è —Ä–∞–±–æ—Ç—ã —Å –≤—ã–¥–µ–ª–µ–Ω–∏—è–º–∏

	–ß—Ç–æ –Ω–æ–≤–æ–≥–æ –≤ –≤–µ—Ä—Å–∏–∏ 5.1:
		- –¶–≤–µ—Ç–æ–≤–∞—è –≥–∞–º–º–∞ –ø—Ä–æ–≥—Ä–∞–º–º—ã –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ –±–æ–ª–µ–µ –¥–µ—Ç–∞–ª—å–Ω—É—é
		- –î–æ–±–∞–≤–ª–µ–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –º–∏–Ω–∏-–ø–∞–Ω–µ–ª—å –∫ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—É "–≤—ã–¥–µ–ª–µ–Ω–∏–µ"
		- –î–æ–±–∞–≤–ª–µ–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ä–∞–∑–º–µ—Ä–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º–∞—è –ø–æ–¥ —Å–∞–º–∏–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º
		- –£—Å–∫–æ—Ä–µ–Ω –∞–ª–≥–æ—Ä–∏—Ç–º —Ä–∏—Å–æ–≤–∞–Ω–∏—è –∫–∏—Å—Ç—å—é –∏ –ª–∞—Å—Ç–∏–∫–æ–º

	–ß—Ç–æ –Ω–æ–≤–æ–≥–æ –≤ –≤–µ—Ä—Å–∏–∏ 5.0:
		- –î–æ–±–∞–≤–ª–µ–Ω –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç "–≤—ã–¥–µ–ª–µ–Ω–∏–µ" –∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ—É–Ω–∫—Ü–∏–π –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –Ω–∏–º
		- –î–æ–±–∞–≤–ª–µ–Ω–æ –º–µ–Ω—é "–ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏", –ø–æ–¥—Å–∫–∞–∑—ã–≤–∞—é—â–µ–µ, –∫–∞–∫ –º–æ–∂–Ω–æ —É–¥–æ–±–Ω–µ–µ —Ä–∞–±–æ—Ç–∞—Ç—å —Å –ø—Ä–æ–≥—Ä–∞–º–º–æ–π

	–ß—Ç–æ –Ω–æ–≤–æ–≥–æ –≤ –≤–µ—Ä—Å–∏–∏ 4.0:
		- –ü—Ä–æ–≥—Ä–∞–º–º–∞ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–∞ –Ω–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫—É —Ç—Ä–æ–π–Ω–æ–≥–æ –±—É—Ñ–µ—Ä–∞, —Å–∫–æ—Ä–æ—Å—Ç—å —Ä–∞–±–æ—Ç—ã —É–≤–µ–ª–∏—á–µ–Ω–∞ –≤ –¥–µ—Å—è—Ç–∫–∏ —Ä–∞–∑
		- –î–æ–±–∞–≤–ª–µ–Ω—ã —Ñ—É–Ω–∫—Ü–∏–∏ –æ–±—Ä–µ–∑–∫–∏, —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è, –ø–æ–≤–æ—Ä–æ—Ç–∞ –∏ –æ—Ç—Ä–∞–∂–µ–Ω–∏—è –∫–∞—Ä—Ç–∏–Ω–∫–∏
		- –î–æ–±–∞–≤–ª–µ–Ω—ã —Ñ—É–Ω–∫—Ü–∏–∏ —Ç–æ–Ω–∞/–Ω–∞—Å—ã—â–µ–Ω–Ω–æ—Å—Ç–∏, —Ü–≤–µ—Ç–æ–≤–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞ –∏ –Ω–∞–ª–æ–∂–µ–Ω–∏—è —Ñ–æ—Ç–æ—Ñ–∏–ª—å—Ç—Ä–∞

]]

copyright = nil

------------------------------------------------ –ë–∏–±–ª–∏–æ—Ç–µ–∫–∏ --------------------------------------------------------------

local ecs = require("ECSAPI")
local MineOSCore = require("MineOSCore")
local GUI = require("GUI")
local fs = require("filesystem")
local unicode = require("unicode")
local image = require("image")
local component = require("component")
local keyboard = require("keyboard")
local buffer = require("doubleBuffering")
local colorlib = require("colorlib")
local palette = require("palette")
local event = require("event")

------------------------------------------------ –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ --------------------------------------------------------------

--–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫—É –¥–≤–æ–π–Ω–æ–≥–æ –±—É—Ñ–µ—Ä–∞
buffer.start()

--–ú–∞—Å—Å–∏–≤ –ª–æ–∫–∞–ª–∏–∞—Ü–∏–∏
local localization = MineOSCore.getCurrentApplicationLocalization()

--–ú–∞—Å—Å–∏–≤ –∏–Ω—Ñ—ã –æ –≤—ã–¥–µ–ª–µ–Ω–∏–∏
local selection

--–ü–æ–ª—É—á–∞–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç—ã –ø—Ä–æ–≥—Ä–∞–º–º—ã
local args = {...}

--–ú–∞—Å—Å–∏–≤ –≥–ª–∞–≤–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
local masterPixels = {
	width = 0,
	height = 0,
}

--–ë–∞–∑–æ–≤–∞—è —Ü–≤–µ—Ç–æ–≤–∞—è —Å—Ö–µ–º–∞ –ø—Ä–æ–≥—Ä–∞–º–º—ã
local colors = {
	leftToolbar = 0x3c3c3c,
	leftToolbarButton = 0x2d2d2d,
	leftToolbarButtonText = 0xeeeeee,
	topToolbar = 0x4b4b4b,
	drawingArea = 0x1e1e1e,
	console = 0x2d2d2d,
	consoleText = 0x999999,
	transparencyWhite = 0xffffff,
	transparencyGray = 0xcccccc,
	transparencyVariable = 0xffffff,
	oldBackground = 0x0,
	oldForeground = 0x0,
	topMenu = 0xeeeeee,
	topMenuText = 0x262626,
}

--–†–∞–∑–ª–∏—á–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏ —Ä–∞–∑–º–µ—Ä—ã —Ç—É–ª–±–∞—Ä–æ–≤ –∏ –∫–ª–∏–∫–∞–±–µ–ª—å–Ω—ã—Ö –∑–æ–Ω
local sizes = {
	widthOfLeftBar = 6,
}
sizes.xStartOfDrawingArea = sizes.widthOfLeftBar + 1
sizes.xEndOfDrawingArea = buffer.screen.width
sizes.yStartOfDrawingArea = 2
sizes.yEndOfDrawingArea = buffer.screen.height - 1
sizes.widthOfDrawingArea = sizes.xEndOfDrawingArea - sizes.xStartOfDrawingArea + 1
sizes.heightOfDrawingArea = sizes.yEndOfDrawingArea - sizes.yStartOfDrawingArea + 1
sizes.heightOfLeftBar = buffer.screen.height - 1
sizes.sizeOfPixelData = 4

--–î–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
local function reCalculateImageSizes(x, y)
	sizes.xStartOfImage = x or 9
	sizes.yStartOfImage = y or 6
	sizes.xEndOfImage = sizes.xStartOfImage + masterPixels.width - 1
	sizes.yEndOfImage = sizes.yStartOfImage + masterPixels.height - 1
end
reCalculateImageSizes()

--–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
local instruments = {
	"M",
	"B",
	"E",
	"F",
	"T",
	"S",
}
sizes.heightOfInstrument = 3
sizes.yStartOfInstruments = 2
local currentInstrument = 2
local currentBackground = 0x000000
local currentForeground = 0xFFFFFF
local currentAlpha = 0x00
local currentSymbol = " "
local currentBrushSize = 1
local savePath
local currentShape
local currentPolygonCountOfEdges
local showTransparencyGrid = true

------------------------------------------------ –§—É–Ω–∫—Ü–∏–∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ --------------------------------------------------------------

--–û–±—ä–µ–∫—Ç—ã –¥–ª—è —Ç–∞—á–∞
local obj = {}
local function newObj(class, name, ...)
	obj[class] = obj[class] or {}
	obj[class][name] = {...}
end

--–§—É–Ω–∫—Ü–∏—è-—Å–≤–∞–ø–ø–µ—Ä –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö, –ø–æ–∫–∞ —á—Ç–æ —é–∑–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –≤—ã–¥–µ–ª–µ–Ω–∏–∏
--–ê, –Ω–µ, –Ω–∞–µ–±–∞–ª!
--–í–æ–Ω, –Ω–∏–∂–µ —Ç–æ–∂–µ —é–∑–∞–µ—Ç—Å—è! –•–∞, —É–¥–æ–±–Ω–µ–Ω—å–∫–æ
local function swap(a, b)
	return b, a
end

--–ê–¥–µ–∫–≤–∞—Ç–Ω–æ–µ –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ, –∏–±–æ –≤ –ª—É–∞—à–∫–µ –Ω–µ—Ç —Ç–∞–∫–æ–≥–æ, –•–ê–•
local function round(num) 
	if num >= 0 then
		return math.floor(num + 0.5) 
	else
		return math.ceil(num - 0.5)
	end
end

--–û—Ç—Ä–∏—Å–æ–≤–∫–∞ "–ø—Ä–æ–∑—Ä–∞—á–Ω–æ–π –∑–æ–Ω—ã", —ç—Ç–∞–∫–∞—è —Å–µ—Ç–æ—á–∫–∞ —á–µ—Ä–µ–¥—É—é—â–∞—è—Å—è
local function drawTransparentZone(x, y)
	if showTransparencyGrid then
		y = y - 1

		local stro4ka1 = ""
		local stro4ka2 = ""
		if masterPixels.width % 2 == 0 then
			stro4ka1 = string.rep("‚ñí ", math.floor(masterPixels.width / 2))
			stro4ka2 = stro4ka1
		else
			stro4ka1 = string.rep("‚ñí ", math.floor(masterPixels.width / 2))
			stro4ka2 = stro4ka1 .. "‚ñí"
		end

		for i = 1, masterPixels.height do
			if i % 2 == 0 then
				buffer.square(x, y + i, masterPixels.width, 1, colors.transparencyWhite, colors.transparencyGray, " ")
				buffer.text(x + 1, y + i, colors.transparencyGray, stro4ka1)
			else
				buffer.square(x, y + i, masterPixels.width, 1, colors.transparencyWhite, colors.transparencyGray)
				buffer.text(x, y + i, colors.transparencyGray, stro4ka2)
			end
		end
	else
		buffer.square(x, y, masterPixels.width, masterPixels.height, colors.transparencyWhite, 0x000000, " ")
	end
end

--–ë–∞–Ω–∞–ª—å–Ω–∞—è –∑–∞–ª–∏–≤–∫–∞ —Ñ–æ–Ω–∞
local function drawBackground()
	buffer.square(sizes.xStartOfDrawingArea, sizes.yStartOfDrawingArea, sizes.widthOfDrawingArea, sizes.heightOfDrawingArea + 1, colors.drawingArea, 0xFFFFFF, " ")
end

--–û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ü–≤–µ—Ç–æ–≤
local function drawColors()
	local xPos, yPos = 2, buffer.screen.height - 4
	buffer.square(xPos, yPos, 3, 2, currentBackground, 0xFFFFFF, " ")
	buffer.square(xPos + 3, yPos + 1, 1, 2, currentForeground, 0xFFFFFF, " ")
	buffer.square(xPos + 1, yPos + 2, 2, 1, currentForeground, 0xFFFFFF, " ")
	buffer.text(xPos + 1, yPos + 3, 0xaaaaaa, "‚Üê‚Üí")

	newObj("Colors", 1, xPos, yPos, xPos + 2, yPos + 1)
	newObj("Colors", 2, xPos + 3, yPos + 1, xPos + 3, yPos + 2)
	newObj("Colors", 3, xPos + 1, yPos + 2, xPos + 3, yPos + 2)
	newObj("Colors", 4, xPos + 1, yPos + 3, xPos + 2, yPos + 3)
end

--–û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø–∞–Ω–µ–ª–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ —Å–ª–µ–≤–∞
local function drawLeftBar()
	--–†–∏—Å—É–µ–º –ø–æ–¥–ª–æ–∂–µ—á–∫—É
	buffer.square(1, 5, sizes.widthOfLeftBar, sizes.heightOfLeftBar, colors.leftToolbar, 0xFFFFFF, " ")
	--–†–∏—Å—É–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
	local yPos = sizes.yStartOfInstruments
	for i = 1, #instruments do
		if currentInstrument == i then
			buffer.square(1, yPos, sizes.widthOfLeftBar, sizes.heightOfInstrument, colors.leftToolbarButton, 0xFFFFFF, " ")
		else
			buffer.square(1, yPos, sizes.widthOfLeftBar, sizes.heightOfInstrument, colors.leftToolbar, 0xFFFFFF, " ")
		end
		buffer.text(3, yPos + 1, colors.leftToolbarButtonText, instruments[i])

		newObj("Instruments", i, 1, yPos, sizes.widthOfLeftBar, yPos + sizes.heightOfInstrument - 1)

		yPos = yPos + sizes.heightOfInstrument
	end
	--–ò —Ü–≤–µ—Ç–∞
	drawColors()
end

--–û—Ç—Ä–∏—Å–æ–≤–∫–∞ –≤–µ—Ä—Ö–Ω–µ–≥–æ –º–µ–Ω—é
local function drawTopMenu()
	obj.menu = GUI.menu(1, 1, buffer.screen.width, colors.topMenu, colors.topMenuText, 0x3366CC, 0xFFFFFF, 0)
	obj.menu:addItem("PS", ecs.colors.blue)
	obj.menu:addItem(localization.file)
	obj.menu:addItem(localization.image)
	obj.menu:addItem(localization.edit)
	obj.menu:addItem(localization.view)
	obj.menu:addItem(localization.hotkeys)
	obj.menu:addItem(localization.about)
	obj.menu:draw()
end

--–§—É–Ω–∫—Ü–∏—è, —Å–æ–∑–¥–∞—é—â–∞—è –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö —Ä–∞–Ω–µ–µ –¥–ª–∏–Ω—ã –∏ —à–∏—Ä–∏–Ω—ã
local function createEmptyMasterPixels()
	--–°–æ–∑–¥–∞–µ–º –ø—É—Å—Ç–æ–π –º–∞—Å—Ç–µ—Ä–ø–∏–∫—Å–µ–ª—å—Å
	for j = 1, masterPixels.height * masterPixels.width do
		table.insert(masterPixels, 0x010101)
		table.insert(masterPixels, 0x010101)
		table.insert(masterPixels, 0xFF)
		table.insert(masterPixels, " ")
	end
end

--–§–æ—Ä–º—É–ª–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞ –º–∞—Å—Å–∏–≤–∞ –≤ –∞–±—Å–æ–ª—é—Ç–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–∏–∫—Å–µ–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
local function convertIteratorToCoords(iterator)
	--–ü—Ä–∏–≤–æ–¥–∏–º –∏—Ç–µ—Ä–∞—Ç–æ—Ä –∫ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–º—É –≤–∏–¥—É (1 = 1, 5 = 2, 9 = 3, 13 = 4, 17 = 5, ...)
	iterator = (iterator + sizes.sizeOfPixelData - 1) / sizes.sizeOfPixelData
	--–ü–æ–ª—É—á–∞–µ–º –æ—Å—Ç–∞—Ç–æ–∫ –æ—Ç –¥–µ–ª–µ–Ω–∏—è –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞ –Ω–∞ —à–∏—Ä–∏–Ω—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
	local ostatok = iterator % masterPixels.width
	--–ï—Å–ª–∏ –æ—Å—Ç–∞—Ç–æ–∫ —Ä–∞–≤–µ–Ω 0, —Ç–æ —Ö —Ä–∞–≤–µ–Ω —à–∏—Ä–∏–Ω–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –∞ –µ—Å–ª–∏ –Ω–µ—Ç, —Ç–æ —Ö —Ä–∞–≤–µ–Ω –æ—Å—Ç–∞—Ç–∫—É
	local x = (ostatok == 0) and masterPixels.width or ostatok
	--–ê —Ç–µ–ø–µ—Ä—å –∫–∞–∫ –¥–≤–∞ –ø–∞–ª—å—Ü–∞ –ø–æ–ª—É—á–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—É –ø–æ Y
	local y = math.ceil(iterator / masterPixels.width)
	--–û—á–∏—â–∞–µ–º –æ—Å—Ç–∞—Ç–æ–∫ –∏–∑ –æ–ø–µ—Ä–∞—Ç–∏–≤–∫–∏
	ostatok = nil
	--–í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
	return x, y
end

--–§–æ—Ä–º—É–ª–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –∞–±—Å–æ–ª—é—Ç–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –ø–∏–∫—Å–µ–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –∏—Ç–µ—Ä–∞—Ç–æ—Ä –¥–ª—è –º–∞—Å—Å–∏–≤–∞
local function convertCoordsToIterator(x, y)
	--–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –∏—Ç–µ—Ä–∞—Ç–æ—Ä
	return (masterPixels.width * (y - 1) + x) * sizes.sizeOfPixelData - sizes.sizeOfPixelData + 1
end

--–ú–∏–Ω–∏-–∫–æ–Ω—Å–æ–ª—å–∫–∞ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏, —Å–æ–æ–±—â–∞—é—â–∞—è —Å–Ω–∏–∑—É, —á–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤–∞—â–µ
local function console(text)
	buffer.square(sizes.xStartOfDrawingArea, buffer.screen.height, sizes.widthOfDrawingArea, 1, colors.console, colors.consoleText, " ")
	
	local _, total, used = ecs.getInfoAboutRAM()
	local RAMText = used .. "/" .. total .. " KB RAM"
	buffer.text(sizes.xEndOfDrawingArea - unicode.len(RAMText), buffer.screen.height, colors.consoleText, RAMText)
	
	buffer.text(sizes.xStartOfDrawingArea + 1, buffer.screen.height, colors.consoleText, text)
end

--–§—É–Ω–∫—Ü–∏—è, –±–µ—Ä—É—â–∞—è —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–∏–∫—Å–µ–ª—å –∏–∑ –º–∞—Å—Å–∏–≤–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏ —Ä–∏—Å—É—é—â–∞—è –µ–≥–æ –≤ –±—É—Ñ–µ—Ä–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ,
--—Ç.–µ. —Å —É—á–µ—Ç–æ–º –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ –∏ —Ç.–ø.
local function drawPixel(x, y, xPixel, yPixel, iterator)
	--–ü–æ–ª—É—á–∞–µ–º —Ç—É–∫—É—â–∏–µ –¥–∞–Ω–Ω—ã–µ –æ –ø–∏–∫—Å–µ–ª–µ
	local background, foreground, alpha, symbol = masterPixels[iterator], masterPixels[iterator + 1], masterPixels[iterator + 2], masterPixels[iterator + 3]
	--–ï—Å–ª–∏ –ø–∏–∫—Å–µ–ª—å –Ω–µ –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π
	if alpha == 0x00 then
		buffer.set(x, y, background, foreground, symbol)
	--–ï—Å–ª–∏ –ø–∏–∫—Å–µ–ª—å –ø—Ä–æ–∑—Ä–∞—á–Ω–µ–µ –Ω–µ–ø—Ä–æ–∑—Ä–∞—á–Ω–æ–≥–æ
	elseif alpha > 0x00 then
		local blendColor
		if xPixel % 2 == 0 then
			if yPixel % 2 == 0 then
				blendColor = colors.transparencyGray
			else
				blendColor = colors.transparencyWhite
			end
		else
			if yPixel % 2 == 0 then
				blendColor = colors.transparencyWhite
			else
				blendColor = colors.transparencyGray
			end
		end

		buffer.set(x, y, colorlib.alphaBlend(blendColor, background, alpha), foreground, symbol)
	end
	background, foreground, alpha, symbol = nil, nil, nil, nil
end

--–ü–∏–∑–¥—é–ª–∏–Ω–∫–∞, –ø–æ–∫–∞–∑—ã–≤–∞—é—â–∞—è —Ä–∞–∑–º–µ—Ä —Ç–µ–∫—Å—Ç–∞ –∏ —Ç—ã–ø—ã
local function drawTooltip(x, y, ...)
	local texts = {...}
	--–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —à–∏—Ä–∏–Ω—É –ø–∏–∑–¥—é–ª–∏–Ω–∫–∏
	local maxWidth = 0; for i = 1, #texts do maxWidth = math.max(maxWidth, unicode.len(texts[i])) end
	--–†–∏—Å—É–µ–º –ø–∏–∑–¥—é–ª–∏–Ω–∫—É
	buffer.square(x, y, maxWidth + 2, #texts, 0x000000, 0xFFFFFF, " ", 69); x = x + 1		
	for i = 1, #texts do buffer.text(x, y, 0xFFFFFF, texts[i]); y = y + 1 end
end

--–§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –≤—ã–¥–µ–ª–µ–Ω–∏—è —Å–æ–æ—Ç–≤. –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–º
local function drawSelection()
	local color = 0x000000
	local xStart, yStart = sizes.xStartOfImage + selection.x - 1, sizes.yStartOfImage + selection.y - 1
	local xEnd, yEnd = xStart + selection.width - 1, yStart + selection.height - 1
	local currentBackground

	local function nextColor()
		if color == 0x000000 then color = 0xFFFFFF else color = 0x000000 end
	end

	--"‚îÅ"
	--"‚îÉ"

	local function drawSelectionSquare(x1, y1, x2, y2, xStep, yStep, symbol)
		for y = y1, y2, yStep do
			for x = x1, x2, xStep do
				local background = buffer.get(x, y)
				buffer.set(x, y, background, color, symbol)
				nextColor()
			end
		end
	end

	local function drawCornerPoint(x, y, symbol)
		local background = buffer.get(x, y)
		buffer.set(x, y, background, color, symbol)
		nextColor()
	end

	if selection.width > 1 and selection.height > 1 then
		drawCornerPoint(xStart, yStart, "‚îè")
		drawSelectionSquare(xStart + 1, yStart, xEnd - 1, yStart, 1, 1, "‚îÅ")
		drawCornerPoint(xEnd, yStart, "‚îì")
		drawSelectionSquare(xEnd, yStart + 1, xEnd, yEnd - 1, 1, 1, "‚îÉ")
		drawCornerPoint(xEnd, yEnd, "‚îõ")
		drawSelectionSquare(xEnd - 1, yEnd, xStart + 1, yEnd, -1, 1, "‚îÅ")
		drawCornerPoint(xStart, yEnd, "‚îó")
		drawSelectionSquare(xStart, yEnd - 1, xStart, yStart + 1, 1, -1, "‚îÉ")
	else
		if selection.width == 1 then
			drawSelectionSquare(xStart, yStart, xStart, yEnd, 1, 1, "‚îÉ")
		elseif selection.height == 1 then 
			drawSelectionSquare(xStart, yStart, xEnd, yStart, 1, 1, "‚îÅ")
		end
	end

	drawTooltip(xEnd + 2, yEnd - 1, localization.w .. ": " .. selection.width .. " px", localization.h .. ": " .. selection.height .. " px")
	-- drawTooltip(xEnd + 2, yEnd - 1, "–®: " .. selection.width .. " px", "–í: " .. selection.height .. " px", "S: " .. xStart .. "x" .. yStart, "E: " .. xEnd .. "x" .. yEnd)
end

local function line(x0, y0, x1, y1, background, applyToMasterPixels)
   	local steep = false;
    
    if math.abs(x0 - x1) < math.abs(y0 - y1 ) then
        x0, y0 = swap(x0, y0)
        x1, y1 = swap(x1, y1)
        steep = true;
    end

    if (x0 > x1) then
    	x0, x1 = swap(x0, x1)
    	y0, y1 = swap(y0, y1)
    end

    local dx = x1 - x0;
    local dy = y1 - y0;
    local derror2 = math.abs(dy) * 2
    local error2 = 0;
    local y = y0;
    
    for x = x0, x1, 1 do
        if steep then
        	if applyToMasterPixels then
        		image.set(masterPixels, y, x, background, 0x000000, 0x00, " ")
        	else
            	buffer.set(y, x, background, 0x000000, " ")
            end
        else
        	if applyToMasterPixels then
        		image.set(masterPixels, x, y, background, 0x000000, 0x00, " ")
        	else
            	buffer.set(x, y, background, 0x000000, " ")
            end
        end

        error2 = error2 + derror2;

        if error2 > dx then
            y = y + (y1 > y0 and 1 or -1);
            error2 = error2 - dx * 2;
        end
    end
end

local function drawShapeCornerPoints(xStart, yStart, xEnd, yEnd)
	buffer.set(xStart, yStart, 0x99FF80, 0x000000, " ")
	buffer.set(xEnd, yEnd, 0x99FF80, 0x000000, " ")
end

local function drawLineShape()
	local xStart, yStart = sizes.xStartOfImage + selection.xStart - 1, sizes.yStartOfImage + selection.yStart - 1
	local xEnd, yEnd = sizes.xStartOfImage + selection.xEnd - 1, sizes.yStartOfImage + selection.yEnd - 1

	line(xStart, yStart, xEnd, yEnd, currentBackground)
	drawShapeCornerPoints(xStart, yStart, xEnd, yEnd)
	drawTooltip(xEnd + 2, yEnd - 3, localization.w .. ": " .. selection.width .. " px", localization.h .. ": " .. selection.height .. " px", " ", localization.accept)
end

--–§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–≤–æ–¥–∫–∏ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–π –∑–æ–Ω—ã
local function stroke(x, y, width, height, color, applyToMasterPixels)
	if applyToMasterPixels then
		local iterator
		for i = x, x + width - 1 do
			iterator = convertCoordsToIterator(i, y)
			masterPixels[iterator] = color; masterPixels[iterator + 1] = 0x0; masterPixels[iterator + 2] = 0x0; masterPixels[iterator + 3] = " "

			iterator = convertCoordsToIterator(i, y + height - 1)
			masterPixels[iterator] = color; masterPixels[iterator + 1] = 0x0; masterPixels[iterator + 2] = 0x0; masterPixels[iterator + 3] = " "
		end

		for i = y, y + height - 1 do
			iterator = convertCoordsToIterator(x, i)
			masterPixels[iterator] = color; masterPixels[iterator + 1] = 0x0; masterPixels[iterator + 2] = 0x0; masterPixels[iterator + 3] = " "

			iterator = convertCoordsToIterator(x + width - 1, i)
			masterPixels[iterator] = color; masterPixels[iterator + 1] = 0x0; masterPixels[iterator + 2] = 0x0; masterPixels[iterator + 3] = " "
		end
	else
		buffer.square(x, y, width, 1, color, 0x000000, " ")
		buffer.square(x, y + height - 1, width, 1, color, 0x000000, " ")

		buffer.square(x, y, 1, height, color, 0x000000, " ")
		buffer.square(x + width - 1, y, 1, height, color, 0x000000, " ")
	end
end

local function ellipse(xStart, yStart, width, height, color, applyToMasterPixels)
	--helper function, draws pixel and mirrors it
	local function setpixel4(centerX, centerY, deltaX, deltaY, color)
		if applyToMasterPixels then
			image.set(masterPixels, centerX + deltaX, centerY + deltaY, color, 0x000000, 0x00, " ")
			image.set(masterPixels, centerX - deltaX, centerY + deltaY, color, 0x000000, 0x00, " ")
			image.set(masterPixels, centerX + deltaX, centerY - deltaY, color, 0x000000, 0x00, " ")
			image.set(masterPixels, centerX - deltaX, centerY - deltaY, color, 0x000000, 0x00, " ")
		else
			buffer.set(centerX + deltaX, centerY + deltaY, color, 0x000000, " ")
			buffer.set(centerX - deltaX, centerY + deltaY, color, 0x000000, " ")
			buffer.set(centerX + deltaX, centerY - deltaY, color, 0x000000, " ")
			buffer.set(centerX - deltaX, centerY - deltaY, color, 0x000000, " ")
		end
	end

	--red ellipse, 2*10px border
	local centerX = math.floor(xStart + width / 2)
	local centerY = math.floor(yStart + height / 2)
	local radiusX = math.floor(width / 2)
	local radiusY = math.floor(height / 2)
	local radiusX2 = radiusX ^ 2
	local radiusY2 = radiusY ^ 2
	
	--upper and lower halves
	local quarter = math.floor(radiusX2 / math.sqrt(radiusX2 + radiusY2))
	for x = 0, quarter do
		local y = radiusY * math.sqrt(1 - x^2 / radiusX2)
		setpixel4(centerX, centerY, x, math.floor(y), color);
	end

	--right and left halves
	quarter = math.floor(radiusY2 / math.sqrt(radiusX2 + radiusY2));
	for y = 0, quarter do
		x = radiusX * math.sqrt(1 - y^2 / radiusY2);
		setpixel4(centerX, centerY, math.floor(x), y, color);
	end
end

local function polygon(xCenter, yCenter, xStart, yStart, countOfEdges, color)
	local degreeStep = 360 / countOfEdges

	local deltaX, deltaY = xStart - xCenter, yStart - yCenter
	local radius = math.sqrt(deltaX ^ 2 + deltaY ^ 2)
	local halfRadius = radius / 2
	local startDegree = math.deg(math.asin(deltaX / radius))

	local function calculatePosition(degree)
		local radDegree = math.rad(degree)
		local deltaX2 = math.sin(radDegree) * radius
		local deltaY2 = math.cos(radDegree) * radius
		return round(xCenter + deltaX2), round(yCenter + (deltaY >= 0 and deltaY2 or -deltaY2))
	end

	local xOld, yOld, xNew, yNew = calculatePosition(startDegree)

	for degree = (startDegree + degreeStep - 1), (startDegree + 360), degreeStep do
		xNew, yNew = calculatePosition(degree)
		buffer.line(xOld, yOld, xNew, yNew, color, 0x000000, " ")
		xOld, yOld = xNew, yNew
	end
end

local function drawPolygonShape()
	local xStart, yStart = sizes.xStartOfImage + selection.xStart - 1, sizes.yStartOfImage + selection.yStart - 1
	local xEnd, yEnd = sizes.xStartOfImage + selection.xEnd - 1, sizes.yStartOfImage + selection.yEnd - 1

	local radius = math.floor(math.sqrt(selection.width ^ 2 + (selection.height*2) ^ 2))
	polygon(xStart, yStart, xEnd, yEnd, currentPolygonCountOfEdges, currentBackground)

	drawShapeCornerPoints(xStart, yStart, xEnd, yEnd)
	drawTooltip(xEnd + 2, yEnd - 3, localization.radius .. ": " .. radius .. " px", localization.edges .. ": " .. currentPolygonCountOfEdges, " ", localization.accept)
end

local function drawSquareShape(type)
	local xStart, yStart = sizes.xStartOfImage + selection.x - 1, sizes.yStartOfImage + selection.y - 1
	local xEnd, yEnd = xStart + selection.width - 1, yStart + selection.height - 1
	
	if type == "filledSquare" then
		buffer.square(xStart, yStart, selection.width, selection.height, currentBackground, 0x000000, " ")
	elseif type == "frame" then
		stroke(xStart, yStart, selection.width, selection.height, currentBackground, false)
	elseif type == "ellipse" then
		ellipse(xStart, yStart, selection.width, selection.height, currentBackground, false)		
	end

	drawShapeCornerPoints(xStart, yStart, xEnd, yEnd)
	drawTooltip(xEnd + 2, yEnd - 3, localization.w .. ": " .. selection.width .. " px", localization.h .. ": " .. selection.height .. " px", " ", localization.accept)
end

local function drawMultiPointInstrument()
	if selection and selection.finished == true then
		if instruments[currentInstrument] == "M" then
			drawSelection()
		elseif instruments[currentInstrument] == "S" then
			if currentShape == localization.line then
				drawLineShape()
			elseif currentShape == localization.ellipse then
				drawSquareShape("ellipse")
			elseif currentShape == localization.rectangle then
				drawSquareShape("filledSquare")
			elseif currentShape == localization.border then
				drawSquareShape("frame")
			elseif currentShape == localization.polygon then
				drawPolygonShape()
			end
		end
	end
end

--–û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
local function drawImage()
	--–°—Ç–∞—Ä—Ç–æ–≤—ã–µ –Ω—É–∂–Ω–æ—Å—Ç–∏
	local xPixel, yPixel = 1, 1
	local xPos, yPos = sizes.xStartOfImage, sizes.yStartOfImage

	--–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø—Ä–æ—Ä–∏—Å–æ–≤–∫–∏, —á—Ç–æ–±—ã –∫–∞—Ä—Ç–∏–Ω–∫–∞ –Ω–µ —Å—ä–µ–±—ã–≤–∞–ª–∞ –∑–∞ –¥–æ–∑–≤–æ–ª–µ–Ω–Ω—É—é –∑–æ–Ω—É
	buffer.setDrawLimit(sizes.xStartOfDrawingArea, sizes.yStartOfDrawingArea, sizes.widthOfDrawingArea, sizes.heightOfDrawingArea)

	--–†–∏—Å—É–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω—É—é –∑–æ–Ω—É
	drawTransparentZone(xPos, yPos)

	--–ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –º–∞—Å—Å–∏–≤ –º–∞—Å—Ç–µ—Ä–ø–∏–∫—Å–µ–ª—å—Å–∞
	for i = 1, #masterPixels, 4 do
		--–†–∏—Å—É–µ–º –ø–∏–∫—Å–µ–ª—å, –µ—Å–ª–∏ —É –Ω–µ–≥–æ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –Ω–µ –∞–±—Å–æ–ª—é—Ç–Ω–∞—è, –õ–ò–ë–û –∏–º–µ–µ—Ç—Å—è –∫–∞–∫–æ–π-—Ç–æ —Å–∏–º–≤–æ–ª
		--–¢.–µ. –¥–∞–∂–µ –µ—Å–ª–∏ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –∏ –æ—Ö—É–µ–ª–∞, –Ω–æ —Å–∏–º–≤–æ–ª –µ—Å—Ç—å, —Ç–æ —Ä–∏—Å—É–µ–º –µ–≥–æ
		if masterPixels[i + 2] ~= 0xFF or masterPixels[i + 3] ~= " " then
			drawPixel(xPos, yPos, xPixel, yPixel, i)
		end
		--–í—Å—è–∫–∏–µ —Ä–∞—Å—á–µ—Ç—ã –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
		xPixel = xPixel + 1
		xPos = xPos + 1
		if xPixel > masterPixels.width then xPixel = 1; xPos = sizes.xStartOfImage; yPixel = yPixel + 1; yPos = yPos + 1 end
	end

	if masterPixels.width > 0 and masterPixels.height > 0 then
		local text = localization.size  .. ": " .. masterPixels.width .. "x" .. masterPixels.height .. " px"
		xPos = math.floor(sizes.xStartOfImage + masterPixels.width / 2 - unicode.len(text) / 2)
		buffer.text(xPos, sizes.yEndOfImage + 1, 0xFFFFFF, text)
	end

	--–†–∏—Å—É–µ–º –º—É–ª—å—Ç–∏–∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç
	drawMultiPointInstrument()
	--–£–±–∏—Ä–∞–µ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
	buffer.resetDrawLimit()
end

--–ü—Ä–æ—Å—Ç–æ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
local function drawBackgroundAndImage()
	drawBackground()
	drawImage()
end

--–§—É–Ω–∫—Ü–∏—è, —Ä–∏—Å—É—é—â–∞—è –í–°–ï, –∞–±—Å–æ–ª—é—Ç–ª–∏, –µ–ø—Ç–∞
local function drawAll()
	drawBackground()
	drawLeftBar()
	drawTopMenu()
	drawBackgroundAndImage()

	buffer.draw()
end

------------------------------------------------ –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º –∏ –ø—Ä–æ—á–∏–º --------------------------------------------------------------

--–°–º–µ–Ω–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –Ω–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –Ω–æ–º–µ—Ä
local function changeInstrumentTo(ID)
	currentInstrument = ID
	selection = nil
	drawAll()
end

--–ü–µ—Ä–µ–º–µ—â–∞–ª–∫–∞ –∫–∞—Ä—Ç–∏–Ω–∫–∏ –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∞—è –≤—Å–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
local function move(direction)
	if instruments[currentInstrument] == "M" and selection and selection.finished == true then
		if direction == "up" then
			selection.y = selection.y - 1
			if selection.y < 1 then selection.y = 1 end
		elseif direction == "down" then
			selection.y = selection.y + 1
			if selection.y + selection.height - 1 > masterPixels.height then selection.y = selection.y - 1 end
		elseif direction == "left" then
			selection.x = selection.x - 1
			if selection.x < 1 then selection.x = 1 end
		elseif direction == "right" then
			selection.x = selection.x + 1
			if selection.x + selection.width - 1 > masterPixels.width then selection.x = selection.x - 1 end
		end
	else
		local howMuchUpDown = 2
		local howMuchLeftRight = 4
		if direction == "up" then
			reCalculateImageSizes(sizes.xStartOfImage, sizes.yStartOfImage - howMuchUpDown)
		elseif direction == "down" then
			reCalculateImageSizes(sizes.xStartOfImage, sizes.yStartOfImage + howMuchUpDown)
		elseif direction == "left" then
			reCalculateImageSizes(sizes.xStartOfImage - howMuchLeftRight, sizes.yStartOfImage)
		elseif direction == "right" then
			reCalculateImageSizes(sizes.xStartOfImage + howMuchLeftRight, sizes.yStartOfImage)
		end
	end
	drawBackgroundAndImage()
	buffer.draw()
end

--–ü—Ä–æ—Å—Ç–æ –±–æ–ª–µ–µ —É–¥–æ–±–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–∏–∫—Å–µ–ª—è, –∞ —Ç–æ –≤—Å–µ —ç—Ç–∏ –ø–ª—é—Å—ã, –º–∏–Ω—É—Å—ã, –±—Ä—Ä—Ä
local function setPixel(iterator, background, foreground, alpha, symbol)
	masterPixels[iterator] = background
	masterPixels[iterator + 1] = foreground
	masterPixels[iterator + 2] = alpha
	masterPixels[iterator + 3] = symbol
end

--–§—É–Ω–∫—Ü–∏—è, –º–µ–Ω—è—é—â–∞—è —Ü–≤–µ—Ç–∞ –º–µ—Å—Ç–∞–º–∏
local function swapColors()
	currentBackground, currentForeground = swap(currentBackground, currentForeground)
	drawColors()
	console("–¶–≤–µ—Ç–∞ –ø–æ–º–µ–Ω—è–Ω—ã –º–µ—Å—Ç–∞–º–∏")
end

--–£—Ö, —Å—É–∫–∞! –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞–±–æ—Ç—ã –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ —Ç–µ–∫—Å—Ç–∞
--–õ—é—Ç–∞—è –¥–∏—á—å, —Å–ø–∏–∑–¥–∏–ª —Å–æ —Å—Ç–∞—Ä–æ–≥–æ —Ñ—à, –Ω–æ, –≤—Ä–æ–¥–µ, –ø–∞—à–µ—Ç –Ω–æ—Ä–º–∞—Å
--–ü—Ä–∞–≤–¥–∞, —á–µ—Ç –µ—Å—Ç—å –ø—Ä–µ–¥—á—É–≤—Å—Ç–≤–∏–µ, —á—Ç–æ –∫–æ—Å—Ç—ã–ª—å–Ω–∞—è –∏ –±–∞–≥–æ–≤–∞–Ω–Ω–∞—è –æ–Ω–∞, –Ω—É –¥–∞ –ø–æ—Ö—É–π
local function inputText(x, y, limit)
	local oldPixels = ecs.rememberOldPixels(x,y-1,x+limit-1,y+1)
	local text = ""
	local inputPos = 1

	local function drawThisShit()
		for i = 1, inputPos do
			ecs.invertedText(x + i - 1, y + 1, "‚îÄ")
			ecs.adaptiveText(x + i - 1, y - 1, " ", currentBackground)
		end
		ecs.invertedText(x + inputPos - 1, y + 1, "‚ñ≤")--"‚ñ≤","‚ñº"
		ecs.invertedText(x + inputPos - 1, y - 1, "‚ñº")
		ecs.adaptiveText(x, y, ecs.stringLimit("start", text, limit, false), currentBackground)
	end

	drawThisShit()

	while true do
		local e = {event.pull()}
		if e[1] == "key_down" then
			if e[4] == 14 then
				if unicode.len(text) >= 1 then
					text = unicode.sub(text, 1, -2)
					if unicode.len(text) < (limit - 1) then
						inputPos = inputPos - 1
					end
					ecs.drawOldPixels(oldPixels)
					drawThisShit()
				end
			elseif e[4] == 28 then
				break
			elseif e[4] == 200 then
				text = text .. "‚ñÄ"
				if unicode.len(text) < limit then
					inputPos = inputPos + 1
				end
				drawThisShit()
			elseif e[4] == 208 then
				text = text .. "‚ñÑ"
				if unicode.len(text) < limit then
					inputPos = inputPos + 1
				end
				drawThisShit()
			else
				local symbol = ecs.convertCodeToSymbol(e[3])
				if symbol ~= nil then
					text = text .. symbol
					if unicode.len(text) < limit then
						inputPos = inputPos + 1
					end
					drawThisShit()
				end
			end
		elseif e[1] == "clipboard" then
			if e[3] then
				text = text .. e[3]
				if unicode.len(text) < limit then
					inputPos = inputPos + unicode.len(e[3])
				end
				drawThisShit()
			end
		end
	end

	ecs.drawOldPixels(oldPixels)
	if text == "" then text = " " end
	return text
end

--–§—É–Ω–∫—Ü–∏—è-–ø—Ä–∏–º–µ–Ω—è—Ç–æ—Ä —Ç–µ–∫—Å—Ç–∞ –∫ –º–∞—Å—Å–∏–≤—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
local function saveTextToPixels(x, y, text)
	local sText = unicode.len(text)
	local iterator
	x = x - 1
	for i = 1, sText do
		if x + i > masterPixels.width then break end
		iterator = convertCoordsToIterator(x + i, y)
		setPixel(iterator, masterPixels[iterator], currentBackground, masterPixels[iterator + 2], unicode.sub(text, i, i))
	end
end

--–§—É–Ω–∫—Ü–∏—è-—Ü–µ–Ω—Ç—Ä–∞—Ç–æ—Ä –∫–∞—Ä—Ç–∏–Ω–∫–∏ –ø–æ —Ü–µ–Ω—Ç—Ä—É –º–æ–Ω–∏–∫–∞
local function tryToFitImageOnCenterOfScreen()
	reCalculateImageSizes()

	local x, y = sizes.xStartOfImage, sizes.yStartOfImage
	if masterPixels.width < sizes.widthOfDrawingArea then
		x = math.floor(sizes.xStartOfDrawingArea + sizes.widthOfDrawingArea / 2 - masterPixels.width / 2) - 1
	end

	if masterPixels.height < sizes.heightOfDrawingArea then
		y = math.floor(sizes.yStartOfDrawingArea + sizes.heightOfDrawingArea / 2 - masterPixels.height / 2)
	end

	reCalculateImageSizes(x, y)
end

--–§—É–Ω–∫—Ü–∏—è, —Å–ø—Ä–∞—à–∏–≤–∞—é—â–∞—è —é–∑–≤–µ—Ä—è, –∫–∞–∫–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ –ø–∏–∫—á—É –æ–Ω  —Ö–æ—á–µ—Ç —Å–æ–∑–¥–∞—Ç—å - –Ω—É, –∏ —Å–æ–∑–¥–∞–µ—Ç –µ–µ
local function new()
	selection = nil
	local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x262626, localization.newDocument}, {"EmptyLine"}, {"Input", 0x262626, 0x880000, localization.width}, {"Input", 0x262626, 0x880000, localization.height}, {"EmptyLine"}, {"Button", {0x999999, 0xffffff, "OK"}})

	data[1] = tonumber(data[1]) or 51
	data[2] = tonumber(data[2]) or 19

	masterPixels = {}
	masterPixels.width, masterPixels.height = data[1], data[2]
	createEmptyMasterPixels()
	tryToFitImageOnCenterOfScreen()
	drawAll()
end

--–û–±—ã—á–Ω–∞—è —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è –∑–∞–ª–∏–≤–∫–∞, –∞–ª–≥–æ—Ä–∏—Ç–º —Å–ø–∏–∑–∂–µ–Ω —Å –≤–∏–∫–∏
--–ï—Å—Ç—å –∏–Ω—Ñ–∞, —á—Ç–æ –≤—ã–∂–∏—Ä–∞–µ—Ç —Å—Ç–µ–∫, –Ω–æ –õ—É–∞, –≤—Ä–æ–¥–µ, –Ω–µ –æ—Å–æ–±–æ —Ä—É–≥–∞–µ—Ç—Å—è, —Ç–∞–∫ —á—Ç–æ –∑–∞–µ–±–æ–∫ –≤—Å–µ
local function fill(x, y, startColor, fillColor)
	local function doFill(xStart, yStart)
		local iterator = convertCoordsToIterator(xStart, yStart)

		--–ó–∞–≤–µ—Ä—à–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é, –µ—Å–ª–∏ —Ü–≤–µ—Ç –≤ –º–∞—Å—Å–∏–≤–µ –Ω–µ —Ç–∞–∫–æ–π, –∫–∞–∫–æ–π –º—ã –∑–∞–ª–∏–≤–∞–µ–º
		if masterPixels[iterator] ~= startColor or masterPixels[iterator] == fillColor then return end

		--–ó–∞–ª–∏–≤–∞–µ–º –≤ –ø–∞–º—è—Ç—å
		masterPixels[iterator] = fillColor
		masterPixels[iterator + 2] = currentAlpha

		doFill(xStart + 1, yStart)
		doFill(xStart - 1, yStart)
		doFill(xStart, yStart + 1)
		doFill(xStart, yStart - 1)

		iterator = nil
	end
	doFill(x, y)
end

--–ö–∏—Å—Ç—å, –ö–ò–ò–ò–ò–°–¢–¨
local function brush(x, y, background, foreground, alpha, symbol)
	--–°–º–µ—â–µ–Ω–∏–µ –≤–ª–µ–≤–æ –∏ –≤–ø—Ä–∞–≤–æ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —Ü–µ–Ω—Ç—Ä–∞ –∫–∏—Å—Ç–∏
	--–ö–û–†–û–ß, –ù–ï –¢–£–ü–ò
	--–ß—Ç–æ–±—ã –∫–∏—Å—Ç–æ—á–∫–∞ –±—ã–ª–∞ –ø–æ —Ü–µ–Ω—Ç—Ä—É –º—ã—à–∏, –Ω—É
	local position = math.floor(currentBrushSize / 2)
	x, y = x - position, y - position
	--–•—É–µ–≤–∏–Ω–∫–∞ –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è
	local newIterator
	--–ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –∫–∏—Å—Ç—å –ø–æ —à–∏—Ä–∏–Ω–µ –∏ –≤—ã—Å–æ—Ç–µ
	for cyka = 1, currentBrushSize do
		for pidor = 1, currentBrushSize do
			--–ï—Å–ª–∏ —ç—Ç–æ—Ç –∫—É—Å–æ—á–µ–∫ –≤—Ö–æ–¥–∏—Ç –≤ –≥—Ä–∞–Ω–∏—Ü—ã —Ä–∏—Å–æ–≤–∞–±–µ–ª—å–Ω–æ–π –∑–æ–Ω—ã, —Ç–æ
			if x >= 1 and x <= masterPixels.width and y >= 1 and y <= masterPixels.height then
				
				--–°—á–∏—Ç–∞–µ–º –∏—Ç–µ—Ä–∞—Ç–æ—Ä –¥–ª—è –∫—É—Å–æ—á–∫–∞ –∫–∏—Å—Ç–∏
				newIterator = convertCoordsToIterator(x, y)

				--–ï—Å–ª–∏ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ –∫–∏—Å—Ç–∏ –í–ê–©–ï –ù–ï–¢, —Ç–æ –ø—Ä–æ—Å—Ç–æ —Ä–∏—Å—É–µ–º –∫–∞–∫ –æ–±—ã—á–Ω–µ–Ω—å–∫–æ –≤—Å–µ
				if alpha == 0x00 then
					setPixel(newIterator, background, foreground, alpha, symbol)
				--–ï—Å–ª–∏ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ –∫–∏—Å—Ç–∏ –µ—Å—Ç—å –∫–∞–∫–∞—è-—Ç–æ, –Ω–æ –æ–Ω–∞ –Ω–µ –∞–±—Å–æ–ª—é—Ç–Ω–∞—è
				elseif alpha < 0xFF and alpha > 0x00 then
					--–ï—Å–ª–∏ –ø–∏–∫—Å–µ–ª—å –≤ –º–∞—Å—Å–∏–≤–µ –Ω–∏ —Ö—É—è –Ω–µ –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π, —Ç–æ –æ—Å—Ç–∞–≤–ª—è–µ–º –µ–≥–æ —Ç–∞–∫–∏–º –∂–µ, —Ä–∞–∑–≤–µ —á—Ç–æ —Ü–≤–µ—Ç –º–µ–Ω—è–µ–º –Ω–∞ —Å–±–ª–µ–Ω–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–π
					if masterPixels[newIterator + 2] == 0x00 then
						local gettedBackground = colorlib.alphaBlend(masterPixels[newIterator], background, alpha)
						setPixel(newIterator, gettedBackground, foreground, 0x00, symbol)
					--–ê –µ—Å–ª–∏ –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π, —Ç–æ —Å–º–µ—à–∏–≤–∞–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
					--–ü–∏–∑–¥–∞–Ω—É—Ç—å—Å—è –≤–æ–æ–±—â–µ, —Å—É–∫
					else
						--–ï—Å–ª–∏ –µ–≥–æ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è
						if masterPixels[newIterator + 2] == 0xFF then
							setPixel(newIterator, background, foreground, alpha, symbol)
						--–ï—Å–ª–∏ –Ω–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è
						else
							local newAlpha = masterPixels[newIterator + 2] - (0xFF - alpha)
							if newAlpha < 0x00 then newAlpha = 0x00 end
							setPixel(newIterator, background, foreground, newAlpha, symbol)
						end
					end
				--–ï—Å–ª–∏ —É–∫–∞–∑–∞–Ω–Ω–∞—è –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞, —Ç.–µ. —Ä–∞–≤–Ω–∞ 0xFF
				else
					setPixel(newIterator, 0x000000, 0x000000, 0xFF, " ")
				end
				
				--–†–∏—Å—É–µ–º –ø–∏–∫—Å–µ–ª—å –∏–∑ –º–∞—Å—Ç–µ—Ä–ø–∏–∫—Å–µ–ª—å—Å–∞
				drawPixel(x + sizes.xStartOfImage - 1, y + sizes.yStartOfImage - 1, x, y, newIterator)
			end

			x = x + 1
		end
		x = x - currentBrushSize
		y = y + 1
	end
end

--–î–∏–∞–ª–æ–≥–æ–≤–æ–µ –æ–∫–Ω–æ –æ–±—Ä–µ–∑–∫–∏ –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è –∫–∞—Ä—Ç–∏–Ω–∫–∏
local function cropOrExpand(text)
	local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
		{"EmptyLine"},
		{"CenterText", 0x262626, text},
		{"EmptyLine"},
		{"Input", 0x262626, 0x880000, localization.countOfPixels},
		{"Selector", 0x262626, 0x880000, localization.fromBottom, localization.fromTop, localization.fromLeft, localization.fromRight},
		{"EmptyLine"},
		{"Button", {0xaaaaaa, 0xffffff, "OK"}, {0x888888, 0xffffff, localization.cancel}}
	)

	if data[3] == "OK" then
		local countOfPixels = tonumber(data[1])
		if countOfPixels then
			local direction = ""
			if data[2] == localization.fromBottom then
				direction = "fromBottom"
			elseif data[2] == localization.fromTop then
				direction = "fromTop"
			elseif data[2] == localization.fromLeft then
				direction = "fromLeft"
			else
				direction = "fromRight"
			end

			return direction, countOfPixels
		else
			ecs.error("–í–≤–µ–¥–µ–Ω–æ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∏–∫—Å–µ–ª–µ–π")
		end 
	end
end

--–§—É–Ω–∫—Ü–∏—è-–æ–±—Ä–µ–∑—á–∏–∫ –∫–∞—Ä—Ç–∏–Ω–∫–∏
local function crop()
	local direction, countOfPixels = cropOrExpand(localization.crop)
	if direction then
		masterPixels = image.crop(masterPixels, direction, countOfPixels)
		reCalculateImageSizes(sizes.xStartOfImage, sizes.yStartOfImage)
		drawAll()
	end
end

--–§—É–Ω–∫—Ü–∏—è-—Ä–∞—Å—à–∏—Ä–∏—Ç–µ–ª—å –∫–∞—Ä—Ç–∏–Ω–∫–∏
local function expand()
	local direction, countOfPixels = cropOrExpand(localization.crop)
	if direction then
		masterPixels = image.expand(masterPixels, direction, countOfPixels, 0x010101, 0x010101, 0xFF, " ")
		reCalculateImageSizes(sizes.xStartOfImage, sizes.yStartOfImage)
		drawAll()
	end
end

--–§—É–Ω–∫—Ü–∏—è-–∑–∞–≥—Ä—É–∑—á–∏–∫ –∫–∞—Ä—Ç–∏–Ω–∫–∏ –∏–∑ —Ñ–∞–π–ª–∞
local function loadImageFromFile(path)
	if fs.exists(path) then
		selection = nil
		masterPixels = image.load(path)
		savePath = path
		tryToFitImageOnCenterOfScreen()
	else
		ecs.error("–§–∞–π–ª \"" .. path .. "\" –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
	end
end

--–§—É–Ω–∫—Ü–∏—è-–∑–∞–ø–æ–ª–Ω–∏—Ç–µ–ª—å –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–π –∑–æ–Ω—ã –∫–∞–∫–∏–º–∏-–ª–∏–±–æ –¥–∞–Ω–Ω—ã–º–∏
local function fillSelection(background, foreground, alpha, symbol)
	for j = selection.y, selection.y + selection.height - 1 do
		for i = selection.x, selection.x + selection.width - 1 do
			local iterator = convertCoordsToIterator(i, j)
			masterPixels[iterator] = background
			masterPixels[iterator + 1] = foreground
			masterPixels[iterator + 2] = alpha
			masterPixels[iterator + 3] = symbol
		end
	end

	drawAll()
end

local function applyShapeToMasterPixels()
	if currentShape == localization.line then
		line(selection.xStart, selection.yStart, selection.xEnd, selection.yEnd, currentBackground, true)
	elseif currentShape == localization.rectangle then
		fillSelection(currentBackground, 0x00000, 0x00, " ")
	elseif currentShape == localization.border then
		stroke(selection.x, selection.y, selection.width, selection.height, currentBackground, true)
	elseif currentShape == localization.ellipse then
		ellipse(selection.x, selection.y, selection.width, selection.height, currentBackground, true)
	end

	selection = nil
	drawBackgroundAndImage()
	buffer.draw()
end

------------------------------------------------ –°—Ç–∞—Ä—Ç –ø—Ä–æ–≥—Ä–∞–º–º—ã --------------------------------------------------------------

--–†–∏—Å—É–µ–º –≤–µ—Å—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å —á–∏—Å—Ç–æ –¥–ª—è –∫—Ä–∞—Å–æ—Ç—ã
drawAll()

--–û—Ç–∫—Ä—ã–≤–∞–µ–º —Ñ–∞–π–ª—ã –ø–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º –ø—Ä–æ–≥—Ä–∞–º–º—ã
if args[1] == "o" or args[1] == "open" or args[1] == "-o" or args[1] == "load" then
	loadImageFromFile(args[2])
else
	new()
end

--–û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å —Å–Ω–æ–≤–∞, –ø–æ—Å–∫–æ–ª—å–∫—É —É –Ω–∞—Å –ª–∏–±–æ —Å–æ–∑–¥–∞–ª—Å—è –Ω–æ–≤—ã–π –¥–æ–∫—É–º–µ–Ω—Ç, –ª–∏–±–æ –æ—Ç–∫—Ä—ã–ª—Å—è –∏–º–µ—é—â–∏–π—Å—è —Ñ–∞–π–ª
drawAll()

--–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∏–≤–µ–Ω—Ç—ã
while true do
	local e = {event.pull()}
	if e[1] == "touch" or e[1] == "drag" or e[1] == "drop" then
		--–õ–µ–≤—ã–π –∫–ª–∏–∫
		if e[5] == 0 then
			--–ï—Å–ª–∏ –∫–ª–∏–∫–Ω—É–ª–∏ –Ω–∞ —Ä–∏—Å–æ–≤–∞–±–µ–ª—å–Ω—É—é –∑–æ–Ω–∫—É
			if ecs.clickedAtArea(e[3], e[4], sizes.xStartOfImage, sizes.yStartOfImage, sizes.xEndOfImage, sizes.yEndOfImage) then
				
				--–ü–æ–ª—É—á–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –∏ –∏—Ç–µ—Ä–∞—Ç–æ—Ä
				local x, y = e[3] - sizes.xStartOfImage + 1, e[4] - sizes.yStartOfImage + 1
				local iterator = convertCoordsToIterator(x, y)
				
				--–í—Å–µ –¥–ª—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –º—É–ª—å—Ç–∏—Ç–æ—á–µ—á–Ω–æ–≥–æ —Ä–∏—Å–æ–≤–∞–Ω–∏—è
				if instruments[currentInstrument] == "M" or instruments[currentInstrument] == "S" then
					if e[1] == "touch" then
						selection = {}
						selection.xStart, selection.yStart = x, y

					elseif e[1] == "drag" and selection then
						local x1, y1 = selection.xStart, selection.yStart
						local x2, y2 = x, y
						if x1 > x2 then
							x1, x2 = swap(x1, x2)
						end
						if y1 > y2 then
							y1, y2 = swap(y1, y2)
						end

						selection.x, selection.y = x1, y1
						selection.x2, selection.y2 = x2, y2
						selection.xEnd, selection.yEnd = x, y
						selection.width = selection.x2 - selection.x + 1
						selection.height = selection.y2 - selection.y + 1

						selection.finished = true
					end

					--–ï—Å–ª–∏ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–≤–µ—Ä—à–µ–Ω–æ, —Ç–æ –æ—Ç–¥–∞–µ–º –∫–æ–Ω—Ç—Ä–æ–ª—å –æ—Ç—Ä–∏—Å–æ–≤–æ—á–Ω—ã–º —Ñ—É–Ω–∫—Ü–∏—è–º
					-- if instruments[currentInstrument] == "M" then
						drawBackgroundAndImage()
						buffer.draw()
					-- end
				--–ö–∏—Å—Ç—å
				elseif instruments[currentInstrument] == "B" then
					
					--–ï—Å–ª–∏ –Ω–∞–∂–∞—Ç–∞ –∫–ª–∞–≤–∏—à–∞ –∞–ª—å—Ç
					if keyboard.isKeyDown(56) then
						local _, gettedForeground, gettedBackground = component.gpu.get(e[3], e[4])
						currentBackground = gettedBackground
						currentForeground = gettedForeground
						drawColors()
						buffer.draw()
					
					--–ï—Å–ª–∏ –æ–±—ã—á–Ω–∞—è –∫–∏—Å—Ç—å, –ø—Ä–æ—Å—Ç–æ –∫–∏—Å—Ç—å, –≤–æ–æ–±—â–µ –≤—Å–µ–º –∫–∏—Å—Ç—è–º –∫–∏—Å—Ç—å
					else
						brush(x, y, currentBackground, currentForeground, currentAlpha, currentSymbol)
						--–ü–∏—à–µ–º —á—Ç–æ-—Ç–æ –≤ –∫–æ–Ω—Å–æ–ª–∏
						console("–ö–∏—Å—Ç—å: –∫–ª–∏–∫ –Ω–∞ —Ç–æ—á–∫—É "..e[3].."x"..e[4]..", –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏: "..x.."x"..y..", –∏–Ω–¥–µ–∫—Å –º–∞—Å—Å–∏–≤–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: "..iterator)
						buffer.draw()
					end
				--–õ–∞—Å—Ç–∏–∫
				elseif instruments[currentInstrument] == "E" then
					brush(x, y, currentBackground, currentForeground, 0xFF, currentSymbol)
					console("–õ–∞—Å—Ç–∏–∫: –∫–ª–∏–∫ –Ω–∞ —Ç–æ—á–∫—É "..e[3].."x"..e[4]..", –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏: "..x.."x"..y..", –∏–Ω–¥–µ–∫—Å –º–∞—Å—Å–∏–≤–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: "..iterator)
					buffer.draw()
				--–¢–µ–∫—Å—Ç
				elseif instruments[currentInstrument] == "T" then
					local limit = masterPixels.width - x + 1
					local text = inputText(e[3], e[4], limit)
					saveTextToPixels(x, y, text)
					drawImage()
					buffer.draw()

				--–ó–∞–ª–∏–≤–∫–∞
				elseif instruments[currentInstrument] == "F" then

					fill(x, y, masterPixels[iterator], currentBackground)
					drawImage()
					buffer.draw()

				end

				iterator, x, y = nil, nil, nil

			end

			--–¶–≤–µ—Ç–∞
			for key in pairs(obj["Colors"]) do
				if ecs.clickedAtArea(e[3], e[4], obj["Colors"][key][1], obj["Colors"][key][2], obj["Colors"][key][3], obj["Colors"][key][4]) then
					if key == 1 then
						currentBackground = palette.show("auto", "auto", currentBackground) or currentBackground
						drawAll()
					elseif key == 2 or key == 3 then
						currentForeground = palette.show("auto", "auto", currentForeground) or currentForeground
						drawAll()
					elseif key == 4 then
						buffer.text(obj["Colors"][key][1], obj["Colors"][key][2], 0xFF0000, "‚Üê‚Üí")
						os.sleep(0.2)
						swapColors()
						buffer.draw()
					end
					break
				end	
			end

			--–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
			for key in pairs(obj["Instruments"]) do
				if ecs.clickedAtArea(e[3], e[4], obj["Instruments"][key][1], obj["Instruments"][key][2], obj["Instruments"][key][3], obj["Instruments"][key][4]) then
					selection = nil
					currentInstrument = key
					drawLeftBar(); buffer.draw()
					if instruments[currentInstrument] == "S" then
						local action = GUI.contextMenu(obj["Instruments"][key][3] + 1, obj["Instruments"][key][2], {localization.line}, {localization.ellipse}, {localization.rectangle}, {localization.polygon}, {localization.border}):show()
						currentShape = action or localization.line
						
						if currentShape == localization.polygon then
							local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
								{"EmptyLine"},
								{"CenterText", 0x262626, localization.edges},
								{"EmptyLine"},
								{"Selector", 0x262626, 0x880000, "3", "4", "5", "6", "7", "8", "9", "10"},
								{"EmptyLine"}, 
								{"Button", {0xaaaaaa, 0xffffff, "OK"}}
							)
							currentPolygonCountOfEdges = tonumber(data[1])
						end
						drawAll()
					end
					break
				end
			end

			--–í–µ—Ä—Ö–Ω–∏–π –º–µ–Ω—é-–±–∞—Ä
			local object = obj.menu:getClickedObject(e[3], e[4])
			if object then
				object:press()
				buffer.draw()
				local action
				if object.text == localization.file then
					action = GUI.contextMenu(object.x, object.y + 1, {localization.new, false, "^N"}, {localization.open, false, "^O"}, {localization.createFromString}, "-", {localization.save, (savePath == nil), "^S"}, {localization.saveAs}, "-", {localization.exit}):show()
				elseif object.text == localization.image then
					action = GUI.contextMenu(object.x, object.y + 1, {localization.crop}, {localization.expand}, "-", {localization.rotateBy90}, {localization.rotateBy180}, "-", {localization.flipHorizontal}, {localization.flipVertical}):show()
				elseif object.text == localization.edit then
					action = GUI.contextMenu(object.x, object.y + 1, {localization.hueSaturation}, {localization.colorBalance}, {localization.photoFilter}, "-", {localization.invertColors}, {localization.blackWhite}, "-", {localization.gaussianBlur}):show()
				elseif object.text == localization.view then
					action = GUI.contextMenu(object.x, object.y + 1, {localization.transparencyPad}):show()
				elseif object.text == localization.about then
					ecs.universalWindow("auto", "auto", 36, 0xeeeeee, true, {"EmptyLine"}, {"CenterText", 0x880000, photoshopVersion}, {"EmptyLine"}, {"CenterText", 0x262626, localization.developers}, {"CenterText", 0x555555, "–¢–∏–º–æ—Ñ–µ–µ–≤ –ò–≥–æ—Ä—å"}, {"CenterText", 0x656565, "vk.com/id7799889"}, {"CenterText", 0x656565, "–¢—Ä–∏—Ñ–æ–Ω–æ–≤ –ì–ª–µ–±"}, {"CenterText", 0x656565, "vk.com/id88323331"}, {"EmptyLine"}, {"CenterText", 0x262626, localization.testers}, {"CenterText", 0x656565, "–®–µ—Å—Ç–∞–∫–æ–≤ –¢–∏–º–æ—Ñ–µ–π"}, {"CenterText", 0x656565, "vk.com/id113499693"}, {"CenterText", 0x656565, "–í–µ—á—Ç–æ–º–æ–≤ –†–æ–º–∞–Ω"}, {"CenterText", 0x656565, "vk.com/id83715030"}, {"CenterText", 0x656565, "–û–º–µ–ª–∞–µ–Ω–∫–æ –ú–∞–∫—Å–∏–º"},  {"CenterText", 0x656565, "vk.com/paladincvm"}, {"EmptyLine"},{"Button", {0xbbbbbb, 0xffffff, "OK"}})
				elseif object.text == localization.hotkeys then
					ecs.universalWindow( "auto", "auto", 42, 0xeeeeee, true, 
						table.unpack(localization.hotkeysLines)
					)				
				end

				if action == localization.exit then
					ecs.prepareToExit()
					return
				elseif action == localization.hueSaturation then
					local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
						{"EmptyLine"},
						{"CenterText", 0x262626, localization.hueSaturation},
						{"EmptyLine"},
						{"Slider", 0x262626, 0x880000, 0, 100, 50, localization.hue .. ": ", ""},
						{"Slider", 0x262626, ecs.colors.red, 0, 100, 50,  localization.saturation .. ": ", ""},
						{"Slider", 0x262626, 0x000000, 0, 100, 50,  localization.brightness .. ": ", ""},
						{"EmptyLine"}, 
						{"Button", {0xaaaaaa, 0xffffff, "OK"}, {0x888888, 0xffffff, localization.cancel}}
					)
					if data[4] == "OK" then
						masterPixels = image.hueSaturationBrightness(masterPixels, data[1] - 50, data[2] - 50, data[3] - 50)
						drawAll()
					end
				elseif action == localization.gaussianBlur then
					local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
						{"EmptyLine"},
						{"CenterText", 0x262626, localization.gaussianBlur},
						{"EmptyLine"},
						{"Slider", 0x262626, 0x880000, 1, 5, 2, localization.radius .. ": ", ""},
						{"Slider", 0x262626, 0x880000, 1, 255, 0x88, localization.force .. ": ", ""},
						{"EmptyLine"}, 
						{"Button", {0xaaaaaa, 0xffffff, "OK"}, {0x888888, 0xffffff, localization.cancel}}
					)
					if data[3] == "OK" then
						masterPixels = image.gaussianBlur(masterPixels, tonumber(data[1]), tonumber(data[2]))
						drawAll()
					end
				elseif action == localization.colorBalance then
					local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
						{"EmptyLine"},
						{"CenterText", 0x262626, localization.colorBalance},
						{"EmptyLine"},
						{"Slider", 0x262626, 0x880000, 0, 100, 50, "R: ", ""},
						{"Slider", 0x262626, ecs.colors.green, 0, 100, 50, "G: ", ""},
						{"Slider", 0x262626, ecs.colors.blue, 0, 100, 50, "B: ", ""},
						{"EmptyLine"}, 
						{"Button", {0xaaaaaa, 0xffffff, "OK"}, {0x888888, 0xffffff, localization.cancel}}
					)
					if data[4] == "OK" then
						masterPixels = image.colorBalance(masterPixels, data[1] - 50, data[2] - 50, data[3] - 50)
						drawAll()
					end
				elseif action == localization.photoFilter then
					local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
						{"EmptyLine"},
						{"CenterText", 0x262626, localization.photoFilter},
						{"EmptyLine"},
						{"Color", localization.filterColor, 0x333333},
						{"Slider", 0x262626, 0x880000, 0, 255, 100, localization.transparency .. ": ", ""},
						{"EmptyLine"}, 
						{"Button", {0xaaaaaa, 0xffffff, "OK"}, {0x888888, 0xffffff, localization.cancel}}
					)
					if data[3] == "OK" then
						masterPixels = image.photoFilter(masterPixels, data[1], data[2])
						drawAll()
					end
				elseif action == localization.crop then
					crop()
				elseif action == localization.expand then
					expand()
				elseif action == localization.flipVertical then
					masterPixels = image.flipVertical(masterPixels)
					drawAll()
				elseif action == localization.flipHorizontal then
					masterPixels = image.flipHorizontal(masterPixels)
					drawAll()
				elseif action == localization.invertColors then
					masterPixels = image.invert(masterPixels)
					drawAll()
				elseif action == localization.blackWhite then
					masterPixels = image.blackAndWhite(masterPixels)
					drawAll()
				elseif action == localization.rotateBy90 then
					masterPixels = image.rotate(masterPixels, 90)
					drawAll()
				elseif action == localization.rotateBy180 then
					masterPixels = image.rotate(masterPixels, 180)
					drawAll()
				elseif action == localization.new then
					new()
					drawAll()
				elseif action == localization.saveAs then
					local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x262626, localization.saveAs}, {"EmptyLine"}, {"Input", 0x262626, 0x880000, localization.path}, {"Selector", 0x262626, 0x880000, "OCIF4", "OCIF1", "OCIFString", "RAW"}, {"CenterText", 0x262626, "–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å"}, {"CenterText", 0x262626, "–º–µ—Ç–æ–¥ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è OCIF4"}, {"EmptyLine"}, {"Button", {0xaaaaaa, 0xffffff, "OK"}, {0x888888, 0xffffff, localization.cancel}})
					if data[3] == "OK" then
						data[1] = data[1] or "Untitled"
						data[2] = data[2] or "OCIF4"
						
						if data[2] == "RAW" then
							data[2] = 0
						elseif data[2] == "OCIF1" then
							data[2] = 1
						elseif data[2] == "OCIF4" then
							data[2] = 4
						elseif data[2] == "OCIFString" then
							data[2] = 6
						else
							data[2] = 4
						end

						local filename = string.gsub(data[1], ".pic$", "") .. ".pic"
						local encodingMethod = data[2]

						image.save(filename, masterPixels, encodingMethod)
						savePath = filename
					end
				elseif action == localization.save then
					image.save(savePath, masterPixels)

				elseif action == localization.open then
					local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x262626, localization.open}, {"EmptyLine"}, {"Input", 0x262626, 0x880000, localization.path}, {"EmptyLine"}, {"Button", {0xaaaaaa, 0xffffff, "OK"}, {0x888888, 0xffffff, localization.cancel}})
					if data[2] == "OK" then
						local fileFormat = ecs.getFileFormat(data[1])
					
						if not data[1] then
							ecs.error("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞!")
						elseif not fs.exists(data[1]) then
							ecs.error("–§–∞–π–ª\""..data[1].."\" –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç!")
						elseif fileFormat ~= ".pic" and fileFormat ~= ".rawpic" and fileFormat ~= ".png" then 
							ecs.error("–§–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞ \""..fileFormat.."\" –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è!")
						else
							loadImageFromFile(data[1])
							drawAll()
						end
					end
				elseif action == localization.createFromString then
					local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
						{"EmptyLine"},
						{"CenterText", 0x262626, localization.createFromString},
						{"EmptyLine"},
						{"Input", 0x262626, 0x880000, localization.string},
						{"EmptyLine"},
						{"Button", {0xaaaaaa, 0xffffff, "OK"}, {0x888888, 0xffffff, localization.cancel}}
					)
					if data[2] == "OK" then
						local success, picture = pcall(image.fromString, data[1])
						if success then
							masterPixels, selection, savePath = picture, nil, nil
							tryToFitImageOnCenterOfScreen()
							drawAll()
						else
							error("–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–∑ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–∏!")
						end
					end
				elseif action == localization.transparencyPad then
					local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
						{"EmptyLine"},
						{"CenterText", 0x262626, localization.transparencyPad},
						{"EmptyLine"},
						{"Color", localization.transparencyColor .. " 1", colors.transparencyWhite},
						{"Color", localization.transparencyColor .. " 2", colors.transparencyGray},
						{"EmptyLine"},
						{"Switch", 0xF2B233, 0xffffff, 0x262626, localization.transparencyGrid, showTransparencyGrid},
						{"EmptyLine"},
						{"Button", {0xaaaaaa, 0xffffff, "OK"}, {0x888888, 0xffffff, localization.cancel}}
					)

					if data[4] == "OK" then
						colors.transparencyWhite, colors.transparencyGray, showTransparencyGrid = data[1], data[2], data[3]
						drawAll()
					end
				end

				drawTopMenu()
				buffer.draw()
			end
		else
			--–ï—Å–ª–∏ –∫–ª–∏–∫–Ω—É–ª–∏ –Ω–∞ —Ä–∏—Å–æ–≤–∞–±–µ–ª—å–Ω—É—é –∑–æ–Ω–∫—É
			if ecs.clickedAtArea(e[3], e[4], sizes.xStartOfImage, sizes.yStartOfImage, sizes.xEndOfImage, sizes.yEndOfImage) then
				
				if instruments[currentInstrument] == "M" and selection then
					local action = GUI.contextMenu(e[3], e[4], {localization.deselect}, {localization.crop, true}, "-", {localization.fill}, {localization.border}, "-", {localization.clear}):show()
					if action == localization.deselect then
						selection = nil
						drawAll()
					elseif action == localization.clear then
						fillSelection(0x0, 0x0, 0xFF, " ")
					elseif action == localization.fill then
						fillSelection(currentBackground, 0x0, 0x0, " ")
					elseif action == localization.border then
						stroke(selection.x, selection.y, selection.width, selection.height, currentBackground, true)
						drawAll()
					end
				else
					local x, y, width, height = e[3], e[4], 30, 12
					--–ê —ç—Ç–æ —á—Ç–æ–± –∑–∞ –∫—Ä–∞—è —ç–∫—Ä–∞–Ω–∞ –Ω–µ –ª–µ–∑–ª–æ
					if y + height >= buffer.screen.height then y = buffer.screen.height - height end
					if x + width + 1 >= buffer.screen.width then x = buffer.screen.width - width - 1 end

					currentBrushSize, currentAlpha = table.unpack(ecs.universalWindow(x, y, width, 0xeeeeee, true, {"EmptyLine"}, {"CenterText", 0x880000, localization.brushParameters}, {"Slider", 0x262626, 0x880000, 1, 10, currentBrushSize, localization.size ..  ": ", " px"}, {"Slider", 0x262626, 0x880000, 0, 255, currentAlpha, localization.transparency .. ": ", ""}, {"EmptyLine"}, {"Button", {0xbbbbbb, 0xffffff, "OK"}}))
					buffer.draw()
				end
			end
		end

	elseif e[1] == "key_down" then
		--–°—Ç—Ä–µ–ª–∫–∏
		if e[4] == 200 then
			move("up")
		elseif e[4] == 208 then
			move("down")
		elseif e[4] == 203 then
			move("left")
		elseif e[4] == 205 then
			move("right")
		-- --–ü—Ä–æ–±–µ–ª
		-- elseif e[4] == 57 then
		-- 	drawAll()
		--ENTER
		elseif e[4] == 28 then
			if instruments[currentInstrument] == "S" and selection and selection.finished then
				applyShapeToMasterPixels()
			end
		--BACKSPACE
		elseif e[4] == 14 then
			if selection and selection.finished then
				fillSelection(0x000000, 0x000000, 0x00, " ")
				drawAll()
			end
		--X
		elseif e[4] == 45 then
			swapColors()
			buffer.draw()
		--B
		elseif e[4] == 48 then
			changeInstrumentTo(2)
		--E
		elseif e[4] == 18 then
			changeInstrumentTo(3)
		--G
		elseif e[4] == 34 then
			changeInstrumentTo(4)
		--T
		elseif e[4] == 20 then
			changeInstrumentTo(5)
		--M
		elseif e[4] == 50 then
			changeInstrumentTo(1)
		--D
		elseif e[4] == 32 then
			if keyboard.isControlDown() then
				selection = nil
				drawAll()
			else
				currentBackground = 0x000000
				currentForeground = 0xFFFFFF
				currentAlpha = 0x00
				drawColors()
				buffer.draw()
			end
		end
	elseif e[1] == "scroll" then
		if e[5] == 1 then
			move("up")
		else
			move("down")
		end
	end
end

------------------------------------------------ –í—ã—Ö–æ–¥ –∏–∑ –ø—Ä–æ–≥—Ä–∞–º–º—ã --------------------------------------------------------------
D,MineOS/Applications/Photoshop.app/Resources/D2MineOS/Applications/Photoshop.app/Resources/About/F=MineOS/Applications/Photoshop.app/Resources/About/Russian.txt;Photoshop - —ç—Ç–æ –º–æ—â–Ω—ã–π –≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π —Ä–µ–¥–∞–∫—Ç–æ—Ä, –Ω–∞–ø–∏—Å–∞–Ω–Ω—ã–π —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –Ω–∞—à–µ–π –û–°. –û–Ω –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ä–∞–±–æ—Ç—É —Å –∫–∏—Å—Ç—è–º–∏, –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å—é, –∏–º–µ–µ—Ç —Ñ—É–Ω–∫—Ü–∏–∏ –∑–∞–ª–∏–≤–∫–∏, –≤—ã–±–æ—Ä–∞ —Ü–≤–µ—Ç–∞ –∏–∑ –∫—Ä–∞—Å–æ—á–Ω–æ–π –ø–∞–ª–∏—Ç—Ä—ã, –ø–æ–∑–≤–æ–ª—è–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å –Ω–∞—Å—Ç–æ—è—â–∏–µ –º–∏–Ω–∏-—à–µ–¥–µ–≤—Ä—ã –ø—Ä—è–º–æ –Ω–∞ –≤–∞—à–µ–º –ü–ö. –í—Å—è –≥—Ä–∞—Ñ–∏–∫–∞ –≤ –Ω–∞—à–µ–π –û–° –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω–∞ –∏–º–µ–Ω–Ω–æ –≤ —ç—Ç–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ.F4MineOS/Applications/Photoshop.app/Resources/Icon.pic£OCIFA SEF÷B TYSSFHB TYSBF÷B *YS FHB TYF÷B TYB )YYB ˇYYFˇB )YSPFHB TYS‚ñÄFˇB )YD9MineOS/Applications/Photoshop.app/Resources/Localization/FEMineOS/Applications/Photoshop.app/Resources/Localization/English.langÆ{
	newDocument = "New document",
	width = "Width",
	height = "Height",
	cancel = "Cancel",
	w = "W",
	h = "H",

	view = "View",
	transparencyPad = "Transparency pad",
	transparencyColor = "Transparency color",
	transparencyGrid = "Transparency grid",

	path = "Path",
	string = "String",
	file = "File",
	image = "Image",
	edit = "Edit",
	hotkeys = "Hot keys",
	about = "About",
	brushSize = "Brush size",
	transparency = "Transparency",
	brushParameters = "Brush parameters",
	size = "Size",

	new = "New",
	open = "Open",
	createFromString = "Create from OCIFString",
	save = "Save",
	saveAs = "Save as",
	exit = "Exit",

	crop = "Crop",
	expand = "Expand",
	rotateBy90 = "Rotate by 90 degrees",
	rotateBy180 = "Rotate by 180 degrees",
	flipVertical = "Flip vertical",
	flipHorizontal = "Flip horizontal",

	hueSaturation = "Hue/Saturation",
	colorBalance = "Color balance",
	photoFilter = "Photo filter",
	invertColors = "Invert colors",
	blackWhite = "Black and white",
	gaussianBlur = "Gaussian blur",

	countOfPixels = "Count of pixels",
	fromBottom = "From bottom",
	fromTop = "From top",
	fromLeft = "From left",
	fromRight = "From right",
	hue = "Hue",
	saturation = "Saturation",
	brightness = "Brightness",
	filterColor = "Filter color",
	radius = "Radius",
	force = "Force",
	edges = "Edges",
	accept = "Enter - accept",

	line = "Line",
	ellipse = "Ellipse",
	rectangle = "Rectangle",
	polygon = "Polygon",
	border = "Border",

	fill = "Fill",
	clear = "Clear",
	deselect = "Deselect",

	hotkeysLines = {
		{"EmptyLine"},
		{"CenterText", 0x880000, "Hotkeys"},
		{"EmptyLine"},
		{"CenterText", 0x000000, "B - Brush"},
		{"CenterText", 0x000000, "E - Eraser"},
		{"CenterText", 0x000000, "T - Text"},
		{"CenterText", 0x000000, "G - Fill"},
		{"CenterText", 0x000000, "M - Selection"},
		{"CenterText", 0x000000, " "},
		{"CenterText", 0x000000, "Arrows - move image"},
		{"CenterText", 0x000000, "X - swap colors"},
		{"CenterText", 0x000000, "D - make colors black&white"},
		{"CenterText", 0x000000, "Ctrl+D - deselect"},
		{"CenterText", 0x000000, "Alt+Click - pick color (brush only)"},
		{"EmptyLine"},
		{"Button", {0xbbbbbb, 0xffffff, "OK"}},
	},

	developers = "Developers:",
	testers = "Testers:",
}FEMineOS/Applications/Photoshop.app/Resources/Localization/Russian.langE{
	newDocument = "–ù–æ–≤—ã–π –¥–æ–∫—É–º–µ–Ω—Ç",
	width = "–®–∏—Ä–∏–Ω–∞",
	height = "–í—ã—Å–æ—Ç–∞",
	cancel = "–û—Ç–º–µ–Ω–∞",
	w = "–®",
	h = "–í",

	view = "–í–∏–¥",
	transparencyPad = "–ü–æ–¥–ª–æ–∂–∫–∞ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏",
	transparencyColor = "–¶–≤–µ—Ç –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏",
	transparencyGrid = "–°–µ—Ç–∫–∞ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏",

	path = "–ü—É—Ç—å",
	string = "–°—Ç—Ä–æ–∫–∞",
	file = "–§–∞–π–ª",
	image = "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ",
	edit = "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å",
	hotkeys = "–ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏",
	about = "–û –ø—Ä–æ–≥—Ä–∞–º–º–µ",
	brushSize = "–†–∞–∑–º–µ—Ä –∫–∏—Å—Ç–∏",
	transparency = "–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å",
	brushParameters = "–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∫–∏—Å—Ç–∏",
	size = "–†–∞–∑–º–µ—Ä",

	new = "–ù–æ–≤—ã–π",
	open = "–û—Ç–∫—Ä—ã—Ç—å",
	createFromString = "–°–æ–∑–¥–∞—Ç—å –∏–∑ OCIFString",
	save = "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
	saveAs = "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫",
	exit = "–í—ã—Ö–æ–¥",

	crop = "–û–±—Ä–µ–∑–∞—Ç—å",
	expand = "–†–∞—Å—à–∏—Ä–∏—Ç—å",
	rotateBy90 = "–ü–æ–≤–µ—Ä–Ω—É—Ç—å –Ω–∞ 90 –≥—Ä–∞–¥—É—Å–æ–≤",
	rotateBy180 = "–ü–æ–≤–µ—Ä–Ω—É—Ç—å –Ω–∞ 180 –≥—Ä–∞–¥—É—Å–æ–≤",
	flipVertical = "–û—Ç—Ä–∞–∑–∏—Ç—å –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏",
	flipHorizontal = "–û—Ç—Ä–∞–∑–∏—Ç—å –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏",

	hueSaturation = "–¢–æ–Ω/–ù–∞—Å—ã—â–µ–Ω–Ω–æ—Å—Ç—å",
	colorBalance = "–¶–≤–µ—Ç–æ–≤–æ–π –±–∞–ª–∞–Ω—Å",
	photoFilter = "–§–æ—Ç–æ—Ñ–∏–ª—å—Ç—Ä",
	invertColors = "–ò–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Ü–≤–µ—Ç–∞",
	blackWhite = "–ß–µ—Ä–Ω–æ-–±–µ–ª—ã–π —Ñ–∏–ª—å—Ç—Ä",
	gaussianBlur = "–†–∞–∑–º—ã—Ç–∏–µ –ø–æ –ì–∞—É—Å—Å—É",

	countOfPixels = "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∏–∫—Å–µ–ª–µ–π",
	fromBottom = "–°–Ω–∏–∑—É",
	fromTop = "–°–≤–µ—Ä—Ö—É",
	fromLeft = "–°–ª–µ–≤–∞",
	fromRight = "–°–ø—Ä–∞–≤–∞",
	hue = "–¢–æ–Ω",
	saturation = "–ù–∞—Å—ã—â–µ–Ω–Ω–æ—Å—Ç—å",
	brightness = "–Ø—Ä–∫–æ—Å—Ç—å",
	filterColor = "–¶–≤–µ—Ç —Ñ–∏–ª—å—Ç—Ä–∞",
	radius = "–†–∞–¥–∏—É—Å",
	force = "–°–∏–ª–∞",
	edges = "–ì—Ä–∞–Ω–∏",
	accept = "Enter - –ø—Ä–∏–º–µ–Ω–∏—Ç—å",

	line = "–õ–∏–Ω–∏—è",
	ellipse = "–≠–ª–ª–∏–ø—Å",
	rectangle = "–ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫",
	polygon = "–ú–Ω–æ–≥–æ—É–≥–æ–ª—å–Ω–∏–∫",
	border = "–†–∞–º–∫–∞",

	fill = "–ó–∞–ª–∏–≤–∫–∞",
	clear = "–û—á–∏—Å—Ç–∏—Ç—å",
	deselect = "–£–±—Ä–∞—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏–µ",

	hotkeysLines = {
		{"EmptyLine"},
		{"CenterText", 0x880000, "–ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏"},
		{"EmptyLine"},
		{"CenterText", 0x000000, "B - –∫–∏—Å—Ç—å"},
		{"CenterText", 0x000000, "E - –ª–∞—Å—Ç–∏–∫"},
		{"CenterText", 0x000000, "T - —Ç–µ–∫—Å—Ç"},
		{"CenterText", 0x000000, "G - –∑–∞–ª–∏–≤–∫–∞"},
		{"CenterText", 0x000000, "M - –≤—ã–¥–µ–ª–µ–Ω–∏–µ"},
		{"CenterText", 0x000000, " "},
		{"CenterText", 0x000000, "Arrows - –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ"},
		{"CenterText", 0x000000, "X - –ø–æ–º–µ–Ω—è—Ç—å —Ü–≤–µ—Ç–∞ –º–µ—Å—Ç–∞–º–∏"},
		{"CenterText", 0x000000, "D - —Å–º–µ–Ω–∏—Ç—å —Ü–≤–µ—Ç–∞ –Ω–∞ —á–µ—Ä–Ω—ã–π –∏ –±–µ–ª—ã–π"},
		{"CenterText", 0x000000, "Ctrl+D - —É–±—Ä–∞—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏–µ"},
		{"CenterText", 0x000000, "Alt+Click - –≤—ã–±—Ä–∞—Ç—å —Ü–≤–µ—Ç (—Ç–æ–ª—å–∫–æ –¥–ª—è –∫–∏—Å—Ç–∏)"},
		{"EmptyLine"},
		{"Button", {0xbbbbbb, 0xffffff, "OK"}},
	},

	developers = "–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏:",
	testers = "–¢–µ—Å—Ç–µ—Ä—ã:",
}DMineOS/Applications/VK.app/D%MineOS/Applications/VK.app/Resources/D+MineOS/Applications/VK.app/Resources/About/F6MineOS/Applications/VK.app/Resources/About/Russian.txtJ–ü–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π –∫–ª–∏–µ–Ω—Ç –¥–ª—è —Å–∞–π—Ç–∞ VK.com, –ø–æ–∑–≤–æ–ª—è—é—â–∏–π –æ–±—â–∞—Ç—å—Å—è —Å –≤–∞—à–∏–º–∏ –¥—Ä—É–∑—å—è–º–∏, –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å –æ—Å–Ω–æ–≤–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏—Ö –ø—Ä–æ—Ñ–∏–ª–µ–π, —á–∏—Ç–∞—Ç—å –Ω–æ–≤–æ—Å—Ç–Ω—É—é –ª–µ–Ω—Ç—É, –∞ —Ç–∞–∫–∂–µ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞—Ç—å –∞—É–¥–∏–æ–∑–∞–ø–∏—Å–∏.F-MineOS/Applications/VK.app/Resources/Icon.picÀOCIFAˇS‚ñÑFB  YS‚ñÄFB  YA	 SKFœB YSiF=B YSnF=B YSlF=B YSCF=B YS F B YYYYSVFœB YSeF=B YStF=B YF/MineOS/Applications/VK.app/Resources/VKLogo.picÜOCIF#AˇS F’B  Y	
#YYY
#Y	
F¨B  Y
F B  Y	
F7B  Y#Y"#YY !"#YY#FgB  YY !"#YY !"#Y	!"#Y	F<B  Y !"#YY	#YYY
	
A S‚ñÑF<B ’Y
B ™YB ÷Y
B ÅYB ûYB 7YYY	"B gY
YYF’B gYY
B ÅY"B ´Y
"FgB ◊YB 7YYYYYY B ’YYF7B ™YB ÅY"Y !B ¨Y	B ûY		B <YB lY!B gYY	YY"B ÄY
YYF◊B ÷YY	 B ¨YB ’YB ˇYY F™B ÅYB ◊Y
F´B <YB ÷YF÷B gYY	!B ’YYB ™YB ûYB ´YB ◊YYY!Y
B ÄYB ÅYF¨B gY	B ◊Y	Y
FˇB ûYB ¨Y !B ´YB ÷YFÄB gYB 7YYB ¨Y	FôB ûYB ÷YB 7YFÅB ◊YB ÷YYB 7YFûB 7YB ◊Y Y	
S
 F<B ÷Y	
F’B ÅYF÷B ÷Y	
YB ◊Y
F™B ÷YF¨B ◊Y	Y
 !FôB ◊YFûB ◊Y
	FgB ÷Y	
FÅB ◊Y	Y	
F◊B ˇYB ◊YYF!MineOS/Applications/VK.app/VK.lua◊Ê
---------------------------------------------------- –ë–∏–±–ª–∏–æ—Ç–µ–∫–∏ ----------------------------------------------------------------

local advancedLua = require("advancedLua")
local json = require("json")
local serialization = require("serialization")
local event = require("event")
local ecs = require("ECSAPI")
local fs = require("filesystem")
local buffer = require("doubleBuffering")
local context = require("context")
local image = require("image")
local unicode = require("unicode")
local component = require("component")
local computer = require("computer")
local GUI = require("GUI")

---------------------------------------------------- –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã ----------------------------------------------------------------

local VKAPIVersion = "5.52"

local colors = {
	leftBar = 0x262626,
	leftBarAlternative = 0x383838,
	leftBarText = 0xFFFFFF,
	leftBarSelection = 0x00A8FF,
	leftBarSelectionText = 0xFFFFFF,

	scrollBar = 0xCCCCCC,
	scrollBarPipe = 0x666666,

	mainZone = 0xFFFFFF,
	senderCloudColor = 0x3392FF,
	senderCloudTextColor = 0xFFFFFF,
	yourCloudColor = 0x55BBFF,
	yourCloudTextColor = 0xFFFFFF,
	systemMessageColor = 0x555555,
	dateTime = 0x777777,

	loginGUIBackground = 0x002440,

	topBar = 0x002440,
	topBarText = 0xFFFFFF,

	statusBar = 0x1b1b1b,
	statusBarText = 0xAAAAAA,

	audioPlayButton = 0x002440,
	audioPlayButtonText = 0xFFFFFF,

	messageInputBarColor = 0xEEEEEE,
	messageInputBarTextBackgroundColor = 0xFFFFFF,
	messsageInputBarTextColor = 0x262626,
}

local leftBarHeight = buffer.screen.height - 9
local leftBarWidth = math.floor(buffer.screen.width * 0.20)

local topBarHeight = 3

local mainZoneWidth = buffer.screen.width - leftBarWidth
local mainZoneHeight = buffer.screen.height - topBarHeight - 1
local mainZoneX = leftBarWidth + 1
local mainZoneY = topBarHeight + 1

local cloudWidth = math.floor(mainZoneWidth * 0.7)

-------------------------------------------------------------------------------------------------------------------------------

local settingsPath = "MineOS/System/VK/Settings.cfg"
local VKLogoImagePath = "MineOS/Applications/VK.app/Resources/VKLogo.pic"
-- local leftBarElements = {"–ù–æ–≤–æ—Å—Ç–∏", "–î—Ä—É–∑—å—è", "–°–æ–æ–±—â–µ–Ω–∏—è", "–ù–∞—Å—Ç—Ä–æ–π–∫–∏", "–í—ã—Ö–æ–¥"}
local leftBarElements = { "–ú–æ—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞", "–î—Ä—É–∑—å—è", "–°–æ–æ–±—â–µ–Ω–∏—è", "–ê—É–¥–∏–æ–∑–∞–ø–∏—Å–∏", "–ù–æ–≤–æ—Å—Ç–∏", "–ù–∞—Å—Ç—Ä–æ–π–∫–∏", "–í—ã—Ö–æ–¥" }
local currentLeftBarElement = 3
local personalInfo
local access_token
local whatIsOnScreen

local countOfDialogsToLoadFromServer = 10
local countOfAudioToLoadFromServer = 10
local countOfMessagesToLoadFromServer = 10

local dialogToShowFrom = 1
local audioToShowFrom = 1
local messageToShowFrom = 1

local dialogScrollSpeed = 5
local audioScrollSpeed = 5
local messagesScrollSpeed = 5
local profileScrollSpeed = 2
local friendsScrollSpeed = 5

local countOfFriendsToGetOnFriendsTab = 12
local currentFriendsOffset = 0
local currentFriends = {}

local countOfFriendsToDisplayInProfile = 16
local currentProfileY = mainZoneY + 2

local currentMessagesPeerID, currentMessagesAvatarText
local dialogPreviewTextLimit = mainZoneWidth - 15
local currentProfile

local settings = {saveAuthData = false, addSendingInfo = true}

local vip = {
	[7799889] = {avatarColor = 0x000000, avatarTextColor = 0xCCCCCC, avatarBottomText = "DEV", avatarBottomTextColor = 0x1b1b1b},
	[113499693] = {avatarColor = 0xFF99CC, avatarTextColor = 0x000000, avatarBottomText = "DEV", avatarBottomTextColor = 0xff6dbf},
	[60991376] = {avatarColor = 0xEEEEEE, avatarTextColor = 0x000000, avatarBottomText = "DEV", avatarBottomTextColor = 0x555555},
}

local messageEndAdderText = " (–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å MineOS VKClient)"

local news
local currentNews = 1
local countOfNewsToShow = 10
local countOfNewsToGet = 20

---------------------------------------------------- –í–µ–±-—á–∞—Å—Ç—å ----------------------------------------------------------------

local function loadSettings()
	if fs.exists(settingsPath) then settings = table.fromFile(settingsPath) end
end

local function saveSettings()
	table.toFile(settingsPath, settings)
end

--–û–±—ä–µ–∫—Ç—ã
local obj = {}
local function newObj(class, name, ...)
	obj[class] = obj[class] or {}
	obj[class][name] = {...}
end

--–î–µ–±–∞–≥-—Ñ—É–Ω–∫—Ü–∏—è –Ω–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≥–æ–≤–Ω–∞ –≤ —Ñ–∞–π–ª, –ú–ê–õ–û –õ–ò –ß–û
local function saveToFile(filename, stro4ka)
	local file = io.open(filename, "w")
	file:write(stro4ka)
	file:close()
end

--–ë–∞–Ω–∞–ª—å–Ω—ã–π URL-–∑–∞–ø—Ä–æ—Å, –¥–µ–∫–æ–¥–∏—Ä—É—é—â–∏–π—Å—è —á–µ—Ä–µ–∑ –ñ–£–°–û–ù –≤ —Å–ª—É—á–∞–µ —É—Å–ø–µ—Ö–∞, –µ–ø—Ç—ã
local function request(url)
	local success, response = ecs.internetRequest(url)
	if success then response = json:decode(response) end
	return success, response
end

--–û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –ø–æ –ª–æ–≥–∏–Ω—É –∏ –ø–∞—Ä–æ–ª—é
local function getLoginDataRequest(username, password)
	local url = "https://oauth.vk.com/token?grant_type=password&client_id=3697615&client_secret=AlVXZFMUqyrnABp8ncuU&username=" .. username .. "&password=" .. password .. "&v=" .. VKAPIVersion
	return request(url)
end

--–ó–∞–ø—Ä–æ—Å –∫ –º–µ—Ç–æ–¥–∞–º VK API
local function VKAPIRequest(method, ... )
	local arguments = { ... }
	local stringArguments = ""

	local url = "https://api.vk.com/method/" .. method .. "?" .. table.concat(arguments, "&") .. "&access_token=" .. access_token .. "&v=" .. VKAPIVersion

	return request(url)
end

--–ó–∞–ø—Ä–æ—Å –Ω–∞ –ø–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–∏–∞–ª–æ–≥–æ–≤
local function getDialogsRequest(fromDialog, count)
	return VKAPIRequest("messages.getDialogs", "offset=" .. fromDialog, "count=" .. count, "preview_length=" .. dialogPreviewTextLimit)
end

--–ó–∞–ø—Ä–æ—Å –Ω–∞ –ø–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–∏–∞–ª–æ–≥–æ–≤
local function getMessagesRequest(peerID, fromMessage, count)
	return VKAPIRequest("messages.getHistory", "offset=" .. fromMessage, "count=" .. count, "peer_id=" .. peerID)
end

--–ó–∞–ø—Ä–æ—Å –Ω–∞ –ø–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –º—É–∑—ã—á–∫–∏
local function getAudioRequest(id, fromAudio, count)
	return VKAPIRequest("audio.get", "offset=" .. fromAudio, "count=" .. count, "owner_id=" .. id, "need_user=1")
end

--–≠—Ç–∞ —Ö—É–π–Ω—è –¥–µ–ª–∞–µ—Ç —Å—Ç—Ä–æ–∫—É –æ—Ö—É–µ–Ω–Ω–æ–π –ø—É—Ç–µ–º –∑–∞–º–µ–Ω—ã –≥–æ–≤–Ω–∞ –Ω–∞ –∫–æ–Ω—Ñ–µ—Ç–∫—É
local function optimizeStringForURLSending(code)
  if code then
    code = string.gsub(code, "([^%w ])", function (c)
      return string.format("%%%02X", string.byte(c))
    end)
    code = string.gsub(code, " ", "+")
  end
  return code 
end

local function optimizeStringForWrongSymbols(s)
	--–£–¥–∞–ª—è–µ–º –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
	s = string.gsub(s, "	", " ")
	s = string.gsub(s, "\r\n", "\n")
	s = string.gsub(s, "\n", "")
	--–ó–∞–º–µ–Ω—è–µ–º "—à–∏—Ä–æ–∫–∏–µ" –¥–≤—É—Ö–ø–∏–∫—Å–µ–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –Ω–∞ –∑–Ω–∞–∫ –≤–æ–ø—Ä–æ—Å–∞
	local massiv = {}
	for i = 1, unicode.len(s) do
		massiv[i] = unicode.sub(s, i, i)
		if unicode.isWide(massiv[i]) then massiv[i] = "?" end
	end
	--–í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–ø—Ç–∏–º–∏–∑—Ä–æ–≤–∞–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É
	return table.concat(massiv)
end

local function convertIDtoPeerID(whatIsThisID, ID)
	if whatIsThisID == "user" then
		return ID
	elseif whatIsThisID == "chat" then
		return (2000000000 + ID)
	elseif whatIsThisID == "group" then
		return -ID
	end
end

local function getPeerIDFromMessageArray(messageArray)
	local peerID
	--–ï—Å–ª–∏ —ç—Ç–æ —á–∞—Ç
	if messageArray.users_count then
		peerID = convertIDtoPeerID("chat", messageArray.chat_id)
	--–ò–ª–∏ –µ—Å–ª–∏ —ç—Ç–æ –¥–∏–∞–ª–æ–≥ —Å –≥—Ä—É–ø–ø–æ–π –∫–∞–∫–æ–π-—Ç–æ
	elseif messageArray.user_id < 0 then
		peerID = convertIDtoPeerID("group", messageArray.user_id)
	--–ò–ª–∏ –µ—Å–ª–∏ –ø—Ä–æ—Å—Ç–æ –∫–∞–∫–æ–π-—Ç–æ —Å—Ç–∞–ª–∫–µ—Ä-–æ–¥–∏–Ω–æ—á–∫–∞
	else
		peerID = convertIDtoPeerID("user", messageArray.user_id)
	end

	return peerID
end

--–ó–∞–ø—Ä–æ—Å –Ω–∞ –æ—Ç–ø—Ä–∞–≤–∫—É —Å–æ–æ–±—â–µ–Ω–∏—è —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –ø–∏–¥–æ—Ä—É
local function sendMessageRequest(peerID, message)
	--–î–µ–ª–∞–µ–º —Å—Ç—Ä–æ—á–∫—É –Ω–µ –ø–∏–¥–æ—Ä—Å–∫–æ–π
	message = optimizeStringForURLSending(message)
	return VKAPIRequest("messages.send", "peer_id=" .. peerID, "message=" .. message)
end

local function usersInformationRequest(...)
	return VKAPIRequest("users.get", "user_ids=" .. table.concat({...}, ","), "fields=contacts,education,site,city,bdate,online,status,last_seen,quotes,about,games,books,counters,relatives,connections,blacklisted,activities,interests,music,movies,tv")
end

local function userFriendsRequest(ID, count, offset, order, nameCase)
	return VKAPIRequest("friends.get", "user_id=" .. ID, "count=" .. count, "offset=" .. offset, "order=" .. order, "name_case=" .. nameCase, "fields=domain,online,last_seen")
end

local function userFriendsListsRequest(ID) 
	return VKAPIRequest("friends.getLists", "user_id=" .. ID, "return_system=1")
end

local function userWallRequest(ID, count, offset)
	return VKAPIRequest("wall.get", "owner_id=" .. ID, "count=" .. count, "offset=" .. offset)
end

local function setCurrentAudioPlaying(ownerID, audioID)
	return VKAPIRequest("audio.setBroadcast", "audio=" .. ownerID .. "_" .. audioID)
end

local function newsRequest(count)
	return VKAPIRequest("newsfeed.get", "filters=post", "return_banned=1", "max_photos=0", "count=" .. count, "fields=name,first_name,last_name")
end

local function setCrazyTypingRequest(peer_id)
	return VKAPIRequest("messages.setActivity", "type=typing", "peer_id=" .. peer_id)
end





---------------------------------------------------- GUI-—á–∞—Å—Ç—å ----------------------------------------------------------------

local function createAvatarHashColor(hash)
	return math.abs(hash % 0xFFFFFF)
end

local function drawAvatar(x, y, width, height, user_id, text)
	local avatarColor = createAvatarHashColor(user_id)
	local textColor = avatarColor > 8388607 and 0x000000 or 0xFFFFFF

	--–•–æ—á—É —Å–µ–±–µ –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—É—é –∞–≤–∫—É, –∞ —Ç–æ —á–µ –∑–∞ —Ö—É–π–Ω—è?
	if vip[user_id] then
		avatarColor = vip[user_id].avatarColor
		textColor = vip[user_id].avatarTextColor
	end

	buffer.square(x, y, width, height, avatarColor, textColor, " ")
	buffer.text(x + math.floor(width / 2) - math.floor(unicode.len(text) / 2), y + math.floor(height / 2), textColor, unicode.upper(text))

	if vip[user_id] and vip[user_id].avatarBottomText then buffer.text(x + math.floor(width / 2) - math.floor(unicode.len(text) / 2), y + height - 1, vip[user_id].avatarBottomTextColor, vip[user_id].avatarBottomText) end
end

--–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª–∏–∫–∞ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—É—é –æ–±–ª–∞—Å—Ç—å –ø–æ "–æ–±—ä–µ–∫—Ç—É". –ö–æ–º—É –Ω–∞ —Ö—É–π –≤—Å—Å–∞–ª–æ—Å—å –û–û–ü?
local function clickedAtZone(x, y, zone)
	if x >= zone[1] and y >= zone[2] and x <= zone[3] and y <= zone[4] then
		return true
	end
	return false
end

--–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –ª–æ–≥–∏–Ω–∞ –≤ –∞–∫–∫–∞—É–Ω—Ç –í–ö, –ø–æ—Å—Ç–∞—Ä–∞—é—Å—å —Å–¥–µ–ª–∞—Ç—å –ø–æ–≥—Ä–∞—Ñ–æ–Ω–∏—Å—Ç–µ–π
--–•–æ—Ç—è —Ö–∞—Ö! –ö–æ–≥–æ —è –æ–±–º–∞–Ω—ã–≤–∞—é, –∞–≥–∞
local function loginGUI(startUsername, startPassword)
	local background = 0x002440
	local buttonColor = 0x666DFF
	local textColor = 0x262626
	local username, password = startUsername or "E-Mail –∏–ª–∏ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞", startPassword or "–ü–∞—Ä–æ–ª—å"

	local textFieldWidth = 50
	local textFieldHeight = 3
	local x, y = math.floor(buffer.screen.width / 2 - textFieldWidth / 2), math.floor(buffer.screen.height / 2)

	local obj = {}
	obj.username = {x, y, x + textFieldWidth - 1, y + 2}; y = y + textFieldHeight + 1
	obj.password = {x, y, x + textFieldWidth - 1, y + 2}; y = y + textFieldHeight + 1
	obj.button = GUI.button(x, y, textFieldWidth, textFieldHeight, buttonColor, 0xFFFFFF, 0xFFFFFF, buttonColor, "–í–æ–π—Ç–∏")

	local VKLogoImage = image.load(VKLogoImagePath)

	local function draw()
		buffer.clear(colors.loginGUIBackground)

		buffer.image(x + 5, obj.username[2] - 15, VKLogoImage)

		buffer.square(x, obj.username[2], textFieldWidth, 3, 0xFFFFFF, 0x000000, " ")
		buffer.square(x, obj.password[2], textFieldWidth, 3, 0xFFFFFF, 0x000000, " ")
		buffer.text(x + 1, obj.username[2] + 1, textColor, ecs.stringLimit("end", username, textFieldWidth - 2))
		buffer.text(x + 1, obj.password[2] + 1, textColor, ecs.stringLimit("end", string.rep("‚óè", unicode.len(password)), textFieldWidth - 2))

		obj.button:draw()

		buffer.draw()
	end

	while true do
		draw()
		local e = {event.pull()}
		if e[1] == "touch" then
			if clickedAtZone(e[3], e[4], obj.username) then
				username = ""
				username = ecs.inputText(x + 1, obj.username[2] + 1, textFieldWidth - 2, username, 0xFFFFFF, 0x262626) or ""
			
			elseif clickedAtZone(e[3], e[4], obj.password) then
				password = ""
				password = ecs.inputText(x + 1, obj.password[2] + 1, textFieldWidth - 2, password, 0xFFFFFF, 0x262626, false, "*") or ""
			
			elseif obj.button:isClicked(e[3], e[4]) then
				obj.button:press(0.2)
				draw()
				local success, loginData = getLoginDataRequest(username, password)
				if success then 
					if settings.saveAuthData then settings.username = username; settings.password = password; saveSettings() end
					loginData.username = username
					loginData.password = password
					return loginData
				else
					GUI.error("–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏: " .. tostring(loginData))
				end
			end
		end
	end
end

---------------------------------------------------- GUI –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å VK API ----------------------------------------------

local function drawPersonalAvatar(x, y, width, height)
	drawAvatar(x, y, width, height, personalInfo.id, unicode.sub(personalInfo.first_name, 1, 1) .. unicode.sub(personalInfo.last_name, 1, 1))
end

local function status(text)
	buffer.square(mainZoneX, buffer.screen.height, mainZoneWidth, 1, colors.statusBar)
	buffer.text(mainZoneX + 1, buffer.screen.height, colors.statusBarText, text)
	buffer.draw()
end

local function drawTopBar(text)
	buffer.square(mainZoneX, 1, mainZoneWidth, 3, colors.topBar)
	local x = math.floor(mainZoneX + mainZoneWidth / 2 - unicode.len(text) / 2 - 1)
	buffer.text(x, 2, colors.topBarText, text)
end

--–†–∏—Å—É–µ–º –≥–ª–∞–≤–Ω—É—é –∑–æ–Ω—É
local function clearGUIZone()
	buffer.square(mainZoneX, mainZoneY, mainZoneWidth, mainZoneHeight, colors.mainZone)
end

local function drawEmptyCloud(x, y, cloudWidth, cloudHeight, cloudColor, fromYou)
	local upperPixel = "‚ñÄ"
	local lowerPixel = "‚ñÑ"

	--–†–∏—Å—É–µ–º —Ñ–∏–Ω—Ç–∏—Ñ–ª—é—à–µ—á–∫–∏
	if not fromYou then
		buffer.set(x, y - cloudHeight + 2, colors.mainZone, cloudColor, upperPixel)
		buffer.set(x + 1, y - cloudHeight + 2, cloudColor, 0xFFFFFF, " ")
		x = x + 2
	else
		buffer.set(x + cloudWidth + 3, y - cloudHeight + 2, colors.mainZone, cloudColor, upperPixel)
		buffer.set(x + cloudWidth + 2, y - cloudHeight + 2, cloudColor, 0xFFFFFF, " ")
	end

	--–ó–∞–ø–æ–ª–Ω—è—à–µ—á–∫–∏
	buffer.square(x + 1, y - cloudHeight + 1, cloudWidth, cloudHeight, cloudColor, 0xFFFFFF, " ")
	buffer.square(x, y - cloudHeight + 2, cloudWidth + 2, cloudHeight - 2, cloudColor, 0xFFFFFF, " ")
	
	--–°–≥—Ä—É–≥–ª–µ–Ω–Ω—ã–µ –∫—Ä–∞–µ—à–∫–∏
	buffer.set(x, y - cloudHeight + 1, colors.mainZone, cloudColor, lowerPixel)
	buffer.set(x + cloudWidth + 1, y - cloudHeight + 1, colors.mainZone, cloudColor, lowerPixel)
	buffer.set(x, y, colors.mainZone, cloudColor, upperPixel)
	buffer.set(x + cloudWidth + 1, y, colors.mainZone, cloudColor, upperPixel)

	return y - cloudHeight + 1
end

local function drawTextCloud(x, y, cloudColor, textColor, fromYou, text)
	local y = drawEmptyCloud(x, y, cloudWidth, #text + 2, cloudColor, fromYou)
	x = fromYou and x + 2 or x + 4

	for i = 1, #text do
		buffer.text(x, y + i, textColor, text[i])
	end

	return y
end

local function getAttachments(messageArray)
	local text = "–í–ª–æ–∂–µ–Ω–∏—è: "
	for j = 1, #messageArray.attachments do
		if messageArray.attachments[j].type == "sticker" then
			text = text .. "—Å—Ç–∏–∫–µ—Ä, "
		elseif messageArray.attachments[j].type == "photo" then
			text = text .. "—Ñ–æ—Ç–æ, "
		elseif messageArray.attachments[j].type == "video" then
			text = text .. "–≤–∏–¥–µ–æ, "
		elseif messageArray.attachments[j].type == "audio" then
			text = text .. "–∞—É–¥–∏–æ, "
		elseif messageArray.attachments[j].type == "wall" then
			text = text .. "–∑–∞–ø–∏—Å—å –Ω–∞ —Å—Ç–µ–Ω–µ, "
		end
	end
	text = unicode.sub(text, 1, -3)

	return text
end

local function drawMessageInputBar(currentText)
	local x, y = mainZoneX, buffer.screen.height - 5
	obj.messageInputBar = GUI.object(x, y, mainZoneWidth - 4, 4)
	buffer.square(x, y, mainZoneWidth, 5, colors.messageInputBarColor)
	buffer.square(x + 2, y + 1, mainZoneWidth - 4, 3, colors.messageInputBarTextBackgroundColor)
	buffer.text(x + 4, y + 2, colors.messsageInputBarTextColor, ecs.stringLimit("start", currentText or "–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ", mainZoneWidth - 8))
end

local function getUserNamesFromTheirIDs(IDsArray)
	local success, usersData = usersInformationRequest(table.unpack(IDsArray))
	local userNames = {}
	if success and usersData.response then
		for i = 1, #usersData.response do
			userNames[usersData.response[i].id] = {
				first_name = usersData.response[i].first_name,
				last_name = usersData.response[i].last_name,
			}
		end
	end
	return success, userNames
end

local function messagesGUI()

	status("–ó–∞–≥—Ä—É–∂–∞—é –∏—Å—Ç–æ—Ä–∏—é –ø–µ—Ä–µ–ø–∏—Å–∫–∏")
	local success, messages = getMessagesRequest(currentMessagesPeerID, messageToShowFrom - 1, countOfMessagesToLoadFromServer)
	if success and messages.response then

		whatIsOnScreen = "messages"

		if currentMessagesPeerID > 2000000000 then
			status("–ó–∞–≥—Ä—É–∂–∞—é –∏–º–µ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏–∑ –ø–µ—Ä–µ–ø–∏—Å–∫–∏ (–∞–∫—Ç—É–∞–ª—å–Ω–æ –¥–ª—è –∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏–π)")

			local IDsArray = {};
			for i = 1, #messages.response.items do table.insert(IDsArray, messages.response.items[i].user_id) end
			local userNamesSuccess, userNames = getUserNamesFromTheirIDs(IDsArray)
			for i = 1, #messages.response.items do 
				messages.response.items[i].first_name = userNames[messages.response.items[i].user_id].first_name or "N/A"
				messages.response.items[i].last_name = userNames[messages.response.items[i].user_id].last_name or "N/A"
			end
			IDsArray = nil
		end

		clearGUIZone()
		drawTopBar("–°–æ–æ–±—â–µ–Ω–∏—è")

		-- saveToFile("lastMessagesRequest.json", serialization.serialize(messages))

		buffer.setDrawLimit(mainZoneX, mainZoneY, mainZoneWidth, mainZoneHeight)

		local y = buffer.screen.height - 7
		local xSender = mainZoneX + 2
		local xYou = buffer.screen.width - 7

		for i = 1, #messages.response.items do

			local messageTextArray = {}

			--–ï—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ –ø–∏–∑–¥–∞—Ç–∞—è
			if messages.response.items[i].body ~= "" then table.insert(messageTextArray, optimizeStringForWrongSymbols(messages.response.items[i].body)) end
			if messages.response.items[i].fwd_messages then table.insert(messageTextArray, "–ü–µ—Ä–µ—Å–ª–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è") end
			if messages.response.items[i].attachments then table.insert(messageTextArray, getAttachments(messages.response.items[i])) end
			if messages.response.items[i].action == "chat_invite_user" then table.insert(messageTextArray, "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–¥ ID " .. messages.response.items[i].from_id .. " –ø—Ä–∏–≥–ª–∞—Å–∏–ª –≤ –±–µ—Å–µ–¥—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ–¥ ID " .. messages.response.items[i].action_mid) end

			messageTextArray = string.wrap(messageTextArray, cloudWidth - 4)
			local peerID = getPeerIDFromMessageArray(messages.response.items[i])

			--–î–µ–ª–∞–µ–º –¥–∞—Ç—É –ø–∏–∑–¥–∞—Ç–æ–π
			-- messages.response.items[i].date = os.date("%d.%m.%y –≤ %X", messages.response.items[i].date)
			messages.response.items[i].date = os.date("%H:%M", messages.response.items[i].date)

			if messages.response.items[i].out == 1 then
				y = drawTextCloud(xYou - cloudWidth - 6, y, colors.yourCloudColor, colors.yourCloudTextColor, true, messageTextArray)
				drawPersonalAvatar(xYou, y, 6, 3)
				buffer.text(xYou - cloudWidth - unicode.len(messages.response.items[i].date) - 8, y + 1, colors.dateTime, messages.response.items[i].date)
			else
				y = drawTextCloud(xSender + 8, y, colors.senderCloudColor, colors.senderCloudTextColor, false, messageTextArray)
				drawAvatar(xSender, y, 6, 3, peerID, messages.response.items[i].first_name and (unicode.sub(messages.response.items[i].first_name, 1, 1) .. unicode.sub(messages.response.items[i].last_name, 1, 1)) or currentMessagesAvatarText)
				buffer.text(xSender + cloudWidth + 14, y + 1, colors.dateTime, messages.response.items[i].date)
			end

			y = y - 2
		end

		local currentText

		drawMessageInputBar(currentText)

		status("–ò—Å—Ç–æ—Ä–∏—è –ø–µ—Ä–µ–ø–∏—Å–∫–∏ –∑–∞–≥—Ä—É–∂–µ–Ω–∞, –æ–∂–∏–¥–∞—é –≤–≤–æ–¥–∞ —Å–æ–æ–±—â–µ–Ω–∏—è")

		buffer.resetDrawLimit()
		-- buffer.draw()
	end
end

local function drawDialog(y, dialogBackground, avatarID, avatarText, text1, text2, text3)
	--–†–∏—Å—É–µ–º –ø–æ–¥–ª–æ–∂–∫—É –ø–æ–¥ –¥–∏–∞–ª–æ–≥ –Ω—É–∂–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞
	buffer.square(mainZoneX, y, mainZoneWidth, 5, dialogBackground)
	--–†–∏—Å—É–µ–º –∞–≤–∞—Ç–∞—Ä–∫—É, —á–æ —É–∂
	drawAvatar(mainZoneX + 2, y + 1, 6, 3, avatarID, avatarText)
	--–ü–∏—à–µ–º –≤—Å–µ, —á—Ç–æ –Ω—É–∂–Ω–æ
	y = y + 1
	if text1 then buffer.text(mainZoneX + 10, y, 0x000000, text1); y = y + 1 end
	if text2 then buffer.text(mainZoneX + 10, y, 0x555555, text2); y = y + 1 end
	if text3 then buffer.text(mainZoneX + 10, y, 0x666666, text3); y = y + 1 end
end

local function dialogsGUI()

	local success, dialogs = getDialogsRequest(dialogToShowFrom - 1, countOfDialogsToLoadFromServer)
	if success and dialogs.response then
		
		whatIsOnScreen = "dialogs"

		obj.dialogList = {}

		clearGUIZone()
		drawTopBar("–°–æ–æ–±—â–µ–Ω–∏—è")

		--–ï–±–∞—à–∏–º –ö–ù–û–ü–ê–ß–ö–ò —Å–ø–∞–º–∞
		obj.crazyTypingButton = GUI.adaptiveButton(mainZoneX + 2, 2, 1, 0, 0xFFFFFF, colors.topBar, 0xAAAAAA, 0x000000, "CrazyTyping")
		-- obj.spamButton = {buffer.adaptiveButton(obj.crazyTypingButton[3] + 2, 2, 1, 0, 0xFFFFFF, colors.topBar, "–°–ø–∞–º")}

		--–ù–£ –¢–´ –ü–û–ù–Ø–õ, –ê–ì–ê
		status("–ü–æ–ª—É—á–∞—é –∏–º–µ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ ID")
		local IDsArray = {}
		for i = 1, #dialogs.response.items do
			if not dialogs.response.items[i].message.chat_id and dialogs.response.items[i].message.user_id and dialogs.response.items[i].message.user_id > 0 then
				table.insert(IDsArray, dialogs.response.items[i].message.user_id)
			end
		end
		local userNamesSuccess, userNames = getUserNamesFromTheirIDs(IDsArray)
		for i = 1, #dialogs.response.items do
			if not dialogs.response.items[i].message.chat_id and dialogs.response.items[i].message.user_id and dialogs.response.items[i].message.user_id > 0 then
				dialogs.response.items[i].message.title = userNames[dialogs.response.items[i].message.user_id].first_name or "N/A" .. " " .. userNames[dialogs.response.items[i].message.user_id].last_name or ""
			end
		end

		local y = mainZoneY
		local avatarText = ""
		local peerID
		local color

		for i = 1, #dialogs.response.items do
			--–ï–±–µ–º—Å—è —Å —Ü–≤–µ—Ç–∞–º–∏
			if dialogs.response.items[i].unread then
				if i % 2 == 0 then 
					color = 0xCCDBFF
				else
					color = 0xCCDBFF
				end
			else
				if i % 2 == 0 then 
					color = 0xEEEEEE
				else
					color = 0xFFFFFF
				end
			end
			
			avatarText = unicode.sub(dialogs.response.items[i].message.title, 1, 2)
			peerID = getPeerIDFromMessageArray(dialogs.response.items[i].message)

			--–ï–±–ª—è —Å —Ç–µ–∫—Å—Ç–æ–º –¥–∏–∞–ª–æ–≥–∞
			local text1 = dialogs.response.items[i].message.title
			local text2
			local text3

			--–ï—Å–ª–∏ —ç—Ç–æ –±–∞–Ω–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
			if dialogs.response.items[i].message.body and dialogs.response.items[i].message.body ~= "" then
				text2 = optimizeStringForWrongSymbols(dialogs.response.items[i].message.body)
			end

			--–ï—Å–ª–∏ –µ—Å—Ç—å –∫–∞–∫–∏–µ-–ª–∏–±–æ –ø–µ—Ä–µ—Å–ª–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è, —Ç–æ
			if dialogs.response.items[i].message.fwd_messages then
				text3 = "–ü–µ—Ä–µ—Å–ª–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è"
			--–ï—Å–ª–∏ –µ—Å—Ç—å –∫–∞–∫–∏–µ-–ª–∏–±–æ –≤–ª–æ–∂–µ–Ω–∏—è, —Ç–æ
			elseif dialogs.response.items[i].message.attachments then
				text3 = getAttachments(dialogs.response.items[i].message)
			end

			--–†–∏—Å—É–µ–º –¥–∏–∞–ª–æ–≥
			drawDialog(y, color, peerID, avatarText, text1, text2, text3)

			--–†–∏—Å—É–µ–º –ø–∏–∑–¥—é–ª–∏–Ω–∫—É, –ø–æ–∫–∞–∑—ã–≤–∞—é—â—É—é –∫–æ–ª-–≤–æ –Ω–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
			if dialogs.response.items[i].unread and dialogs.response.items[i].unread ~= 0 then
				local cyka = tostring(dialogs.response.items[i].unread)
				local cykaWidth = unicode.len(cyka) + 2
				local cykaX = buffer.screen.width - cykaWidth - 2
				buffer.square(cykaX, y + 2, cykaWidth, 1, ecs.colors.blue)
				buffer.text(cykaX + 1, y + 2, 0xFFFFFF, cyka)
			end

			obj.dialogList[i] = GUI.object(mainZoneX, y, mainZoneWidth, 5)
			obj.dialogList[i][5], obj.dialogList[i][6], obj.dialogList[i][7], obj.dialogList[i][8], obj.dialogList[i][9] = peerID, avatarText, text1, text2, text3

			y = y + 5
		end
	end

	status("–°–ø–∏—Å–æ–∫ –¥–∏–∞–ª–æ–≥–æ–≤ –ø–æ–ª—É—á–µ–Ω")
end

--–ì—É–∏—à–∫–∞ –∞—É–¥–∏–æ–∑–∞–ø–∏—Å–µ–π
--–ê-–ê-–ê-–ê!!!!! –ú–û–ô –ö–†–ê–°–ò–í–´–ô –¢–†–ï–£–ì–û–õ–¨–ù–ò–ß–ï–ö PLAY, –ë–õ–Ø–î–¨!!!! –®–¢–û –¢–´ –î–ï–õ–ê–ï–®–¨, SANGAR, –ü–†–ï–ö–†–ê–¢–ò!!!!
local function audioGUI(ID)
	status("–ó–∞–≥—Ä—É–∂–∞—é —Å–ø–∏—Å–æ–∫ –∞—É–¥–∏–æ–∑–∞–ø–∏—Å–µ–π")
	local success, audios = getAudioRequest(ID, audioToShowFrom - 1, countOfAudioToLoadFromServer)
	if success and audios.response then
		whatIsOnScreen = "audio"
		obj.audio = {}
		clearGUIZone()
		drawTopBar("–ê—É–¥–∏–æ–∑–∞–ø–∏—Å–∏ " .. audios.response.items[1].name_gen)

		local y = mainZoneY
		local color
		for i = 2, #audios.response.items do
			color = 0xFFFFFF
			if i % 2 == 0 then color = 0xEEEEEE end

			buffer.square(mainZoneX, y, mainZoneWidth, 5, color)
			obj.audio[i] = GUI.button(mainZoneX + 2, y + 1, 5, 3, colors.audioPlayButton, colors.audioPlayButtonText, 0x66FF80, colors.audioPlayButton, ">")
			obj.audio[i][5] = audios.response.items[i]

			local x = mainZoneX + 9
			buffer.text(x, y + 1, colors.audioPlayButton, audios.response.items[i].artist)
			x = x + unicode.len(audios.response.items[i].artist)
			buffer.text(x, y + 1, 0x000000, " - " .. audios.response.items[i].title)

			x = mainZoneX + 9
			local hours = string.format("%02.f", math.floor(audios.response.items[i].duration / 3600))
			local minutes = string.format("%02.f", math.floor(audios.response.items[i].duration / 60 - (hours * 60)))
			local seconds = string.format("%02.f", math.floor(audios.response.items[i].duration - hours * 3600 - minutes * 60))
			buffer.text(x, y + 2, 0x888888, "–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: " .. hours .. ":" .. minutes .. ":" .. seconds)

			y = y + 5
		end
	else
		GUI.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –∞—É–¥–∏–æ–∑–∞–ø–∏—Å–µ–π")
	end
end

local function checkField(field)
	if field and field ~= "" and field ~= " " then return true end
	return false
end

local function userProfileRequest()
	--–ï–±–∞—à–∏–º –æ—Å–Ω–æ–≤–Ω—É—é –∏–Ω—Ñ—É
	status("–ó–∞–≥—Ä—É–∂–∞—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –ø–æ–¥ ID " .. currentProfile.ID)
	local profileSuccess, userProfile = usersInformationRequest(currentProfile.ID)
	
	--–ï–±–∞—à–∏–º —Å—Ç–µ–Ω—É
	status("–ó–∞–≥—Ä—É–∂–∞—é —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å—Ç–µ–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è " .. currentProfile.ID)
	local wallSuccess, wall = userWallRequest(currentProfile.ID, 20, currentProfile.wallOffset)
	--–ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ—É –æ —é–∑–≤–µ—Ä—è—Ö —Å–æ —Å—Ç–µ–Ω—ã
	local userNamesSuccess, userNames
	if wallSuccess and wall.response then
		local IDsArray = {}
		for i = 1, #wall.response.items do table.insert(IDsArray, wall.response.items[i].from_id) end
		status("–ó–∞–≥—Ä—É–∂–∞—é –∏–º–µ–Ω–∞ –ª—é–¥–µ–π, –æ—Å—Ç–∞–≤–∏–≤—à–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–∞ —Å—Ç–µ–Ω–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è " .. currentProfile.ID)
		userNamesSuccess, userNames = getUserNamesFromTheirIDs(IDsArray)
		IDsArray = nil
	end

	--–ï–±–∞—à–∏–º —Ñ—Ä–µ–Ω–¥—Å–æ–≤
	status("–ó–∞–≥—Ä—É–∂–∞—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –¥—Ä—É–∑—å—è—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ–¥ ID " .. currentProfile.ID)
	local friendsSuccess, friends = userFriendsRequest(currentProfile.ID, countOfFriendsToDisplayInProfile, 0, "random", "nom")

	--–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –Ω–∞ –ø–∏–∑–¥–∞—Ç–æ—Å—Ç—å
	if (profileSuccess and userProfile.response) and (wallSuccess and wall.response) and (userNamesSuccess) and (friendsSuccess and friends.response) then
		-- saveToFile("lastUserProfileRequest.json", serialization.serialize(userProfile))
		currentProfile.userProfile = userProfile
		currentProfile.wall = wall
		currentProfile.userNames = userNames
		currentProfile.friends = friends
		return true
	else
		GUI.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø—Ä–æ—Ñ–∏–ª–µ")
		return false
	end
end

local function userProfileGUI()
	clearGUIZone()
	whatIsOnScreen = "userProfile"
	drawTopBar("–°—Ç—Ä–∞–Ω–∏—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è " .. currentProfile.ID)

	buffer.setDrawLimit(mainZoneX, mainZoneY, mainZoneWidth, mainZoneHeight)

	local xAvatar, yAvatar = mainZoneX + 4, currentProfileY
	local x, y = xAvatar, yAvatar
	local avatarWidth = 18
	local avatarHeight = math.floor(avatarWidth / 2)

	--–†–∏—Å—É–µ–º –∞–≤–∫—É
	currentProfile.avatarText =  unicode.sub(currentProfile.userProfile.response[1].first_name, 1, 1) .. unicode.sub(currentProfile.userProfile.response[1].last_name, 1, 1)
	drawAvatar(x, y, avatarWidth, avatarHeight, currentProfile.ID, currentProfile.avatarText)
	--–†–∏—Å—É–µ–º –∏–º—è—á–∫–æ –∏ —Å—Ç–∞—Ç—É—Å
	x = x + avatarWidth + 4
	buffer.text(x, y, 0x000000, currentProfile.userProfile.response[1].first_name .. " " .. currentProfile.userProfile.response[1].last_name); y = y + 1
	buffer.text(x, y, 0xAAAAAA, currentProfile.userProfile.response[1].status); y = y + 2

	--–ò–Ω—Ñ–∞–∞–∞–∞–∞
	local informationOffset = 20
	local informationKeyColor = 0x888888
	local informationTitleColor = 0x000000
	local informationValueColor = 0x002440
	local informationSeparatorColor = 0xCCCCCC

	local function drawInfo(x, y2, key, value)
		if checkField(value) then
			value = {value}
			value = string.wrap(value, buffer.screen.width - x - 4 - informationOffset)
			buffer.text(x, y2, informationKeyColor, key)
			for i = 1, #value do
				buffer.text(x + informationOffset, y2, informationValueColor, value[i])
				y2 = y2 + 1
			end
			y = y2
		end
	end

	local function drawSeparator(x, y2, text)
		buffer.text(x, y2, informationTitleColor, text)
		buffer.text(x + unicode.len(text) + 1, y2, informationSeparatorColor, string.rep("‚îÄ", buffer.screen.width - x - unicode.len(text)))
		y = y + 1
	end

	drawSeparator(x, y, "–û—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è"); y = y + 1

	drawInfo(x, y, "–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è:", currentProfile.userProfile.response[1].bdate)
	if currentProfile.userProfile.response[1].city then drawInfo(x, y, "–ì–æ—Ä–æ–¥:", currentProfile.userProfile.response[1].city.title) end
	drawInfo(x, y, "–û–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ:", currentProfile.userProfile.response[1].university_name)
	drawInfo(x, y, "–í–µ–±-—Å–∞–π—Ç", currentProfile.userProfile.response[1].site); y = y + 1

	drawSeparator(x, y, "–ö–æ–Ω—Ç–∞–∫—Ç–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è"); y = y + 1

	drawInfo(x, y, "–ú–æ–±–∏–ª—å–Ω—ã–π —Ç–µ–ª–µ—Ñ–æ–Ω:", currentProfile.userProfile.response[1].mobile_phone)
	drawInfo(x, y, "–î–æ–º–∞—à–Ω–∏–π —Ç–µ–ª–µ—Ñ–æ–Ω:", currentProfile.userProfile.response[1].home_phone)
	drawInfo(x, y, "Skype:", currentProfile.userProfile.response[1].skype); y = y + 1

	drawSeparator(x, y, "–õ–∏—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è"); y = y + 1

	drawInfo(x, y, "–ò–Ω—Ç–µ—Ä–µ—Å—ã:", currentProfile.userProfile.response[1].interests)
	drawInfo(x, y, "–î–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å:", currentProfile.userProfile.response[1].activities)
	drawInfo(x, y, "–õ—é–±–∏–º–∞—è –º—É–∑—ã–∫–∞:", currentProfile.userProfile.response[1].music)
	drawInfo(x, y, "–õ—é–±–∏–º–∞—è —Ñ–∏–ª—å–º—ã:", currentProfile.userProfile.response[1].movies)
	drawInfo(x, y, "–õ—é–±–∏–º–∞—è —Ç–µ–ª–µ—à–æ—É:", currentProfile.userProfile.response[1].tv)
	drawInfo(x, y, "–õ—é–±–∏–º–∞—è –∫–Ω–∏–≥–∏:", currentProfile.userProfile.response[1].books)
	drawInfo(x, y, "–õ—é–±–∏–º–∞—è –∏–≥—Ä—ã:", currentProfile.userProfile.response[1].games)
	drawInfo(x, y, "–û —Å–µ–±–µ:", currentProfile.userProfile.response[1].about)

	-- –ê –í–û–¢ –ò –°–¢–ï–ù–û–ß–ö–ê –ü–û–î–™–ï–•–ê–õ–ê –ù–ê –ü–†–ê–ó–î–ù–ò–ö –î–£–®–ò
	y = y + 1
	buffer.square(x, y, buffer.screen.width - x - 2, 1, 0xCCCCCC); buffer.text(x + 1, y, 0x262626, "–°—Ç–µ–Ω–∞"); y = y + 2
	--–ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –≤—Å—é —Å—Ç–µ–Ω–∫—É
	for i = 1, #currentProfile.wall.response.items do
		--–ï—Å–ª–∏ —ç—Ç–æ –Ω–µ —Ä–µ–ø–æ—Å—Ç –∏–ª–∏ –µ—â–µ –Ω–µ —Ö—É–π–Ω—è –∫–∞–∫–∞—è-—Ç–æ
		if currentProfile.wall.response.items[i].text ~= "" then
			-- GUI.error(userNames)
			drawAvatar(x, y, 6, 3, currentProfile.wall.response.items[i].from_id, unicode.sub(currentProfile.userNames[currentProfile.wall.response.items[i].from_id].first_name, 1, 1) .. unicode.sub(currentProfile.userNames[currentProfile.wall.response.items[i].from_id].last_name, 1, 1))
			buffer.text(x + 8, y, informationValueColor, currentProfile.userNames[currentProfile.wall.response.items[i].from_id].first_name .. " " .. currentProfile.userNames[currentProfile.wall.response.items[i].from_id].last_name)
			local date = os.date("%d.%m.%y –≤ %H:%M", currentProfile.wall.response.items[i].date)
			buffer.text(buffer.screen.width - unicode.len(date) - 2, y, 0xCCCCCC, date)
			y = y + 1
			local text = {currentProfile.wall.response.items[i].text}
			text = string.wrap(text, buffer.screen.width - x - 10)
			for i = 1, #text do
				buffer.text(x + 8, y, 0x000000, text[i])
				y = y + 1
			end
			y = y + 1
			if #text == 1 then y = y + 1 end
		end
	end

	--–ü–æ–¥–ê–≤–æ—á–Ω–∞—è –ø–∞—Ä–∞—à–∞
	informationOffset = 13
	x, y = xAvatar, yAvatar
	y = y + avatarHeight + 1

	currentProfile.avatarWidth = avatarWidth
	currentProfile.sendMessageButton = GUI.button(x, y, avatarWidth, 1, 0xCCCCCC, 0x000000, 0x888888, 0x000000,"–°–æ–æ–±—â–µ–Ω–∏–µ")
	y = y + 2
	currentProfile.audiosButton = GUI.button(x, y, avatarWidth, 1, 0xCCCCCC, 0x000000, 0x888888, 0x000000, "–ê—É–¥–∏–æ–∑–∞–ø–∏—Å–∏")
	y = y + 2

	drawInfo(x, y, "–ü–æ–¥–ø–∏—Å—á–∏–∫–∏: ", currentProfile.userProfile.response[1].counters.followers)
	drawInfo(x, y, "–§–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏: ", currentProfile.userProfile.response[1].counters.photos)
	drawInfo(x, y, "–í–∏–¥–µ–æ–∑–∞–ø–∏—Å–∏: ", currentProfile.userProfile.response[1].counters.videos)
	drawInfo(x, y, "–ê—É–¥–∏–æ–∑–∞–ø–∏—Å–∏: ", currentProfile.userProfile.response[1].counters.audios)

	--–î—Ä—É–∑—è—à–∫–∏, –ï–ü–¢–ê–ê–ê–ê–ê–ê, –ê–•–ê–•–ê–•–ê–•–ê–•–ê–•–ê–•–ê–•–ê–•–ê		
	y = y + 1
	buffer.square(x, y, avatarWidth, 1, 0xCCCCCC); buffer.text(x + 1, y, 0x262626, "–î—Ä—É–∑—å—è (" .. currentProfile.userProfile.response[1].counters.friends .. ")"); y = y + 2
	local xPos, yPos = x + 1, y
	local count = 1
	for i = 1, #currentProfile.friends.response.items do
		drawAvatar(xPos, yPos, 6, 3, currentProfile.friends.response.items[i].id, unicode.sub(currentProfile.friends.response.items[i].first_name, 1, 1) .. unicode.sub(currentProfile.friends.response.items[i].last_name, 1, 1))
		buffer.text(xPos - 1, yPos + 3, 0x000000, ecs.stringLimit("end", currentProfile.friends.response.items[i].first_name .. " " .. currentProfile.friends.response.items[i].last_name, 8))
		xPos = xPos + 10
		if i % 2 == 0 then xPos = x + 1; yPos = yPos + 5 end
		count = count + 1
		if count > countOfFriendsToDisplayInProfile then break end
	end

	buffer.resetDrawLimit()
end

local function loadAndShowProfile(ID)
	currentProfileY = mainZoneY + 2
	currentProfile = {ID = ID, wallOffset = 0}
	if userProfileRequest() then userProfileGUI(currentProfile.ID) end
end

local function friendsGUI()
	status("–ó–∞–≥—Ä—É–∂–∞—é —Å–ø–∏—Å–æ–∫ –¥—Ä—É–∑–µ–π")
	local success, friends = userFriendsRequest(personalInfo.id, countOfFriendsToGetOnFriendsTab, currentFriendsOffset, "hints", "nom")
	status("–ó–∞–≥—Ä—É–∂–∞—é —Å–ø–∏—Å–æ–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –¥—Ä—É–∑–µ–π")
	local successLists, friendsLists = userFriendsListsRequest(personalInfo.id)
	if (success and friends.response) and (successLists and friendsLists.response) then
		-- saveToFile("lastFriendsResponse.json", serialization.serialize(friends))
		clearGUIZone()
		currentFriends = {sendMessageButtons = {}, openProfileButtons = {}}
		whatIsOnScreen = "friends"
		drawTopBar("–î—Ä—É–∑—å—è")
		buffer.setDrawLimit(mainZoneX, mainZoneY, mainZoneWidth, mainZoneHeight)

		local function getListName(listID)
			local name = "N/A"
			for i = 1, #friendsLists.response.items do
				if friendsLists.response.items[i].id == listID then
					name = friendsLists.response.items[i].name
					break
				end
			end
			return name
		end

		local x, y = mainZoneX + 2, mainZoneY
		for i = 1, #friends.response.items do
			--–ü–∞–¥–ª–æ–∂–∫–∞
			if i % 2 == 0 then buffer.square(mainZoneX, y, mainZoneWidth, 5 + (friends.response.items[i].lists and 1 or 0), 0xEEEEEE) end
			--–Æ–∑–µ—Ä
			y = y + 1
			local subbedName = unicode.sub(friends.response.items[i].first_name, 1, 1) .. unicode.sub(friends.response.items[i].last_name, 1, 1)
			drawAvatar(x, y, 6, 3, friends.response.items[i].id, subbedName)
			local text = friends.response.items[i].first_name .. " " .. friends.response.items[i].last_name
			buffer.text(x + 8, y, colors.topBar, text)
			local text2 = friends.response.items[i].last_seen and (", " .. (friends.response.items[i].online == 1 and "–æ–Ω–ª–∞–π–Ω" or "–±—ã–ª(–∞) –≤ —Å–µ—Ç–∏ " .. os.date("%d.%m.%y –≤ %H:%M", friends.response.items[i].last_seen.time))) or " "
			buffer.text(x + 8 + unicode.len(text), y, 0xAAAAAA, text2)

			if friends.response.items[i].lists then
				y = y + 1
				local cykaX = x + 8
				for listID = 1, #friends.response.items[i].lists do
					local listName = getListName(friends.response.items[i].lists[listID])
					local listWidth = unicode.len(listName) + 2
					local listBackColor = math.floor(0xFFFFFF / friends.response.items[i].lists[listID])
					local listTextColor = (listBackColor > 0x7FFFFF and 0x000000 or 0xFFFFFF)
					buffer.square(cykaX, y, listWidth, 1, listBackColor, listTextColor, " ")
					buffer.text(cykaX + 1, y, listTextColor, listName)
					cykaX = cykaX + listWidth + 2
				end
			end

			y = y + 1
			buffer.text(x + 8, y, 0x999999, "–ù–∞–ø–∏—Å–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ")
			currentFriends.sendMessageButtons[friends.response.items[i].id] = {x + 8, y, x + 18, y, subbedName}
			y = y + 1
			buffer.text(x + 8, y, 0x999999, "–û—Ç–∫—Ä—ã—Ç—å –ø—Ä–æ—Ñ–∏–ª—å")
			currentFriends.openProfileButtons[friends.response.items[i].id] = {x + 8, y, x + 18, y, subbedName}

			y = y + 2
		end

		buffer.resetDrawLimit()
	else
		GUI.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –¥—Ä—É–∑–µ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
	end
end

local function newsGUI()
	clearGUIZone()
	drawTopBar("–ù–æ–≤–æ—Å—Ç–∏")
	whatIsOnScreen = "news"
	buffer.setDrawLimit(mainZoneX, mainZoneY, mainZoneWidth, mainZoneHeight)

	local function getAvatarTextAndNameForNews(source_id)
		local avatarText, name = "N/A", "N/A"
		if source_id < 0 then
			for i = 1, #news.response.groups do
				if news.response.groups[i].id == math.abs(source_id) then
					avatarText = unicode.sub(news.response.groups[i].name, 1, 2)
					name = news.response.groups[i].name
					break
				end
			end
		else
			for i = 1, #news.response.profiles do
				if news.response.profiles[i].id == source_id then
					avatarText = unicode.sub(news.response.profiles[i].first_name, 1, 1) .. unicode.sub(news.response.profiles[i].last_name, 1, 1)
					name = news.response.profiles[i].first_name .. " " .. news.response.profiles[i].last_name
					break
				end
			end
		end
		return avatarText, name
	end

	local x, y = mainZoneX + 2, mainZoneY
	for item = currentNews, currentNews + countOfNewsToShow do
		if news.response.items[item] then
			--–î–µ–ª–∞–µ–º —Ç–µ–∫—Å—Ç –ø–∏–∑–¥–∞—Ç—ã–º
			news.response.items[item].text = optimizeStringForWrongSymbols(news.response.items[item].text)
			--–£–±–∏—Ä–∞–µ–º –≥–æ–≤–Ω–æ –∏–∑ –Ω–æ–≤–æ—Å—Ç–µ–π
			if news.response.items[item].text == "" then
				if news.response.items[item].copy_history then
					news.response.items[item].text = "–†–µ–ø–æ—Å—Ç"
				elseif news.response.items[item].attachments then
					 news.response.items[item].text = getAttachments(news.response.items[item])
				end
			end
			--–î–µ–ª–∞–µ–º –µ–≥–æ –µ—â–µ –ø–∏–∑–∂–µ
			local text = {news.response.items[item].text}; text = string.wrap(text, buffer.screen.width - x - 10)
			--–ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ—É –Ω—É–∂–Ω—É—é
			local avatarText, name = getAvatarTextAndNameForNews(news.response.items[item].source_id)
			--–°–º–µ—Å—Ç–∏—Ç—å—Å—è –ø–æ—Ç–æ–º –Ω–∞ —Å—Ç–æ–∫–∞ –≤–æ—Ç
			local yShift = 5
			if #text > 2 then yShift = yShift + #text - 2 end
			
			--–†–∏—Å—É–µ–º –∞–≤–∫—É –∏ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ö—É–π–Ω–∏
			if item % 2 == 0 then buffer.square(mainZoneX, y, mainZoneWidth, yShift, 0xEEEEEE) end
			drawAvatar(x, y + 1, 6, 3, math.abs(news.response.items[item].source_id), avatarText)
			buffer.text(x + 7, y + 1, colors.topBar, name)
			--–†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç
			for line = 1, #text do
				buffer.text(x + 7, y + line + 1, 0x000000, text[line])
			end

			y = y + yShift
		end
	end

	buffer.resetDrawLimit()
end

local function getAndShowNews()
	status("–ó–∞–≥—Ä—É–∂–∞—é —Å–ø–∏—Å–æ–∫ –Ω–æ–≤–æ—Å—Ç–µ–π")
	local success, news1 = newsRequest(countOfNewsToGet)
	if success and news1.response then
		news = news1
		currentNews = 1
		newsGUI()
	else
		GUI.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –Ω–æ–≤–æ—Å—Ç–µ–π")
	end
end

local function drawLeftBar()
	--–ü–æ–¥–ª–æ–∂–∫–∞ –ø–æ–¥ —ç–ª–µ–º–µ–Ω—Ç—ã
	buffer.square(1, 1, leftBarWidth, buffer.screen.height, colors.leftBar, 0xFFFFFF, " ")
	
	if personalInfo then
		drawPersonalAvatar(3, 2, 6, 3)
		buffer.text(11, 3, 0xFFFFFF, ecs.stringLimit("end", personalInfo.first_name .. " " .. personalInfo.last_name, leftBarWidth - 11))
	end

	--–≠–ª–µ–º–µ–Ω—Ç—ã
	obj.leftBar = {}
	local y, color = 6
	for i = 1, #leftBarElements do
		color = colors.leftBarAlternative
		if i % 2 == 0 then color = colors.leftBar end
		if i == currentLeftBarElement then color = colors.leftBarSelection end

		newObj("leftBar", i, 1, y, leftBarWidth, y + 2)

		buffer.square(1, y, leftBarWidth, 3, color, 0xFFFFFF, " ")
		y = y + 1
		buffer.text(3, y, colors.leftBarText, ecs.stringLimit("end", leftBarElements[i], leftBarWidth - 4))
		y = y + 2
	end
end

--–ì–ª–∞–≤–Ω–æ–µ –ì–£–ò —Å –ª–µ–≤—Ç–±–∞—Ä–æ–º –∏ –ø—Ä–æ—á–∏–º
local function mainGUI()
	drawLeftBar()
	--–û—Ç–æ–±—Ä–∞–∂–∞–µ–º –≥—É—é –Ω—É–∂–Ω—É—é –≤—ã–±—Ä–∞–Ω–Ω—É—é
	if leftBarElements[currentLeftBarElement] == "–°–æ–æ–±—â–µ–Ω–∏—è" then
		status("–ü–æ–ª—É—á–∞—é —Å–ø–∏—Å–æ–∫ –¥–∏–∞–ª–æ–≥–æ–≤")
		messageToShowFrom = 1
		dialogToShowFrom = 1
		dialogsGUI()
	elseif leftBarElements[currentLeftBarElement] == "–ê—É–¥–∏–æ–∑–∞–ø–∏—Å–∏" then
		status("–ü–æ–ª—É—á–∞—é —Å–ø–∏—Å–æ–∫ –∞—É–¥–æ–∑–∞–ø–∏—Å–µ–π")
		audioToShowFrom = 1
		audioGUI(personalInfo.id)
	elseif leftBarElements[currentLeftBarElement] == "–ú–æ—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞" then
		loadAndShowProfile(personalInfo.id)
		-- loadAndShowProfile(186860159)
	elseif leftBarElements[currentLeftBarElement] == "–î—Ä—É–∑—å—è" then
		friendsGUI()
	elseif leftBarElements[currentLeftBarElement] == "–ù–æ–≤–æ—Å—Ç–∏" then
		getAndShowNews()
	end

	buffer.draw()
end

local function spam(id)
	while true do
		local randomMessages = {
			"–¢—ã –º–æ–µ –∑–æ–ª–æ—Ç—Ü–µ",
			"–¢—ã –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ —Å–¥–µ–ª–∞–µ—à—å —Å–∞–π—Ç",
			"–¢—ã –Ω–∏—á—Ç–æ–∂–µ—Å—Ç–≤–æ",
			"–¢–≤–æ—è –∂–∏–∑–Ω—å –Ω–∏—á–µ–≥–æ –Ω–µ –∑–Ω–∞—á–∏—Ç",
			"–¢—ã –Ω–∏—á–µ–≥–æ –Ω–µ –¥–æ–±—å–µ—à—å—Å—è",
			"–¢—ã –∑–∞–≤–∞–ª–∏—à—å —ç–∫–∑–∞–º–µ–Ω—ã",
			"–¢—ã –Ω–∏–∫–æ–º—É –Ω–µ –Ω—É–∂–Ω–∞",
			"–¢—ã –Ω–µ –Ω–∞–ø–∏—à–µ—à—å –∫—É—Ä—Å–æ–≤—É—é",
			"–¢–≤–æ–µ –∂–∏–≤–æ—Ç–Ω–æ–µ –ø–æ–º—Ä–µ—Ç –∑–∞–≤—Ç—Ä–∞",
			"–ù–µ –¥–æ–±–∞–≤–ª—è–π –≤ –ß–°!",
			"–ü–µ—Ä–µ–¥–∞–µ–º –ø—Ä–∏–≤–µ—Ç –æ—Ç –Ø—à–∏ –∏ –ú–µ–Ω—è (–∞ –∫—Ç–æ —è?)",
			"–•—É–π!",
			"–ü–∏–∑–¥–∞!",
			"–ó–∞–ª—É–ø–∞!",
			"–ü–µ–Ω–∏—Å!",
			"–•–µ—Ä!",
			"–î–∞–≤–∞–ª–∫–∞!"
		}
		local text = randomMessages[math.random(1, #randomMessages)] .. " (—Å –ª—é–±–æ–≤—å—é, –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å OpenComputers)"
		sendMessageRequest(tostring(id), text)
		print("–û—Ç–ø—Ä–∞–≤–ª—è—é —Å–æ–æ–±—â–µ–Ω–∏–µ: " .. text)
		os.sleep(2)
	end
end


---------------------------------------------------- –°—Ç–∞—Ä—Ç —Å–∫—Ä–∏–ø—Ç–∞ ----------------------------------------------------------------

--–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫—É –¥–≤–æ–π–Ω–æ–≥–æ –±—É—Ñ—Ñ–µ—Ä–∞
--–≠—Ö, —á—Ç–æ –±—ã —è –¥–µ–ª–∞–ª, –µ—Å–ª–∏ –± –Ω–µ –Ω–∞–∫–æ–¥–∏–ª –µ–µ? 0.2 —Ñ–ø—Å –Ω–∞ GPU –º–µ—Ä—Ç–≤–µ—Ü–∞!
buffer.start()
--–•—É—è—Ä–∏–º –Ω–∞—Å—Ç—Ä—Ä—Ä—Ä—Ä–æ–µ—á–∫–∏
loadSettings()
--–ê–∫—Ç–∏–≤–∏—Ä—É–µ–º —Ñ–æ—Ä–º—É –ª–æ–≥–∏–Ω–∞
local loginData = loginGUI(settings.username or "E-Mail", settings.password or "password")
access_token = loginData.access_token
--–ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
_, personalInfo = usersInformationRequest(loginData.user_id)
personalInfo = personalInfo.response[1]

-- --–ï–±–µ–º—Å—è –≤ –ø–æ–ø—á–∞–Ω—Å–∫–∏–π
-- spam(21321257)

--–ê–∫—Ç–∏–≤–∏—Ä—É–µ–º –≥–ª–∞–≤–Ω–æ–µ GUI
clearGUIZone()
mainGUI()

while true do
	local e = {event.pull()}
	if e[1] == "touch" then

		if whatIsOnScreen == "audio" then
			for key in pairs(obj.audio) do
				if obj.audio[key]:isClicked(e[3], e[4]) then
					obj.audio[key]:press(0.2)

					if component.isAvailable("openfm_radio") then
						component.openfm_radio.stop()
						component.openfm_radio.setURL(obj.audio[key][5].url)
						component.openfm_radio.start()
						status("–í—ã–≤–æ–∂—É –≤ —Å—Ç–∞—Ç—É—Å –∏–≥—Ä–∞–µ–º—É—é –º—É–∑—ã–∫—É")
						setCurrentAudioPlaying(currentProfile and currentProfile.ID or personalInfo.id, obj.audio[key][5].id)
					else
						GUI.error("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–≥–æ –º–æ–¥–∞ OpenFM, –¥–æ–±–∞–≤–ª—è—é—â–µ–≥–æ –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω–æ–µ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-—Ä–∞–¥–∏–æ")
					end

					break
				end
			end
		end

		if whatIsOnScreen == "dialogs" then
			for key in pairs(obj.dialogList) do
				if obj.dialogList[key]:isClicked(e[3], e[4]) then
					drawDialog(obj.dialogList[key].y, 0xFF8888, obj.dialogList[key][5], obj.dialogList[key][6], obj.dialogList[key][7], obj.dialogList[key][8], obj.dialogList[key][9])
					buffer.draw()
					os.sleep(0.2)
					status("–ó–∞–≥—Ä—É–∂–∞—é –ø–µ—Ä–µ–ø–∏—Å–∫—É —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º " .. obj.dialogList[key][7])
					currentMessagesPeerID = obj.dialogList[key][5]
					currentMessagesAvatarText = obj.dialogList[key][6]
					messagesGUI()
					break
				end
			end

			if obj.crazyTypingButton:isClicked(e[3], e[4]) then
				obj.crazyTypingButton:press(0.2)
				local data = ecs.universalWindow("auto", "auto", 36, 0x262626, true,
					{"EmptyLine"},
					{"CenterText", ecs.colors.orange, "CrazyTyping"},
					{"EmptyLine"},
					{"Slider", 0xFFFFFF, ecs.colors.orange, 1, 15, 5, "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–∏–∞–ª–æ–≥–æ–≤: ", ""},
					{"Slider", 0xFFFFFF, ecs.colors.orange, 1, 100, 5, "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø—Ä–æ—Å–æ–≤: ", ""},
					{"Slider", 0xFFFFFF, ecs.colors.orange, 1, 5000, 500, "–ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏: ", " –º—Å"},
					{"EmptyLine"},
					{"Button", {ecs.colors.orange, 0xffffff, "OK"}, {0x999999, 0xffffff, "–û—Ç–º–µ–Ω–∞"}}
				)
				if data[4] == "OK" then
					for i = 1, data[2] do
						local count = 1
						for key in pairs(obj.dialogList) do
							-- GUI.error("–ï–±–∞—à—É —Å–ø–∞–º –¥–∏–∞–ª–æ–≥—É –ø–æ–¥ –ø–∏—Ä–æ–º: " .. obj.dialogList[key][5])
							ecs.info("auto", "auto", "CrazyTyping", "–ó–∞–ø—Ä–æ—Å: " .. i ..  " –∏–∑ " .. data[2] ..  ", –¥–∏–∞–ª–æ–≥: " .. count .. " –∏–∑ ".. data[1] .. ", peerID: " .. obj.dialogList[key][5])
							setCrazyTypingRequest(obj.dialogList[key][5])
							count = count + 1
							if count > data[1] then break end
							os.sleep(data[3] / 1000)
						end
					end
					buffer.draw(true)
				end
			end
		end

		if whatIsOnScreen == "messages" then
			if obj.messageInputBar:isClicked(e[3], e[4]) then
				drawMessageInputBar(" ")
				buffer.draw()
				local newText = ecs.inputText(obj.messageInputBar.x + 4, obj.messageInputBar.y + 2, obj.messageInputBar.width - 4, "", colors.messageInputBarTextBackgroundColor, colors.messsageInputBarTextColor)
				if newText and newText ~= " " and newText ~= "" then
					computer.beep(1700)
					status("–û—Ç–ø—Ä–∞–≤–ª—è—é —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é")
					sendMessageRequest(currentMessagesPeerID, newText .. (settings.addSendingInfo and messageEndAdderText or ""))
					status("–û–±–Ω–æ–≤–ª—è—é –∏—Å—Ç–æ—Ä–∏—é –ø–µ—Ä–µ–ø–∏—Å–∫–∏")
					messageToShowFrom = 1
					messagesGUI()
				end
				drawMessageInputBar(" ")
			end
		end

		if whatIsOnScreen == "userProfile" then
			if currentProfile.audiosButton:isClicked(e[3], e[4]) then
				currentProfile.audiosButton:press(0.2)
				audioToShowFrom = 1
				audioGUI(currentProfile.ID)
				buffer.draw()
			elseif currentProfile.sendMessageButton:isClicked(e[3], e[4]) then
				currentProfile.sendMessageButton:press(0.2)
				currentMessagesPeerID = currentProfile.ID
				messageToShowFrom = 1
				currentMessagesAvatarText = currentProfile.avatarText
				messagesGUI()
			end
		end

		if whatIsOnScreen == "friends" then
			for ID in pairs(currentFriends.sendMessageButtons) do
				if clickedAtZone(e[3], e[4], currentFriends.sendMessageButtons[ID]) then
					buffer.text(currentFriends.sendMessageButtons[ID][1], currentFriends.sendMessageButtons[ID][2], 0x000000, "–ù–∞–ø–∏—Å–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ")
					buffer.draw()
					currentMessagesPeerID = ID
					messageToShowFrom = 1
					currentMessagesAvatarText = currentFriends.sendMessageButtons[ID][5]
					messagesGUI()
					break
				end
			end

			for ID in pairs(currentFriends.openProfileButtons) do
				if clickedAtZone(e[3], e[4], currentFriends.openProfileButtons[ID]) then
					buffer.text(currentFriends.openProfileButtons[ID][1], currentFriends.openProfileButtons[ID][2], 0x000000, "–û—Ç–∫—Ä—ã—Ç—å –ø—Ä–æ—Ñ–∏–ª—å")
					buffer.draw()
					loadAndShowProfile(ID)
					buffer.draw()
					break
				end
			end
		end

		for key in pairs(obj.leftBar) do
			if clickedAtZone(e[3], e[4], obj.leftBar[key]) then
				-- GUI.error("–ö–ª–∏–∫–Ω—É–ª–∏ –Ω–∞ –ª–µ—Ñ—Ç –±–∞—Ä —ç—ç–ª–µ–º–µ–Ω—Ç")
				local oldLeftBarElement = currentLeftBarElement
				currentLeftBarElement = key

				drawLeftBar()
				buffer.draw()

				if leftBarElements[currentLeftBarElement] == "–í—ã—Ö–æ–¥" then
					os.sleep(0.3)
					buffer.clear(0x262626)
					ecs.prepareToExit()
					return
				elseif leftBarElements[currentLeftBarElement] == "–ê—É–¥–∏–æ–∑–∞–ø–∏—Å–∏" then
					currentProfile = currentProfile or {}
					currentProfile.ID = personalInfo.id
				elseif leftBarElements[currentLeftBarElement] == "–ù–∞—Å—Ç—Ä–æ–π–∫–∏" then
					local data = ecs.universalWindow("auto", "auto", 36, 0x262626, true,
						{"EmptyLine"},
						{"CenterText", ecs.colors.orange, "–ù–∞—Å—Ç—Ä–æ–π–∫–∏"},
						{"EmptyLine"},
						{"Switch", ecs.colors.orange, 0xffffff, 0xFFFFFF, "–°–æ—Ö—Ä–∞–Ω—è—Ç—å –¥–∞–Ω–Ω—ã–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏", settings.saveAuthData},
						{"EmptyLine"},
						{"Switch", ecs.colors.orange, 0xffffff, 0xFFFFFF, "–î–æ–±–∞–≤–ª—è—Ç—å –ø—Ä–∏–ø–∏—Å–∫—É \"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å ...\"", settings.addSendingInfo},
						{"EmptyLine"},
						{"CenterText", ecs.colors.orange, "OpenComputers VK Client v4.0"},
						{"EmptyLine"},
						{"CenterText", ecs.colors.white, "–ê–≤—Ç–æ—Ä: –ò–≥–æ—Ä—å –¢–∏–º–æ—Ñ–µ–µ–≤, vk.com/id7799889"},
						{"CenterText", ecs.colors.white, "–í—Å–µ –ø—Ä–∞–≤–∞ –∑–∞—â–∏—â–µ–Ω—ã, –µ–ø—Ç–∞! –ü–æ–ø—Ä–æ–±—É–π —Ç–æ–ª—å–∫–æ —Å–ø–∏–∑–¥–∏—Ç—å!"},
						{"EmptyLine"},
						{"Button", {ecs.colors.orange, 0xffffff, "OK"}, {0x999999, 0xffffff, "–û—Ç–º–µ–Ω–∞"}}
					)
					if data[3] == "OK" then
						settings.saveAuthData = data[1]
						settings.addSendingInfo = data[2]

						if settings.saveAuthData then
							settings.username = loginData.username
							settings.password = loginData.password
						else
							settings.username = nil
							settings.password = nil
						end
						saveSettings()

						currentLeftBarElement = oldLeftBarElement
					end
				end

				mainGUI()
				break
			end
		end
	elseif e[1] == "scroll" then
		if e[5] == 1 then
			if whatIsOnScreen == "dialogs" then
				dialogToShowFrom = dialogToShowFrom - dialogScrollSpeed
				if dialogToShowFrom < 1 then dialogToShowFrom = 1 end
				status("–ü—Ä–æ–∫—Ä—É—á–∏–≤–∞—é –¥–∏–∞–ª–æ–≥–∏, –æ—Ç–ø—Ä–∞–≤–ª—è—é –∑–∞–ø—Ä–æ—Å –Ω–∞ —Å–µ—Ä–≤–µ—Ä")
				dialogsGUI()
				buffer.draw()
			elseif whatIsOnScreen == "messages" then
				messageToShowFrom = messageToShowFrom + messagesScrollSpeed
				status("–ü—Ä–æ–∫—Ä—É—á–∏–≤–∞—é —Å–æ–æ–±—â–µ–Ω–∏—è, –æ—Ç–ø—Ä–∞–≤–ª—è—é –∑–∞–ø—Ä–æ—Å –Ω–∞ —Å–µ—Ä–≤–µ—Ä")
				messagesGUI()
				buffer.draw()
			elseif whatIsOnScreen == "audio" then
				audioToShowFrom = audioToShowFrom - audioScrollSpeed
				if audioToShowFrom < 1 then audioToShowFrom = 1 end
				status("–ü—Ä–æ–∫—Ä—É—á–∏–≤–∞—é –∞—É–¥–æ–∑–∞–ø–∏—Å–∏, –æ—Ç–ø—Ä–∞–≤–ª—è—é –∑–∞–ø—Ä–æ—Å –Ω–∞ —Å–µ—Ä–≤–µ—Ä")
				audioGUI(currentProfile and currentProfile.ID or personalInfo.id)
				buffer.draw()
			elseif whatIsOnScreen == "userProfile" then
				currentProfileY = currentProfileY + profileScrollSpeed
				if currentProfileY > mainZoneY + 2 then currentProfileY = mainZoneY + 2 end
				userProfileGUI()
				buffer.draw()
			elseif whatIsOnScreen == "friends" then
				currentFriendsOffset = currentFriendsOffset - friendsScrollSpeed
				if currentFriendsOffset < 0 then currentFriendsOffset = 0 end
				friendsGUI()
				buffer.draw()
			elseif whatIsOnScreen == "news" then
				currentNews = currentNews - 1
				if currentNews < 1 then currentNews = 1 end
				newsGUI()
				buffer.draw()
			end
		else
			if whatIsOnScreen == "dialogs" then
				dialogToShowFrom = dialogToShowFrom + dialogScrollSpeed
				status("–ü—Ä–æ–∫—Ä—É—á–∏–≤–∞—é –¥–∏–∞–ª–æ–≥–∏, –æ—Ç–ø—Ä–∞–≤–ª—è—é –∑–∞–ø—Ä–æ—Å –Ω–∞ —Å–µ—Ä–≤–µ—Ä")
				dialogsGUI()
				buffer.draw()
			elseif whatIsOnScreen == "messages" then
				messageToShowFrom = messageToShowFrom - messagesScrollSpeed
				if messageToShowFrom < 1 then messageToShowFrom = 1 end
				status("–ü—Ä–æ–∫—Ä—É—á–∏–≤–∞—é —Å–æ–æ–±—â–µ–Ω–∏—è, –æ—Ç–ø—Ä–∞–≤–ª—è—é –∑–∞–ø—Ä–æ—Å –Ω–∞ —Å–µ—Ä–≤–µ—Ä")
				messagesGUI()
				buffer.draw()
			elseif whatIsOnScreen == "audio" then
				audioToShowFrom = audioToShowFrom + audioScrollSpeed
				status("–ü—Ä–æ–∫—Ä—É—á–∏–≤–∞—é –∞—É–¥–æ–∑–∞–ø–∏—Å–∏, –æ—Ç–ø—Ä–∞–≤–ª—è—é –∑–∞–ø—Ä–æ—Å –Ω–∞ —Å–µ—Ä–≤–µ—Ä")
				audioGUI(currentProfile and currentProfile.ID or personalInfo.id)
				buffer.draw()
			elseif whatIsOnScreen == "userProfile" then
				currentProfileY = currentProfileY - profileScrollSpeed
				userProfileGUI()
				buffer.draw()
			elseif whatIsOnScreen == "friends" then
				currentFriendsOffset = currentFriendsOffset + friendsScrollSpeed
				friendsGUI()
				buffer.draw()
			elseif whatIsOnScreen == "news" then
				currentNews = currentNews + 1
				newsGUI()
				buffer.draw()
			end
		end
	end
end

-- local success, dialogs = getDialogsRequest(0, 5)
-- saveToFile(serialization.serialize(dialogs))


-- sendMessageRequest(dialogs.response.items[2], "—Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —á–µ—Ä–µ–∑ OpenComputers VK Client by –ò–≥–æ—Ä—å, –µ–ø—Ç–∞")





DMineOS/Applications/Viewer.app/D)MineOS/Applications/Viewer.app/Resources/D/MineOS/Applications/Viewer.app/Resources/About/F:MineOS/Applications/Viewer.app/Resources/About/Russian.txtÿ–ü—Ä–æ–≥—Ä–∞–º–º–∞ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤ –Ω–∞—à–µ–º —Ñ–æ—Ä–º–∞—Ç–µ .pic, –∏–º–µ–µ—Ç—Å—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–Ω–∏—è –∫–∞—Ä—Ç–∏–Ω–æ–∫ –≤ —Ä–µ–∂–∏–º–µ —Å–ª–∞–π–¥—à–æ—É.F1MineOS/Applications/Viewer.app/Resources/Icon.picıOCIFA S‚ñÄF B ÿYB ¸YB êYB  YB ÏYB CYB ¶YS F B ÿYB ¸YB êYB  YYB ÏYB CYB ¶YS‚ñÑF’B  YAˇS‚ñôF¨B  YS‚ñÑF¨B  YS F’B  YF¨B  YS‚ñüF¨B  YF6MineOS/Applications/Viewer.app/Resources/arrowLeft.picõOCIFAˇS‚ñÄF◊B  YYS‚ñÅF◊B  YS‚ñîF◊B  YS‚ñÑF◊B  YYS F B  YF◊B  YYA S F◊B ◊YYF7MineOS/Applications/Viewer.app/Resources/arrowRight.picõOCIFAˇS‚ñÄF◊B  YYS‚ñÅF◊B  YS‚ñîF◊B  YS‚ñÑF◊B  YYS F B  YF◊B  YYA S F◊B ◊YYF1MineOS/Applications/Viewer.app/Resources/play.pic°OCIFAˇS‚ñÄFÚB  YYS‚ñÅFÚB  YS‚ñîFÚB  YS‚ñÑFÚB  YYS F B  YFÚB  YYYYA S FÚB ÚYYF)MineOS/Applications/Viewer.app/Viewer.lua¿
local computer = require("computer")
local ecs = require("ECSAPI")
local image = require("image")
local fs = require("filesystem")
local buffer = require("doubleBuffering")
local unicode = require("unicode")
local event = require("event")

local pathToApplicationResources = "MineOS/Applications/Viewer.app/Resources/"
local currentPath = "MineOS/Pictures/"
local imageList = {}
local currentImage = 1
local showGUI = true
local slideShowInterval = 5
local enableSlideShow = true

local arrowLeftImage = image.load(pathToApplicationResources .. "arrowLeft.pic")
local arrowRightImage = image.load(pathToApplicationResources .. "arrowRight.pic")
local playImage = image.load(pathToApplicationResources .. "play.pic")
local wallpaperImage = image.load("MineOS/System/OS/Icons/Computer.pic")

local obj = {}

buffer.start()

local function loadImageList()
	local fileList = fs.list(currentPath)
	imageList = {}
	for file in fileList do
		if ecs.getFileFormat(file) == ".pic" then
			table.insert(imageList, currentPath .. file)
		end
	end
end

local function drawImage()
	if #imageList > 0 then
		local xImage, yImage = 1, 1   
		local currentLoadedImage = image.load(imageList[currentImage])
		
		if currentLoadedImage.width < buffer.screen.width then xImage = math.floor(buffer.screen.width / 2 - currentLoadedImage.width / 2) end
		if currentLoadedImage.height < buffer.screen.height then yImage = math.floor(buffer.screen.height / 2 - currentLoadedImage.height / 2) end
		
		buffer.image(xImage, yImage, currentLoadedImage)
		currentLoadedImage = nil
	else
		local text = "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ \"" .. currentPath .. "\" –Ω–µ –Ω–∞–π–¥–µ–Ω—ã"
		buffer.text(math.floor(buffer.screen.width / 2 - unicode.len(text) / 2), math.floor(buffer.screen.height / 2), 0x000000, text)
	end
end

local function multipleButtons(x, y, widthOfButton, heightOfButton, spaceBetweenButtons, ...)
	local buttons = {...}
	local objectsToReturn = {}
	for i = 1, #buttons do
		buffer.button(x, y, widthOfButton, heightOfButton, buttons[i][1], buttons[i][2], buttons[i][3])
		table.insert(objectsToReturn, {x, y, x + widthOfButton - 1, y + heightOfButton - 1})
		x = x + widthOfButton + spaceBetweenButtons
	end
	return objectsToReturn
end

local function drawBottomButtons()
	local y = buffer.screen.height - 4
	local x = math.floor(buffer.screen.width / 2 - 21)

	obj.arrowLeft = {x, y, x + 7, y + 3} 
	buffer.image(x, y, arrowLeftImage); x = x + 10
	obj.play = {x, y, x + 7, y + 3} 
	buffer.image(x, y, playImage); x = x + 10
	obj.arrowRight = {x, y, x + 7, y + 3} 
	buffer.image(x, y, arrowRightImage); x = x + 12
	obj.wallpaper = {x, y, x + 7, y + 3} 
	buffer.image(x, y, wallpaperImage)
end

local function drawGUI()
	if showGUI then
		--–í–µ—Ä—Ö–Ω–∏–π –±–∞—Ä
		buffer.square(1, 1, buffer.screen.width, 1, 0xDDDDDD, 0xFFFFFF, " ")
		local text = #imageList > 0 and ecs.stringLimit("start", imageList[currentImage], 40) or "Viewer"
		buffer.text(math.floor(buffer.screen.width / 2 - unicode.len(text) / 2), 1, 0x000000, text)
		buffer.text(2, 1, ecs.colors.red, "‚¨§")
		buffer.text(5, 1, ecs.colors.orange, "‚¨§")
		buffer.text(8, 1, ecs.colors.green, "‚¨§")

		--–ù–∏–∂–Ω–∏–π –±–∞—Ä
		local height = 6
		local transparency = 40
		local y = buffer.screen.height - height + 1
		buffer.square(1, y, buffer.screen.width, height, 0x000000, 0xFFFFFF, " ", transparency)
		-- multipleButtons(math.floor(buffer.screen.width / 2 - 16), y, 7, 3, 2, {0xEEEEEE, 0x262626, "‚Üê"}, {0xEEEEEE, 0x262626, "‚ñ∫"}, {0xEEEEEE, 0x262626, "‚Üí"}, {0xEEEEEE, 0x262626, "‚ô•"})
		drawBottomButtons()
	end
end

local function drawAll(force)
	buffer.clear(0xFFFFFF)

	drawImage()
	drawGUI()

	buffer.draw(force)
end

local function prevImage()
	currentImage = currentImage - 1
	if currentImage < 1 then currentImage = #imageList end
	drawAll()
end

local function nextImage()
	currentImage = currentImage + 1
	if currentImage > #imageList then currentImage = 1 end
	drawAll()
end

local function slideShowDro4er()
	nextImage()
end

local function enableSlideShowDro4er()
	enableSlideShow = true
	_G.imageViewerSlideShowTimer = event.timer(slideShowInterval, slideShowDro4er, math.huge)
end

local function clicked(x, y, obj)
	if obj and ecs.clickedAtArea(x, y, obj[1], obj[2], obj[3], obj[4]) and #imageList > 0 then
		return true
	end
	return false
end

local function press(x, y)
	buffer.square(x, y, 10, 6, 0x000000, 0xFFFFFF, " ", 60)
	drawBottomButtons()
	buffer.draw()
	os.sleep(0.2)
	drawAll()
end

------------------------------------------------------------------------------------------------------------------------------------------------

local args = {...}

if args[1] == "open" then
	if args[2] then
		currentPath = fs.path(args[2])
		loadImageList()
		for i = 1, #imageList do
			if args[2] == imageList[i] then currentImage = i; break end
		end
	else
		ecs.error("Invalid arguments!")
		return
	end
else
	loadImageList()
end

drawAll()

while true do
	local e = {event.pull()}
	if e[1] == "touch" then

		if enableSlideShow then
			showGUI = true
			enableSlideShow = false
			if _G.imageViewerSlideShowTimer then event.cancel(_G.imageViewerSlideShowTimer) end
			drawAll()
		end

		if clicked(e[3], e[4], obj.arrowLeft) then
			press(obj.arrowLeft[1] - 1, obj.arrowLeft[2] - 1)
			prevImage()
		elseif clicked(e[3], e[4], obj.play) then
			press(obj.play[1] - 1, obj.play[2] - 1)
			showGUI = false
			obj = {}
			enableSlideShowDro4er()
			drawAll()
		elseif clicked(e[3], e[4], obj.arrowRight) then
			press(obj.arrowRight[1] - 1, obj.arrowRight[2] - 1)
			nextImage()
		elseif clicked(e[3], e[4], obj.wallpaper) then
			press(obj.wallpaper[1] - 1, obj.wallpaper[2] - 1)
			buffer.clear(0x262626)
			buffer.draw()
			ecs.createShortCut("MineOS/System/OS/Wallpaper.lnk", imageList[currentImage])
			computer.pushSignal("MineOSCore", "updateWallpaper")
			return
		elseif (e[3] >= 2 and e[3] <= 3 and e[4] == 1) then
			buffer.text(2, 1, ecs.colors.blue, "‚¨§")
			buffer.draw()
			os.sleep(0.2)
			buffer.clear(0x262626)
			buffer.draw()
			return
		end
	end
end















DMineOS/Desktop/FMineOS/Desktop/Viewer.lnk(return "/MineOS/Applications/Viewer.app"DMineOS/System/DMineOS/System/OS/F!MineOS/System/OS/Applications.txtöæ{
  GitHubUserURL="https://raw.githubusercontent.com/",
  GitHubApplicationListURL="https://raw.githubusercontent.com/IgorTimofeev/OpenComputers/master/Applications.txt",
  ----------------------------------------------------- –í—Å–µ –¥–ª—è –û–° --------------------------------------------------------------------------
  {
    name="OS.lua",
    url="IgorTimofeev/OpenComputers/master/MineOS/OS.lua",
    about="IgorTimofeev/OpenComputers/master/MineOS/About/",
    type="Script",
    forceDownload=true,
    version=3.47,
  },
  {
    name="MineOS/Pictures/Raspberry.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Wallpapers/Raspberry.pic",
    type="Wallpaper",
    version=1.0,
  },
  {
    name="MineOS/Pictures/Nettle.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Wallpapers/Nettle.pic",
    type="Wallpaper",
    version=1.0,
  },
  {
    name="MineOS/Pictures/Catniss.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Wallpapers/Catniss.pic",
    type="Wallpaper",
    version=1.0,
  },
  {
    name="MineOS/Pictures/Nocturnal.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Wallpapers/Nocturnal.pic",
    type="Wallpaper",
    version=1.0,
  },
  {
    name="MineOS/Pictures/Ciri.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Wallpapers/Ciri.pic",
    type="Wallpaper",
    version=1.0,
  },
  {
    name="MineOS/Pictures/AhsokaTanoHiRes.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Wallpapers/AhsokaTanoHiRes.pic",
    type="Wallpaper",
    version=1.0,
  },
  {
    name="MineOS/Pictures/Girl.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Wallpapers/Girl.pic",
    type="Wallpaper",
    version=1.0,
  },
  {
    name="MineOS/Pictures/TemplarAssassin.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Wallpapers/TemplarAssassin.pic",
    type="Wallpaper",
    version=1.0,
  },
  {
    name="MineOS/Pictures/ChristmasTree.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Wallpapers/ChristmasTree.pic",
    type="Wallpaper",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Languages/Russian.lang",
    url="IgorTimofeev/OpenComputers/master/MineOS/Languages/Russian.lang",
    type="Script",
    forceDownload=true,
    version=1.18,
  },
  {
    name="MineOS/System/OS/Languages/English.lang",
    url="IgorTimofeev/OpenComputers/master/MineOS/Languages/English.lang",
    type="Script",
    forceDownload=true,
    version=1.18,
  },

  ----------------------------------------------------- –°–∏—Å—Ç–µ–º–Ω—ã–µ –∏–∫–æ–Ω–∫–∏ --------------------------------------------------------------------------
  {
    name="MineOS/System/OS/Icons/Application.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Application.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Languages.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Languages.pic",
    type="Icon",
    preLoadFile=true,
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/OK.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/OK.pic",
    type="Icon",
    preLoadFile=true,
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Downloading.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Downloading.pic",
    type="Icon",
    preLoadFile=true,
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/OS_Logo.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/OS_Logo.pic",
    type="Icon",
    preLoadFile=true,
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/3DModel.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/3DModel.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Computer.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Computer.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Robot.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Robot.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Tablet.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Tablet.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Pastebin.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Pastebin.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Love.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Love.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/HDD.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/HDD.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Floppy.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Floppy.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Steve.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Steve.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Folder.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Folder.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Finger.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Finger.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/FileNotExists.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/FileNotExists.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Script.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Script.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Text.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Text.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Update.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Update.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Security.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Security.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Config.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Config.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Image.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Image.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Lua.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Lua.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/SampleIcon.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/SampleIcon.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Archive.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Archive.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Trash.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Trash.pic",
    type="Icon",
    version=1.01,
  },

  ----------------------------------------------------- –ë–∏–±–ª–∏–æ—Ç–µ–∫–∏ --------------------------------------------------------------------------

  {
    name="lib/MineOSCore.lua",
    url="IgorTimofeev/OpenComputers/master/lib/MineOSCore.lua",
    type="Library",
    version=1.47,
  },
  {
    name="lib/advancedLua.lua",
    url="IgorTimofeev/OpenComputers/master/lib/advancedLua.lua",
    type="Library",
    preLoadFile=true,
    version=1.06,
  },
  {
    name="MineOS/System/OS/EFI.lua",
    url="IgorTimofeev/OpenComputers/master/MineOS/EFI.lua",
    type="Library",
    forceDownload=true,
    version=1.0,
  },
  {
    name="lib/ECSAPI.lua",
    url="IgorTimofeev/OpenComputers/master/lib/ECSAPI.lua",
    type="Library",
    preLoadFile=true,
    version=1.13,
  },
  {
    name="lib/colorlib.lua",
    url="IgorTimofeev/OpenComputers/master/lib/colorlib.lua",
    type="Library",
    preLoadFile=true,
    version=1.03,
  },
  {
    name="lib/image.lua",
    url="IgorTimofeev/OpenComputers/master/lib/image.lua",
    type="Library",
    preLoadFile=true,
    version=1.23,
  },
  {
    name="lib/serialization.lua",
    url="IgorTimofeev/OpenComputers/master/lib/serialization.lua",
    type="Library",
    version=1.05,
  },
  {
    name="lib/GUI.lua",
    url="IgorTimofeev/OpenComputers/master/lib/GUI.lua",
    type="Library",
    version=1.41,
  },
  {
    name="lib/windows.lua",
    url="IgorTimofeev/OpenComputers/master/lib/windows.lua",
    type="Library",
    version=1.17,
  },
  {
    name="lib/rayEngine.lua",
    url="IgorTimofeev/OpenComputers/master/lib/rayEngine.lua",
    type="Library",
    version=1.38,
  },
  {
    name="lib/json.lua",
    url="IgorTimofeev/OpenComputers/master/lib/json.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/modemConnection.lua",
    url="IgorTimofeev/OpenComputers/master/lib/modemConnection.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/bigLetters.lua",
    url="IgorTimofeev/OpenComputers/master/lib/bigLetters.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/libPNGImage.lua",
    url="IgorTimofeev/OpenComputers/master/lib/libPNGImage.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/crc32lua.lua",
    url="IgorTimofeev/OpenComputers/master/lib/crc32lua.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/deflatelua.lua",
    url="IgorTimofeev/OpenComputers/master/lib/deflatelua.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/context.lua",
    url="IgorTimofeev/OpenComputers/master/lib/context.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/syntax.lua",
    url="IgorTimofeev/OpenComputers/master/lib/syntax.lua",
    type="Library",
    version=1.11,
  },
  {
    name="lib/palette.lua",
    url="IgorTimofeev/OpenComputers/master/lib/palette.lua",
    type="Library",
    version=1.09,
  },
  {
    name="lib/doubleBuffering.lua",
    url="IgorTimofeev/OpenComputers/master/lib/doubleBuffering.lua",
    type="Library",
    version=1.19,
  },
  {
    name="lib/compressor.lua",
    url="IgorTimofeev/OpenComputers/master/lib/compressor.lua",
    type="Library",
    version=1.04,
  },
  {
    name="lib/xmlParser.lua",
    url="IgorTimofeev/OpenComputers/master/lib/xmlParser.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/SHA2.lua",
    url="IgorTimofeev/OpenComputers/master/lib/SHA2.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/vector.lua",
    url="IgorTimofeev/OpenComputers/master/lib/vector.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/matrix.lua",
    url="IgorTimofeev/OpenComputers/master/lib/matrix.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/OpenComputersGL/Main.lua",
    url="IgorTimofeev/OpenComputers/master/lib/OpenComputersGL/Main.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/OpenComputersGL/Materials.lua",
    url="IgorTimofeev/OpenComputers/master/lib/OpenComputersGL/Materials.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/OpenComputersGL/Renderer.lua",
    url="IgorTimofeev/OpenComputers/master/lib/OpenComputersGL/Renderer.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/PolyCatEngine/Main.lua",
    url="IgorTimofeev/OpenComputers/master/lib/PolyCatEngine/Main.lua",
    type="Library",
    version=1.01,
  },
  {
    name="lib/PolyCatEngine/PostProcessing.lua",
    url="IgorTimofeev/OpenComputers/master/lib/PolyCatEngine/PostProcessing.lua",
    type="Library",
    version=1.01,
  },

  ----------------------------------------------------- –°–∫—Ä–∏–ø—Ç—ã –∏ –¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è –∫ –Ω–∏–º --------------------------------------------------------------------------

  {
    name="init.lua",
    url="IgorTimofeev/OpenComputers/master/MineOS/Init.lua",
    type="Script",
    forceDownload=true,
    version=1.13,
  },
  {
    name="etc/profile",
    url="IgorTimofeev/OpenComputers/master/etc/profile",
    type="Script",
    forceDownload=true,
    version=1.0,
  },
  {
    name="bin/clear.lua",
    url="IgorTimofeev/OpenComputers/master/Applications/clear.lua",
    type="Script",
    forceDownload=true,
    version=1.0,
  },
  {
    name="bin/scale.lua",
    url="IgorTimofeev/OpenComputers/master/Applications/scale.lua",
    type="Script",
    forceDownload=true,
    version=1.01,
  },
  {
    name="usr/misc/greetings/English.txt",
    url="IgorTimofeev/OpenComputers/master/Applications/Motd/English.txt",
    type="Script",
    forceDownload=true,
    version=1.03,
  },
  {
    name="usr/misc/greetings/Russian.txt",
    url="IgorTimofeev/OpenComputers/master/Applications/Motd/Russian.txt",
    type="Script",
    forceDownload=true,
    version=1.03,
  },
  {
    name="etc/motd",
    url="IgorTimofeev/OpenComputers/master/Applications/Motd/motd.lua",
    type="Script",
    forceDownload=true,
    version=1.02,
  },
  ----------------------------------------------------- Screensavers --------------------------------------------------------------------------
  {
    name="MineOS/System/OS/Screensavers/Matrix.lua",
    url="IgorTimofeev/OpenComputers/master/MineOS/Screensavers/Matrix.lua",
    type="Script",
    forceDownload=true,
    version=1.00,
  },
  {
    name="MineOS/System/OS/Screensavers/Mandala.lua",
    url="IgorTimofeev/OpenComputers/master/MineOS/Screensavers/Mandala.lua",
    type="Script",
    forceDownload=true,
    version=1.00,
  },
  {
    name="MineOS/System/OS/Screensavers/Clock.lua",
    url="IgorTimofeev/OpenComputers/master/MineOS/Screensavers/Clock.lua",
    type="Script",
    forceDownload=true,
    version=1.00,
  },
  ----------------------------------------------------- –ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è --------------------------------------------------------------------------
  {
    name="MineOS/Applications/MineCode IDE",
    url="IgorTimofeev/OpenComputers/master/Applications/MineCodeIDE/MineCodeIDE.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/MineCodeIDE/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/MineCodeIDE/Icon.pic",
    createShortcut="dock",
    forceDownload=true,
    version=1.51,
    resources={
      {
        name="Localization/Russian.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/MineCodeIDE/Localization/Russian.lang"
      },
      {
        name="Localization/English.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/MineCodeIDE/Localization/English.lang"
      },
    }
  },
  {
    name="MineOS/Applications/OCGLTest",
    url="IgorTimofeev/OpenComputers/master/Applications/OCGLTest/OCGLTest.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/OCGLTest/Icon.pic",
    createShortcut="desktop",
    version=1.02,
  },
  {
    name="MineOS/Applications/GeoScan2",
    url="IgorTimofeev/OpenComputers/master/Applications/GeoScan2/GeoScan2.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/GeoScan2/Icon.pic",
    createShortcut="desktop",
    version=1.02,
    resources={
      {
        name="Earth.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/GeoScan2/Earth.pic",
      }
    },
  },
  {
    name="MineOS/Applications/SmartHouse",
    url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/SmartHouse.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Icon.pic",
    createShortcut="desktop",
    version=1.29,
    resources={
      {
        name="Modules/command_block/Icon.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/command_block/Icon.pic",
      },
      {
        name="Modules/command_block/Main.lua",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/command_block/Main.lua",
      },
      --
      {
        name="Modules/redstone/Icon.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/redstone/Icon.pic",
      },
      {
        name="Modules/redstone/Main.lua",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/redstone/Main.lua",
      },
      --
      {
        name="Modules/mfsu/Icon.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/mfsu/Icon.pic",
      },
      {
        name="Modules/mfsu/Main.lua",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/mfsu/Main.lua",
      },
      --
      {
        name="Modules/screen/Icon.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/screen/Icon.pic",
      },
      {
        name="Modules/screen/Main.lua",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/screen/Main.lua",
      },
      --
      {
        name="Modules/homePC/Server.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/homePC/Server.pic",
      },
      {
        name="Modules/homePC/Icon.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/homePC/Icon.pic",
      },
      {
        name="Modules/homePC/Main.lua",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/homePC/Main.lua",
      },
      --
      {
        name="Modules/motion_sensor/Icon.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/motion_sensor/Icon.pic",
      },
      {
        name="Modules/motion_sensor/Main.lua",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/motion_sensor/Main.lua",
      },
      --
      {
        name="Modules/reactor/Icon.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/reactor/Icon.pic",
      },
      {
        name="Modules/reactor/Main.lua",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/reactor/Main.lua",
      },
    },
  },
  {
    name="MineOS/Applications/VK",
    url="IgorTimofeev/OpenComputers/master/Applications/VK/VK.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/VK/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/VK/Icon.pic",
    createShortcut="dock",
    forceDownload=true,
    version=1.24,
    resources={
      {
        name="VKLogo.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/VK/VKLogo.pic",
      },
    },
  },
  {
    name="MineOS/Applications/Control2",
    url="IgorTimofeev/OpenComputers/master/Applications/Control2/Control2.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Control2/Icon.pic",
    createShortcut="desktop",
    version=1.05,
    resources={
      {
        name="LuaLogo.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Control2/LuaLogo.pic",
      },
      {
        name="Modules/00_LuaConsole.lua",
        url="IgorTimofeev/OpenComputers/master/Applications/Control2/Modules/00_LuaConsole.lua",
      },
    },
  },
  {
    name="MineOS/Applications/Weather",
    url="IgorTimofeev/OpenComputers/master/Applications/Weather/Weather.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Weather/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Weather/Icon.pic",
    createShortcut="desktop",
    version=1.12,
    resources={
      {
        name="Cloudy.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Weather/Cloudy.pic",
      },
      {
        name="Cloudy.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Weather/Cloudy.pic",
      },
      {
        name="Rainy.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Weather/Rainy.pic",
      },
      {
        name="Snowy.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Weather/Snowy.pic",
      },
      {
        name="Stormy.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Weather/Stormy.pic",
      },
      {
        name="Sunny.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Weather/Sunny.pic",
      },
      {
        name="SunnyWithClouds.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Weather/SunnyWithClouds.pic",
      },
    },
  },
  {
    name="MineOS/Applications/3DPrint",
    url="IgorTimofeev/OpenComputers/master/Applications/3DPrint/3DPrint.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/3DPrint/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/3DPrint/Icon.pic",
    createShortcut="desktop",
    version=1.11,
  },
  {
    name="MineOS/Applications/FlappyBird",
    url="IgorTimofeev/OpenComputers/master/Applications/FlappyBird/FlappyBird.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/FlappyBird/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/FlappyBird/Icon.pic",
    createShortcut="desktop",
    version=1.11,
    resources={
      {
        name="Flappy.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/FlappyBird/Flappy.pic",
      },
    },
  },
  {
    name="MineOS/Applications/RayWalk",
    url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/RayWalk.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/RayWalk/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Icon.pic",
    createShortcut="desktop",
    version=1.60,
    resources={
      {
        name="Localization/Russian.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Localization/Russian.lang"
      },
      {
        name="Localization/English.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Localization/English.lang"
      },
------------
      {
        name="RayEngine.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/RayEngine.cfg",
      },
------------
      {
        name="Weapons/Weapons.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/Weapons.cfg",
      },
------------
      {
        name="Weapons/CrosshairTextures/Angled.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/CrosshairTextures/Angled.pic",
      },
      {
        name="Weapons/CrosshairTextures/Default.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/CrosshairTextures/Default.pic",
      },
      {
        name="Weapons/CrosshairTextures/Half.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/CrosshairTextures/Half.pic",
      },
      {
        name="Weapons/CrosshairTextures/Dotted.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/CrosshairTextures/Dotted.pic",
      },
------------
      {
        name="Weapons/FireTextures/PowderFire.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/FireTextures/PowderFire.pic",
      },
      {
        name="Weapons/FireTextures/Plasma.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/FireTextures/Plasma.pic",
      },
------------
      {
        name="Weapons/WeaponTextures/Pistol.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/WeaponTextures/Pistol.pic",
      },
      {
        name="Weapons/WeaponTextures/Sniper.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/WeaponTextures/Sniper.pic",
      },
      {
        name="Weapons/WeaponTextures/Rifle.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/WeaponTextures/Rifle.pic",
      },
      {
        name="Weapons/WeaponTextures/Plasmer.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/WeaponTextures/Plasmer.pic",
      },
------------
      {
        name="Worlds/ExampleWorld/Map.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Worlds/ExampleWorld/Map.cfg",
      },
      {
        name="Worlds/ExampleWorld/Player.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Worlds/ExampleWorld/Player.cfg",
      },
      {
        name="Worlds/ExampleWorld/World.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Worlds/ExampleWorld/World.cfg",
      },
      {
        name="Worlds/ExampleWorld/Blocks.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Worlds/ExampleWorld/Blocks.cfg",
      },
------------
      {
        name="Worlds/SundownBeams/Map.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Worlds/SundownBeams/Map.cfg",
      },
      {
        name="Worlds/SundownBeams/Player.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Worlds/SundownBeams/Player.cfg",
      },
      {
        name="Worlds/SundownBeams/World.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Worlds/SundownBeams/World.cfg",
      },
      {
        name="Worlds/SundownBeams/Blocks.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Worlds/SundownBeams/Blocks.cfg",
      },
    },
  },
  {
    name="MineOS/Applications/GuessWord",
    url="IgorTimofeev/OpenComputers/master/Applications/GuessWord/GuessWord.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/GuessWord/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/GuessWord/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/Calendar",
    url="IgorTimofeev/OpenComputers/master/Applications/Calendar/Calendar.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Calendar/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Calendar/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/PrintImage",
    url="IgorTimofeev/OpenComputers/master/Applications/PrintImage/PrintImage.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/PrintImage/Icon.pic",
    createShortcut="desktop",
    version=1.05,
  },
  {
    name="MineOS/Applications/Palette",
    url="IgorTimofeev/OpenComputers/master/Applications/Palette/Palette.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Palette/Icon.pic",
    createShortcut="desktop",
    version=1.02,
  },
  {
    name="MineOS/Applications/Stargate",
    url="IgorTimofeev/OpenComputers/master/Applications/Stargate/Stargate.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Stargate/Icon.pic",
    createShortcut="desktop",
    version=1.03,
    resources={
      {
        name="Gate.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Stargate/Gate.pic",
      },
      {
        name="GateCore.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Stargate/GateCore.pic",
      },
    },
  },
  {
    name="MineOS/Applications/RunningString",
    url="IgorTimofeev/OpenComputers/master/Applications/RunningString/RunningString.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/RunningString/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/RunningString/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/Graph",
    url="IgorTimofeev/OpenComputers/master/Applications/Graph/Graph.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Graph/Icon.pic",
    createShortcut="desktop",
    version=1.02,
  },
  {
    name="MineOS/Applications/Battleship",
    url="IgorTimofeev/OpenComputers/master/Applications/Battleship/Battleship.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Battleship/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Battleship/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/Radio",
    url="IgorTimofeev/OpenComputers/master/Applications/Radio/Radio.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Radio/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Radio/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/FuckTheRain",
    url="IgorTimofeev/OpenComputers/master/Applications/FuckTheRain/FuckTheRain.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/FuckTheRain/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/FuckTheRain/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/ForceAdmin",
    url="IgorTimofeev/OpenComputers/master/Applications/ForceAdmin/ForceAdmin.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/ForceAdmin/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/ForceAdmin/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/MineSweeper",
    url="IgorTimofeev/OpenComputers/master/Applications/MineSweeper/MineSweeper.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/MineSweeper/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/MineSweeper/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/DanceFloor",
    url="IgorTimofeev/OpenComputers/master/Applications/DanceFloor/DanceFloor.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/DanceFloor/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/DanceFloor/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/QuantumCube",
    url="IgorTimofeev/OpenComputers/master/Applications/QuantumCube/QuantumCube.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/QuantumCube/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/QuantumCube/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/Photoshop",
    url="IgorTimofeev/OpenComputers/master/Applications/Photoshop/Photoshop.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Photoshop/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Photoshop/Icon.pic",
    createShortcut="dock",
    forceDownload=true,
    version=1.03,
    resources={
      {
        name="Localization/Russian.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/Photoshop/Localization/Russian.lang"
      },
      {
        name="Localization/English.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/Photoshop/Localization/English.lang"
      },
    }
  },
  {
    name="MineOS/Applications/Shooting",
    url="IgorTimofeev/OpenComputers/master/Applications/Shooting/Shooting.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Shooting/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/HoloClock",
    url="IgorTimofeev/OpenComputers/master/Applications/HoloClock/HoloClock.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/HoloClock/Icon.pic",
    createShortcut="desktop",
    version=1.02,
  },
  -- {
  --   name="MineOS/Applications/Finder",
  --   url="IgorTimofeev/OpenComputers/master/Applications/Finder/Finder.lua",
  --   about="IgorTimofeev/OpenComputers/master/Applications/Finder/About/",
  --   type="Application",
  --   icon="IgorTimofeev/OpenComputers/master/Applications/Finder/Icon.pic",
  --   createShortcut="dock",
  --   forceDownload=true,
  --   version=1.12,
  -- },
  {
    name="MineOS/Applications/AppMarket",
    url="IgorTimofeev/OpenComputers/master/Applications/AppMarket/AppMarket.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/AppMarket/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/AppMarket/Icon.pic",
    createShortcut="dock",
    forceDownload=true,
    version=1.54,
     resources={
      {
        name="Localization/Russian.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/AppMarket/Localization/Russian.lang",
      },
      {
        name="Localization/English.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/AppMarket/Localization/English.lang",
      },
    },
  },
  {
    name="MineOS/Applications/Control",
    url="IgorTimofeev/OpenComputers/master/Applications/Control/Control.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Control/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Control/Icon.pic",
    createShortcut="desktop",
    version=1.01,
  },
  {
    name="MineOS/Applications/Piano",
    url="IgorTimofeev/OpenComputers/master/Applications/Piano/Piano.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Piano/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/CodeDoor",
    url="IgorTimofeev/OpenComputers/master/Applications/CodeDoor/CodeDoor.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/CodeDoor/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/CodeDoor/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/Keyboard",
    url="IgorTimofeev/OpenComputers/master/Applications/Keyboard/Keyboard.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Keyboard/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Keyboard/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/Nano",
    url="IgorTimofeev/OpenComputers/master/Applications/Nano/Nano.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Nano/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Nano/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/Camera",
    url="IgorTimofeev/OpenComputers/master/Applications/Camera/Camera.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Camera/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Camera/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/Autorun",
    url="IgorTimofeev/OpenComputers/master/Applications/Autorun/Autorun.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Autorun/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Autorun/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/HEX",
    url="IgorTimofeev/OpenComputers/master/Applications/HEX/HEX.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/HEX/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/HEX/Icon.pic",
    createShortcut="desktop",
    version=1.02,
  },
  {
    name="MineOS/Applications/ChristmasTree",
    url="IgorTimofeev/OpenComputers/master/Applications/ChristmasTree/ChristmasTree.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/ChristmasTree/About/",
    type="Application",
    createShortcut="desktop",
    icon="IgorTimofeev/OpenComputers/master/Applications/ChristmasTree/Icon.pic",
    version=1.0,
  },
  -- –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ InfoPanel
  {
    name="MineOS/Applications/InfoPanel",
    url="IgorTimofeev/OpenComputers/master/Applications/InfoPanel/InfoPanel.lua",
    type="Application",
    about="IgorTimofeev/OpenComputers/master/Applications/InfoPanel/About/",
    icon="IgorTimofeev/OpenComputers/master/Applications/InfoPanel/Icon.pic",
    createShortcut="desktop",
    version=1.01,
    resources = {
      {
        name="Pages/Rules.txt",
        url="IgorTimofeev/OpenComputers/master/Applications/InfoPanel/Rules.txt",
      },
      {
        name="Pages/Main.txt",
        url="IgorTimofeev/OpenComputers/master/Applications/InfoPanel/Main.txt",
      },
      {
        name="Pages/SSPI.txt",
        url="IgorTimofeev/OpenComputers/master/Applications/InfoPanel/SSPI.txt",
      },
      {
        name="Pages/Claims.txt",
        url="IgorTimofeev/OpenComputers/master/Applications/InfoPanel/Claims.txt",
      },
    }
  },
  --–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –ß–∞—Ç
  {
    name="MineOS/Applications/Chat",
    url="IgorTimofeev/OpenComputers/master/Applications/Chat/Chat.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Chat/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Chat/Icon.pic",
    createShortcut="desktop",
    version=1.01,
    resources = {
      {
        name="Avatars/MyAvatar.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Chat/MyAvatar.pic",
      }
    },
  },
  {
    name="MineOS/Applications/TurretControl",
    url="IgorTimofeev/OpenComputers/master/Applications/TurretControl/TurretControl.lua",
    type="Application",
    about="IgorTimofeev/OpenComputers/master/Applications/TurretControl/About/",
    icon="IgorTimofeev/OpenComputers/master/Applications/TurretControl/Icon.pic",
    createShortcut="desktop",
    version=1.0,
    resources={
      {
        name="Turret.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/TurretControl/Turret.pic",
      },
    },
  },
  {
    name="MineOS/Applications/HoloEdit",
    url="IgorTimofeev/OpenComputers/master/Applications/HoloEdit/HoloEdit.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/HoloEdit/Icon.pic",
    createShortcut="desktop",
    version=1.02,
    resources={
      {
        name="Localization/Russian.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/HoloEdit/Localization/Russian.lang",
      },
      {
        name="Localization/English.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/HoloEdit/Localization/English.lang",
      },
    },
  },
  {
    name="MineOS/Applications/BufferDemo",
    url="IgorTimofeev/OpenComputers/master/Applications/BufferDemo/BufferDemo.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/BufferDemo/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/BufferDemo/Icon.pic",
    createShortcut="desktop",
    version=1.0,
    resources={
      {
        name="Wallpaper.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/BufferDemo/Wallpaper.pic",
      },
    },
  },
  {
    name="MineOS/Applications/Viewer",
    url="IgorTimofeev/OpenComputers/master/Applications/Viewer/Viewer.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Viewer/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Viewer/Icon.pic",
    createShortcut="desktop",
    forceDownload=true,
    version=1.01,
    resources={
      {
        name="arrowLeft.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Viewer/arrowLeft.pic",
      },
      {
        name="arrowRight.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Viewer/arrowRight.pic",
      },
      {
        name="play.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Viewer/play.pic",
      },
    },
  },
}
FMineOS/System/OS/EFI.luawlocal ee,gpu,sc,bg,fg,re,sce
local pr,cm,ls,ps=component.proxy,computer,component.list,computer.pullSignal

local function init()
	local g=ls("gpu")()
	local s=ls("screen")()
	local e=ls("eeprom")()

	if g and s and e then
		gpu,sc,ee=pr(g),pr(s),pr(e)
		computer.getBootAddress=function() return ee.getData() end
		computer.setBootAddress=function(address) return ee.setData(address) end
		gpu.bind(sc.address)
		re={};re.width,re.height=gpu.maxResolution()
		gpu.setResolution(re.width,re.height)
		sce=math.floor(re.height/2)
	else
		error("")
	end
end

local function pu(t) while true do local e={ps()};if e[1]==t then return e end end end

local function sleep(timeout)
	local deadline=cm.uptime() + (timeout or 0)
	while cm.uptime()<deadline do ps(deadline - cm.uptime()) end
end

local function bGP()
	gpu.bind(sc.address)
	re={}
	re.width,re.height=gpu.maxResolution()
	gpu.setResolution(re.width,re.height)
end

local colors={b=0xDDDDDD,t1=0x444444,t2=0x999999,t3=0x888888}

local function sB(color) if color~=bg then bg=color;gpu.setBackground(color) end end
local function sF(color) if color~=fg then fg=color;gpu.setForeground(color) end end
local function clear() gpu.fill(1,1,re.width,re.height," ") end
local function cT(y,color,text) sF(color);gpu.set(math.floor(re.width/2-#text/2),y,text) end
local function l() sB(colors.b);clear();cT(sce-1,colors.t1,"MineOS EFI") end

local function fade(fromColor,toColor,step)
	for color=fromColor,toColor,step do
		sB(color)
		clear()
		sleep(0.05)
	end
	sB(toColor)
	clear()
end

local function bt(fs)
	cT(sce,colors.t2,"Booting from " .. fs.address)
	ee.setData(fs.address)
	local openS,fileOrR=pcall(fs.open,"/init.lua","r")
	if openS then
		local data,rData="",""
		while rData do data=data..rData;rData=fs.read(fileOrR,math.huge) end
		fs.close(fileOrR)
		
		local loadS,loadR=load(data)
		if loadS then
			local xpS,xpR=xpcall(loadS,debug.traceback)
			if not xpS then error(xpR) end
		else
			error(loadR)
		end
	else
		error("init.lua not found")
	end
end

local function cbf(f) return f.exists("/init.lua") or f.exists("/MineOS/EFI.lua") end

local function gB()
	local dr={}
	for address in ls("filesystem") do local fs=pr(address);if cbf(fs) then table.insert(dr,fs) end end
	return dr
end

local function menu(t,v)
	local y,sv,b,f=math.floor(sce-#v/2-1),1
	while true do
		sB(colors.b)
		clear()
		cT(y,colors.t1,t)
		for i=1,#v do
			b,f=colors.b,colors.t3
			if i==sv then b,f=colors.t3,colors.b end
			sB(b)
			cT(y+i+1,f,"   "..v[i].."   ")
		end
		local e=pu("key_down")
		if e[4]==200 then
			sv=sv>1 and sv-1 or 1
		elseif e[4]==208 then
			sv=sv<#v and sv+1 or #v
		elseif e[4]==28 then
			return sv
 		end
	end
end

local function waitForAlt(t,dr)
	local dl=cm.uptime()+t
	while cm.uptime()<dl do
		local e={ps(dl-cm.uptime())}
		if e[1]=="key_down" and e[4]==56 then
			while true do
				local v={};for i=1,#dr do v[i]=dr[i].getLabel().." "..(dr[i].spaceTotal()>524288 and "HDD" or "FDD").." ("..dr[i].address..")" end; table.insert(v, "Back")
				local d=menu("Choose drive",v);
				if d==#v then break end
				v={"Set as bootable"};if not dr[d].isReadOnly() then v[2]="Format" end; table.insert(v, "Back")
				local a=menu("Drive \""..dr[d].address.."\"",v)
				if a==1 then
					l();bt(dr[d]);return
				elseif a==2 and #v==3 then
					for _,file in pairs(dr[d].list("/")) do dr[d].remove("/"..file) end;cm.shutdown(true)
				end
			end
		end
	end
	
	local fs=pr(ee.getData() or "")
	l();bt((fs and cbf(fs)) and fs or dr[1])
end

init()
bGP()
fade(0x0,colors.b,0x202020)
l()
cT(sce,colors.t2,"Initialising system")
local dr=gB()
if #dr>0 then cT(re.height - 1,colors.t2,"Hold Alt to enter boot options menu");waitForAlt(1.2,dr) else cT(sce,colors.t2,"Bootable drives not found");pu("key_down");fade(colors.b,0x0,-0x202020);cm.shutdown() end
DMineOS/System/OS/Icons/F"MineOS/System/OS/Icons/3DModel.picÙOCIFAˇS F◊B  YYYYF)B  YF B  YA	 SmF)B ’YS‚îêF◊B SYS F◊B ◊YB SYYYB ’YF)B ’YS‚îåF◊B SYS.F)B ’YSdF)B ’YS3F)B ’YS‚îîF◊B SYS‚îòF◊B SYF&MineOS/System/OS/Icons/Application.picúOCIFAˇS F B  YYYYA SaF*B ◊YS F B ◊YS.F*B ◊YSpF*B ◊YS‚ñÑFÚB „YFãB >YFzB ¸YF"MineOS/System/OS/Icons/Archive.picOCIFAˇS‚ñôF◊B  YF÷B  YS FˇB  YYF÷B  YYF B  YF◊B  YYFSB  YA S‚ïëFSB ◊YB ÷YB ¨YScFˇB SYSaFˇB SYSpFˇB SYSkFˇB SYS F B ◊YFˇB ¨YB ’YB SYFSB ◊YB ÷YB ¨YF◊B ÷YF#MineOS/System/OS/Icons/Computer.pic®OCIFA S F B  YYB *YS‚ñÑF’B  YS‚ñÄF B *YAˇS‚ñôF¨B  YS F’B  YF¨B  YS‚ñüF¨B  YS‚ñÑF¨B  YF!MineOS/System/OS/Icons/Config.pic∞OCIFAˇS F B  YYF◊B  YYYYA S-F◊B SYYYScF B ◊YSfF B ◊YS F◊B ◊YF B ◊YSgF B ◊YS.F B ◊YF&MineOS/System/OS/Icons/Downloading.pic OCIF@AˇS F B  Y 	
 Y 	
 Y 	
 Y	
 Y	
 Y	
 Y
 Y Y
	 Y
	
 Y	
 Y	
 Y 	
 Y 	
 Y 	
 Y 	
 A S F B AY#$'(34=>Y#$'(34=>Y#$'()*+,-./0123456789:;<=>Y#$Y#$'()*3456789:;<=>Y#$34Y#$'()*3456789:;<=>Y	#$34Y
#$'()*3456789:;<=>Y#$34Y#$'()*3456789:;<=>Y#$34Y#$'()*3456789:;<=>Y#$34B ;Y789:B Y !"#$%&'()*+,-./0123456789:;<=>?@Y!"%&)*1256;<?@Y!"%&)*+,-./01256789:;<?@Y!"%&?@Y!"%&'()*+,-./0123456789:;<=>?@Y
!"%&+,12?@Y!"%&'()*+,1256789:;<=>?@Y
!"%&+,12?@Y	!"%&'()*+,1256789:;<=>?@Y

!"%&+,12?@Y!"%&'()*+,1256789:;<=>?@Y
!"%&+,12?@Y!"%&'()*+,1256789:;<=>?@Y
!"%&+,12?@Y!"%&'()*+,1256789:;<=>?@Y !"#$%&'()*+,-./0123456789:;<=>?@B PY+,-./0B 
)Y-./0Y-./0Y-./0Y	-./0Y
-./0Y-./0Y-./0Y-./0Y-./0Y-./0B 	YYYY	
Y	
Y
Y		
YYF(MineOS/System/OS/Icons/FileNotExists.pic∆OCIFA
 SlFÇB ˇYS F B ˇYFÇB ˇYYYSoFÇB ˇYSnFÇB ˇYSeFÇB ˇYYStFÇB ˇYYSsFÇB ˇYSiFÇB ˇYYSxFÇB ˇYSFFÇB ˇYF!MineOS/System/OS/Icons/Finger.pic«OCIFAˇS F B  Y	Y
Y	
YY	
Y	
Y	Y
Y	Y
	Y	
Y	
Y
YA S F B  Y
Y	Y	Y	
YYY	
Y
	Y		
Y	

YY
Y		Y	
F!MineOS/System/OS/Icons/Floppy.picôOCIFA S-F´B ˇYYS F™B ßYYF´B ßYYF B ßYYB ™YS‚ñÄF™B ßYS*F B ™YAˇS F B  YF!MineOS/System/OS/Icons/Folder.picpOCIFA S F B ˛YF˛B ¯YB ˝YB ÛYAˇS F˛B  YS‚ñôF˛B  YFMineOS/System/OS/Icons/HDD.picOCIFAˇS F B  YYYYA S*F¶B ¨YF¸B ¨YS‚îÄF B ÷YB ’YS‚îêF B ÷YS‚îîF B ’YS‚îòF B ’YS F B ◊YB ÷YB ’YB ¨YF¸B ¨YS‚îåF B ÷YS‚óèF B ◊YB ¨YF MineOS/System/OS/Icons/Image.picOCIFAˇS F B  YYYYA ScF B ◊YSiF B ◊YSpF B ◊YS F B ˛YB ©YB ZYB ‘YB ÿYB ˚YB "YB ÏYB ÙYB ¯YB ßYB ÈYB ˝YB ◊YB ïYB ÚYB NYB  YB ”YS.F B ◊YF$MineOS/System/OS/Icons/Languages.pic0OCIF<ADˇSmFTB  Y3SŸÑFTB  YSkFSB  Y4S—åF~B  Y
SpF B  Y4SoF B  YYYSnF B  Y	YY3FÄB  YFTB  Y/SeF B  Y9Y
YY27<Y
FÄB  YFSB  Y26FTB  Y59;S–∏F~B  YF B  Y7Y2Y	
ScF B  Y7FÄB  YSœÑFÄB  Y7Y3SiF B  Y6YFÄB  Y	YFSB  Y/58FTB  Y.7ShF B  Y0:Y8YYSgF B  Y
YFÄB  YYFTB  Y08SŒ±FÄB  Y<Y	:SœÄFÄB  Y2SaF B  YY6YFÄB  YYFSB  Y-FTB  Y2SŒ≠FÄB  Y5SSF B  Y5Y3FÄB  YSWF B  Y.SVFSB  Y,SLFTB  Y-S√§F B  Y/S—ÖF B  Y3SCF B  YYSIF B  Y9S–µF~B  YF B  Y	SÿßFTB  YSŒµFÄB  Y8S–∞F B  Y8Y3Sÿ™FTB  Y
S–æF~B  YF B  Y4Y5<S–∫F B  Y
SÿÆFTB  YSŒæFÄB  Y6SœÇFÄB  Y	;S—ÇF~B  Y	F B  Y	Y1Sÿ∫FTB  Y	S–≤F~B  YS FTB  Y4<Y&	
*+,-./0123456789:;<Y,-FSB  Y39:;<Y4	
"#$%&'()*+,-./0123456789:;<F B  Y2	
 $%&'()*+,-./0123456789:;<YY48Y	
-./012:;<Y./0123456789:;<Y/0Y	/02345678Y
/013456789:;<Y	
./0123456789:;<Y69:;<Y	
8Y%	
*+,-./0123456789:;<Y
()*+FÄB  Y
	Y
-.Y9:;<Y	<Y,-./01Y	
/0126F~B  Y()*+,S—ñF~B  YS—ãF B  Y	Y
SŸÉFTB  YSŒªFÄB  Y4Y8Sÿ±FTB  YS—èF B  Y

SŒ∑FÄB  Y4S—ÉF~B  YF B  Y:S—àF B  Y9SŒ≥FÄB  Y7SœéFÄB  Y9S–ºF~B  YF B  Y;S–ΩF B  Y0Y6S—ÄF~B  YF B  Y		S–òF B  Y/SzF B  YS–∑F B  Y
Y2SŒΩFÄB  Y5SœÉFÄB  Y:;Y	9S–±F~B  YF B  Y4Y57Y	SuF B  YYFÄB  YFTB  Y1StF B  YFSB  Y0FTB  Y:SsF B  Y	Y	FSB  Y1SrF B  Y;Y5YSŒπFÄB  Y3S–íF~B  YF B  Y	SlF B  YYY1FÄB  YYFSB  Y.7FTB  Y6SvF B  YA SŒïFÄB ˇY1S FTB sY"#B <Y"&B =Y$%Y(B ûY!)Y$B ÕYYB ’YB üYB £YYB ´Y B ŒYYB 7Y*B úYYB Y)B §YB rY B ¨Y+B ◊YB hYB mY&'Y!#'B ùYYB gY(Y%FSB ˇYB œY B ◊YB ‘Y!B ÷YF5 B Y$Y"Y$%YB 5Y
 "#$&B =Y'YYY	YY'Y"#$Y
B ‘YY)B Y
%B Y)Y#Y'+Y	),Y*+Y
*B Y&Y'+Y&Y	(*+YY$%Y
,B ÷YB ◊Y.YYY'B ôY	YB mY Y,Y "Y	YY%Y
B ˘YB 7Y!(Y!"Y#,Y	&Y)Y#YY
B ~Y	%B ùYB ûYYYYB Y	"B üYY	.B ˛YB 8Y	Y
B AYB ˇY
2Y	1YB BYY	YY!B £YB 1Y#$%Y)*B §YYY	Y-Y&B CYY
-B ÄY B <YYB sY(B ’Y"#Y
YYB 
Y
!Y!B Y+Y&Y&Y	'-YY
B 6Y
'()Y "#$%B TY&B UY(B Y
B ™YB kY	 !B ´YB fY
Y'YB ¨Y,B nY	B lY-Y	#$Y B gY!"YY B ÕYB ŒYB hY!YYY	B œY!Y-Y
.B  Y()*Y
+B Y,B (Y*Y%(B rYYFÄB Y)YB ◊YB YY'(B =YYY$B BY*B Y)B ûYB ˇY
YB ™Y!B Y+B hYYB <YB lYB nYB üYB rY"YB UY%&Y$B §Y.Y,B Y-B SY"B ÄY B ~Y!Y"#B ÅY B 2Y+B TY$'Y%B YY(*Y&,B œY+B 6Y#B ôYY B 7Y	&YY%'()*B mY!#F
~B ’YB ŒYB ÷YB œY "%B ◊Y'B §Y!B ¨Y&B ˇYB ûY$B üY#FMineOS/System/OS/Icons/Love.picGOCIF*AˇS F B  Y
#$%&'()*Y
#$%&'()*Y
#$%&'()*Y
#$%&'()*Y
#$%&'()*Y
#$%&'()*Y
#$%&'()*Y()*Y	*Y
YY*Y)*Y()*Y&'()*Y	$%&'()*Y(	
"#$%&'()*A S F B „Y
YYY	YYYB ÇY
()Y(Y$%Y	#$%&'Y)Y&'Y"#Y !B PYB ;YB ÿY	 !"#$Y Y
 !"#$%&Y !"YB AY	
 Y	
 Y	
 YY	
 YY	
 Y	Y
	
YY		
YY	
YB 
VY#$%&'Y	"()Y
 !"*Y*Y)Y(Y&'Y$%Y"#Y !B ÈY
Y	YYB 
)YYYY	Y
YYYYYB Y 	
 !"Y!"Y!"Y!"Y	
 !"Y
!"Y	
 !"Y
!"Y		
 !Y
Y	
YY	
YY	
Y	
B 	≠YY	Y
#$%&'Y'(Y%&'Y#$%Y!"#Y !YFMineOS/System/OS/Icons/Lua.pic,OCIFAˇS F B  YYYYA SrF¯B )YF˝B )YSpF˝B )YSaF B ◊YSfF¯B )YSuF B ◊YStF˝B )YSeF¯B )YS F B )YYYB ◊YS.F B ◊YSdF¯B )YSiF˝B )YYSnF˝B )YF¯B )YSoF¯B )YSlF B ◊YS=F˝B )YFMineOS/System/OS/Icons/OK.pic}OCIF AˇS F B  Y 	
 Y	
 Y	
 Y	
 Y	
 Y	
 Y	
 Y
 Y	 Y
	 Y	
 Y	
 Y	
 Y	
 Y	
 Y 	
 A S F B $YYYYYY	Y
	Y		
Y


Y	YYYYF"MineOS/System/OS/Icons/OS_Logo.picîOCIFAˇS‚ñÑFpB  YFkB  YY
YYFfB  YYF;B  Y	YYF@B  YS F B  Y	
YYYYYY	
B aY	YYS‚ñÄFaB  YB SYF0B *YYYYB )YB 1YB [YA S F B *Y
YYY	YYYB kYYYYYYB ;YYB 0Y
YYY	YB )YYYB aYYYYYYS‚ñÑFqB kY	YF:B fY
B *YF;B ~YYB kYYY	YB fYYB @YB 6YYB 5Y
B lYF\B *Y
YB aY
B 5YB `YYB 0YFAB kYFfB aY	B UYB lYB \Y

Y	B @YYFlB @YYB kYYYYY
B ;Y
F+B *YFpB lYF*B fYB [YYYB 5YY	B kYB `Y
YB ;YYYB 0Y
YYY	YYYB aYYB \Y	B 6Y	B )Y	B SYY	
YYB (Y	FUB @YFTB aYB 5YFB ~YB *YF[B *Y
Y	YB SY
	Y
YB 1YB `YB 0YY		YB aYFSB [Y
Y	YYB *YYB `YYYB ;YYYB 5YYYB \Y
YB 0Y
YY	YYYB aY
Y
YY
F@B ~YB kYYB fYB UYB TY	FaB TY	B `YYB fYB SY	B \YYB *Y
YYB 0YYYY
B )Y	F`B aY
Y
Y
Y	YB SYY	Y	B \YF0B *Y
YYYYYB +YB `Y
YB SY
YYB \Y	B 6Y	B )YYY	YYB aY
YYFçB `YB 0YF5B 6YYB )YB *YYF6B fYB ;YB kYB )YFkB ~YY
YB fYY	B ;YY	YYB UYYB lYYYYYB @Y
YYYF~B ;YB kYYB @YF)B 
YB [Y	YB :YB ;YYYB 5YB 6YB 0Y
YY	YYB *YYY	YYYYF#MineOS/System/OS/Icons/Pastebin.pic!OCIFA SmF B *YSrF B *YSuF B *YSpF B *YSaFˇB *YSPFˇB *YSoF B *YSnFˇB *YSeFˇB *YF B *YStFˇB *YF B *YSsFˇB *YSbFˇB *YSiFˇB *YSCF B *YS‚á©F{B *YYS FˇB *YF{B *YYF MineOS/System/OS/Icons/Robot.pic‰OCIFAˇS F B  YF)B  YFSB  YF*B  YS‚ñÄF)B  YS‚ñÑFSB  YF*B  YYA S‚ñÇF*B  YS F)B )YS‚ñÑF B SYF*B VYB +YB SYB  YB ﬁYB ≠YB ÇYF%MineOS/System/OS/Icons/SampleIcon.picÚOCIFA SmF B ˇYSlF B ˇYSaF B ˇYFˇB iYSpF B ˇYFˇB iYSoF B ˇYSnF B ˇYSeF B ˇYSSF B ˇYSIF B ˇYS.FˇB iYScF B ˇYS F B ˇYYYB iYFˇB iYF!MineOS/System/OS/Icons/Script.piceOCIFA S F B  YFˇB  YYYYS_FˇB  YS>F˚B  YF#MineOS/System/OS/Icons/Security.pic∂OCIF AˇS F B  Y	
 Y	
Y
	
 Y Y Y Y Y Y	 Y

 Y Y Y	 Y	
 Y	
 Y	
 A S F B YYYYYYY	Y
YYYB 
nYYYY	
YYYYY	Y
B  YYYY	Y
YY
B ÷YYYYYY	B 7YYYYYYY
Y		
Y			
Y
	
Y	
Y	
Y
B YYYYYYY	Y
YYYYYB 	=YYYY	
YYYY	Y
B ¨YYYY	YYYY
B 
8YYYY	
Y	YY	Y
YYB ÅY
YYB Y YYYYYYY	Y
YYYYYYF MineOS/System/OS/Icons/Steve.pic÷OCIFA S F B √Y	
Y	
Y	
YYYB ˇYB aY	
B çY	
B 0Y	
Y	
YYY	
B 8YF!MineOS/System/OS/Icons/Tablet.pic(OCIFAˇS‚ñõF0B  YS‚ñôFëB  YS‚ñüFëB  YS‚ñúF0B  YA S‚ñÄF1B 0YS F8B 1YF¿B 1YF{B `YB 1YB 0YF˝B 1YFëB `YFÈB 1YFB 1YB 0YS‚ñóF8B 1YF¿B 1YF{B 1YF˝B 1YFÈB 1YFB 1YS‚ñÑFbB ëYFMineOS/System/OS/Icons/Text.pic∞OCIFAˇS F B  YYFˇB  YYYYA SeF B ◊YSTF B ◊YStF B ◊YS FˇB ◊YF B ◊YSxF B ◊YS-FˇB ¯YYYF MineOS/System/OS/Icons/Trash.pic¡OCIFAˇS‚ñêF◊B  YF’B  YS‚ñúF¨B  YS‚ñõF¨B  YS‚ñíF◊B  YF¨B  YF’B  YS‚ñåF◊B  YF’B  YS F B  YYA S‚ñÑFSB ´YF!MineOS/System/OS/Icons/Update.picóOCIF AˇS F B  Y	
 Y Y Y Y
 Y
 YYY	Y

Y Y
 Y
 Y Y Y	
 A S F B Y	
 Y		
 Y	
 Y
	 B §YY	
B CY	
Y	
B sY	
Y	
B Y	
Y	
YB Y	
Y	
Y	
DMineOS/System/OS/Installer/F(MineOS/System/OS/Installer/Language.langk{
	beginOsInstall = "–ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —É—Å—Ç–∞–Ω–æ–≤–∫—É –û–°, –Ω–∞–∂–º–∏—Ç–µ –¥–∞–ª–µ–µ",
	acceptLicense = "–ü—Ä–∏–Ω–∏–º–∞—é",
	osInstallation = "–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –û–°",
	downloading = "–ó–∞–≥—Ä—É–∑–∫–∞",
	needToRestart = "–°–∏—Å—Ç–µ–º–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞, –Ω–µ–æ–±—Ö–æ–¥–∏–º–∞ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞",
	restart = "–ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å",
}
DMineOS/System/OS/Languages/F'MineOS/System/OS/Languages/English.lang9{
	pressAnyKeyToContinue = "Press any key to continue",
	screensaver = "Screensaver",
	screensaverDelay = "Delay",
	screensaverDisabled = "Disabled",

	areYouSure = "Are you sure?",
	emptyTrash = "Empty trash"
	type = "Type",
	size = "Size",
	date = "Date",
	path = "Path",
	folder = "Folder",
	unknown = "Unknown",
	calculatingSize = "calculating‚Ä¶",
	contextMenuProperties = "Properties",
	contextMenuNewFile = "New file",
	contextMenuNewFolder = "New folder",
	contextMenuNewApplication = "New MineOS application",
	contextMenuPaste = "Paste",
	contextMenuCopy = "Copy",
	contextMenuCut = "Cut",
	contextMenuRemoveWallpaper = "Remove wallpaper",
	contextMenuEdit = "Edit",
	contextMenuEditInPhotoshop = "Edit in Photoshop",
	contextMenuRename = "Rename",
	contextMenuCreateShortcut = "Create shortcut",
	contextMenuUploadToPastebin = "Upload to Pastebin",
	contextMenuAddToDock = "Add to Dock",
	contextMenuRemoveFromDock = "Remove from Dock",
	contextMenuMoveRight = "Move right",
	contextMenuMoveLeft = "Move left",
	contextMenuArchive = "Compress",
	contextMenuDelete = "Delete",
	contextMenuAddToFavourites = "Add to favourites",
	contextMenuCreateApplication = "Create MineOS application",
	contextMenuSetAsWallpaper = "Set as wallpaper",
	contextMenuShowPackageContent = "Show package content",
	contextMenuShowContainingFolder = "Show containing folder",
	contextMenuRemoveFromFavourites = "Remove from favourites",
	contextMenuFlashEEPROM = "Write file to EEPROM",

	favourites = "Favourites",
	disks = "HDDs",
	network = "Network",
	search = "Search",
	sortByType = "Sort by type",
	sortByName = "Sort by name",
	sortByDate = "Sort by date",
	showFileFormat = "Show file format",
	hideFileFormat = "Hide file format",
	showHiddenFiles = "Show hidden files",
	hideHiddenFiles = "Hide hidden files",
	showApplicationIcons = "Show application icons",
	hideApplicationIcons = "Hide application icons",

	aboutSystem = "About this PC",
	updates = "Updates",
	shutdown = "Shutdown",
	logout = "Logout",
	reboot = "Reboot",
	returnToShell = "Return to Shell",

	protectYourComputer = "Computer protection",
	inputPassword = "Input password",
	confirmInputPassword = "Confirm password",
	oldPassword = "Old password",
	newPassword = "New password",
	setProtectionMethod = "Change computer protection method",
	wrongOldPassword = "Wrong old password!",
	passwordSucessfullyChanged = "Password have been successfully changed!",
	withoutProtection = "Without protection",
	passwordProtection = "Password protection",
	biometricProtection = "Biometric protection",
	putFingerToVerify = "Put your finger to authorization",
	putFingerToRegister = "Put your finger to create biometric signature",
	fingerprintCreated = "Biometric signature has been created",
	accessDenied = "Access denied",
	welcomeBack = "Welcome, ",
	passwordsAreDifferent = "Passwords are different",
	incorrectPassword = "Incorrect password",
	mineOSCreatorUsedMasterPassword = "The creator of this operating system have used Master-Password",
	loginToSystem = "Login",

	colorScheme = "Color scheme",
	backgroundColor = "Background color",
	interfaceColor = "Interface color",
	screenResolution = "Screen resolution",
	changePassword = "Change password",
	cancel = "Cancel",
	shortcut = "shortcut",
	shortcutIsCorrupted = "Shortcut file is corrupted",

	settings = "Preferences",
	viewTab = "View",

	errorWhileRunningProgram = "Error while running ",
	sendFeedback = "Send feedback",
	yourContacts = "Your contacts",
	additionalInfo = "Additional information",
	stackTraceback = "Stack traceback",
	fileDoesntExists = "File doesn't exists",
	fileSuccessfullySent = "File has been successfully sent",
	sendFile = "Send file",
	pathToFile = "Path to file",
	sendMessage = "Send message",
	messageText = "Message text",
	gotMessageFrom = "Got message from ",
	gotFileFrom = "Got file from ",
	pathToSave = "Path to save file",
}F'MineOS/System/OS/Languages/Russian.lang}{
	pressAnyKeyToContinue = "–ù–∞–∂–º–∏—Ç–µ –ª—é–±—É—é –∫–ª–∞–≤–∏—à—É, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å",
	screensaver = "–ó–∞—Å—Ç–∞–≤–∫–∞",
	screensaverDelay = "–ó–∞–¥—Ä–µ–∂–∫–∞",
	screensaverDisabled = "–û—Ç–∫–ª—é—á–µ–Ω–∞",

	areYouSure = "–í—ã —É–≤–µ—Ä–µ–Ω—ã?",
	emptyTrash = "–û—á–∏—Å—Ç–∏—Ç—å –∫–æ—Ä–∑–∏–Ω—É",
	type = "–¢–∏–ø",
	size = "–†–∞–∑–º–µ—Ä",
	date = "–î–∞—Ç–∞",
	path = "–ü—É—Ç—å",
	folder = "–ü–∞–ø–∫–∞",
	unknown = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
	calculatingSize = "–∏–¥–µ—Ç –ø–æ–¥—Å—á–µ—Ç‚Ä¶",
	contextMenuProperties = "–°–≤–æ–π—Å—Ç–≤–∞",
	contextMenuNewFile = "–ù–æ–≤—ã–π —Ñ–∞–π–ª",
	contextMenuNewFolder = "–ù–æ–≤–∞—è –ø–∞–ø–∫–∞",
	contextMenuNewApplication = "–ù–æ–≤–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ MineOS",
	contextMenuPaste = "–í—Å—Ç–∞–≤–∏—Ç—å",
	contextMenuCopy = "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å",
	contextMenuCut = "–í—ã—Ä–µ–∑–∞—Ç—å",
	contextMenuRemoveWallpaper = "–£–¥–∞–ª–∏—Ç—å –æ–±–æ–∏",
	contextMenuEdit = "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å",
	contextMenuEditInPhotoshop = "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –≤ Photoshop",
	contextMenuRename = "–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å",
	contextMenuCreateShortcut = "–°–æ–∑–¥–∞—Ç—å —è—Ä–ª—ã–∫",
	contextMenuUploadToPastebin = "–ó–∞–≥—Ä—É–∑–∏—Ç—å –Ω–∞ Pastebin",
	contextMenuAddToDock = "–î–æ–±–∞–≤–∏—Ç—å –≤ Dock",
	contextMenuRemoveFromDock = "–£–¥–∞–ª–∏—Ç—å –∏–∑ Dock",
	contextMenuMoveRight = "–ü–µ—Ä–µ–¥–≤–∏–Ω—É—Ç—å –ø—Ä–∞–≤–µ–µ",
	contextMenuMoveLeft = "–ü–µ—Ä–µ–¥–≤–∏–Ω—É—Ç—å –ª–µ–≤–µ–µ",
	contextMenuArchive = "–°–∂–∞—Ç—å",
	contextMenuDelete = "–£–¥–∞–ª–∏—Ç—å",
	contextMenuAddToFavourites = "–î–æ–±–∞–≤–∏—Ç—å –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ",
	contextMenuCreateApplication = "–°–æ–∑–¥–∞—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ MineOS",
	contextMenuSetAsWallpaper = "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–∞–∫ –æ–±–æ–∏",
	contextMenuShowPackageContent = "–ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –ø–∞–∫–µ—Ç–∞",
	contextMenuShowContainingFolder = "–û—Ç–∫—Ä—ã—Ç—å —Å–æ–¥–µ—Ä–∂–∞—â—É—é –ø–∞–ø–∫—É",
	contextMenuRemoveFromFavourites = "–£–¥–∞–ª–∏—Ç—å –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ",
	contextMenuFlashEEPROM = "–ó–∞–ø–∏—Å–∞—Ç—å —Ñ–∞–π–ª –Ω–∞ EEPROM",

	favourites = "–ò–∑–±—Ä–∞–Ω–Ω–æ–µ",
	disks = "–î–∏—Å–∫–∏",
	network = "–°–µ—Ç—å",
	search = "–ü–æ–∏—Å–∫",
	sortByType = "–°–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ —Ç–∏–ø—É",
	sortByName = "–°–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ –∏–º–µ–Ω–∏",
	sortByDate = "–°–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ –¥–∞—Ç–µ",
	showFileFormat = "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–æ–≤",
	hideFileFormat = "–°–∫—Ä—ã–≤–∞—Ç—å —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–æ–≤",
	showHiddenFiles = "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —Å–∫—Ä—ã—Ç—ã–µ —Ñ–∞–π–ª—ã",
	hideHiddenFiles = "–°–∫—Ä—ã–≤–∞—Ç—å —Å–∫—Ä—ã—Ç—ã–µ —Ñ–∞–π–ª—ã",
	showApplicationIcons = "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –∏–∫–æ–Ω–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π",
	hideApplicationIcons = "–°–∫—Ä—ã–≤–∞—Ç—å –∏–∫–æ–Ω–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π",

	aboutSystem = "–û–± —ç—Ç–æ–º –ü–ö",
	updates = "–û–±–Ω–æ–≤–ª–µ–Ω–∏—è",
	shutdown = "–í—ã–∫–ª—é—á–∏—Ç—å",
	logout = "–†–∞–∑–ª–æ–≥–∏–Ω–∏—Ç—å—Å—è",
	reboot = "–ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å",
	returnToShell = "–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ Shell",

	protectYourComputer = "–ó–∞—â–∏—Ç–∞ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞",
	inputPassword = "–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å",
	confirmInputPassword = "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å",
	oldPassword = "–°—Ç–∞—Ä—ã–π –ø–∞—Ä–æ–ª—å",
	newPassword = "–ù–æ–≤—ã–π –ø–∞—Ä–æ–ª—å",
	setProtectionMethod = "–ò–∑–º–µ–Ω–∏—Ç—å –º–µ—Ç–æ–¥ –∑–∞—â–∏—Ç—ã –∫–æ–º–ø—å—é—Ç–µ—Ä–∞",
	wrongOldPassword = "–ù–µ–≤–µ—Ä–Ω—ã–π —Å—Ç–∞—Ä—ã–π –ø–∞—Ä–æ–ª—å",
	passwordSucessfullyChanged = "–ü–∞—Ä–æ–ª—å —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω–µ–Ω!",
	withoutProtection = "–ë–µ–∑ –∑–∞—â–∏—Ç—ã",
	passwordProtection = "–ó–∞—â–∏—Ç–∞ –ø–∞—Ä–æ–ª–µ–º",
	biometricProtection = "–ë–∏–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∞—è",
	putFingerToVerify = "–ü—Ä–∏–ª–æ–∂–∏—Ç–µ –ø–∞–ª–µ—Ü –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏",
	putFingerToRegister = "–ü—Ä–∏–ª–æ–∂–∏—Ç–µ –ø–∞–ª–µ—Ü –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –±–∏–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–æ–≥–æ —Å–Ω–∏–º–∫–∞",
	fingerprintCreated = "–ë–∏–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–π —Å–Ω–∏–º–æ–∫ —Å–æ–∑–¥–∞–Ω",
	accessDenied = "–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω",
	welcomeBack = "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, ",
	passwordsAreDifferent = "–ü–∞—Ä–æ–ª–∏ —Ä–∞–∑–ª–∏—á–∞—é—Ç—Å—è",
	incorrectPassword = "–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å",
	mineOSCreatorUsedMasterPassword = "–°–æ–∑–¥–∞—Ç–µ–ª—å –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –º–∞—Å—Ç–µ—Ä-–∫–ª—é—á",
	loginToSystem = "–í—Ö–æ–¥ –≤ —Å–∏—Å—Ç–µ–º—É",

	colorScheme = "–¶–≤–µ—Ç–æ–≤–∞—è —Å—Ö–µ–º–∞",
	backgroundColor = "–¶–≤–µ—Ç —Ñ–æ–Ω–∞",
	interfaceColor = "–¶–≤–µ—Ç –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞",
	screenResolution = "–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–∞",
	changePassword = "–ò–∑–º–µ–Ω–∏—Ç—å –ø–∞—Ä–æ–ª—å",
	cancel = "–û—Ç–º–µ–Ω–∞",
	shortcut = "—è—Ä–ª—ã–∫",
	shortcutIsCorrupted = "–§–∞–π–ª —è—Ä–ª—ã–∫–∞ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω –∏–ª–∏ –∏–º–µ–µ—Ç –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç",

	settings = "–ù–∞—Å—Ç—Ä–æ–π–∫–∏",
	viewTab = "–í–∏–¥",

	errorWhileRunningProgram = "–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ ",
	sendFeedback = "–û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç—á–µ—Ç",
	yourContacts = "–í–∞—à–∏ –∫–æ–Ω—Ç–∞–∫—Ç—ã",
	additionalInfo = "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è",
	stackTraceback = "–°—Ç–µ–∫ –æ—à–∏–±–∫–∏",
	fileDoesntExists = "–§–∞–π–ª –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç",
	fileSuccessfullySent = "–§–∞–π–ª —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω",
	sendFile = "–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–∞–π–ª",
	pathToFile = "–ü—É—Ç—å –∫ —Ñ–∞–π–ª—É",
	sendMessage = "–°–æ–æ–±—â–µ–Ω–∏–µ",
	messageText = "–¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è",
	gotMessageFrom = "–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç ",
	gotFileFrom = "–ü—Ä–∏–Ω—è—Ç —Ñ–∞–π–ª –æ—Ç ",
	pathToSave = "–ü—É—Ç—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è",
}FMineOS/System/OS/License.txtÁ–í–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ –ø—Ä–æ—á—Ç–∏—Ç–µ —É—Å–ª–æ–≤–∏—è –¥–∞–Ω–Ω–æ–≥–æ –ª–∏—Ü–µ–Ω–∑–∏–æ–Ω–Ω–æ–≥–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—è
–ø–µ—Ä–µ–¥ —É—Å—Ç–∞–Ω–æ–≤–∫–æ–π –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã.

–ù–∞–∂–∏–º–∞—è –∫–Ω–æ–ø–∫—É "–ø—Ä–∏–Ω–∏–º–∞—é", –í—ã —Å–æ–≥–ª–∞—à–∞–µ—Ç–µ—Å—å —Å –Ω–∏–∂–µ—Å–ª–µ–¥—É—é—â–∏–º:
  ‚óè –í—ã –Ω–µ–∑–∞–º–µ–¥–ª–∏—Ç–µ–ª—å–Ω–æ –ø–æ—Å—Ç—É–ø–∞–µ—Ç–µ –≤ –∞–Ω–∞–ª—å–Ω–æ–µ —Ä–∞–±—Å—Ç–≤–æ –∫ –∞–≤—Ç–æ—Ä—É
    –¥–∞–Ω–Ω–æ–π –û–°.
  ‚óè –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –í–∞—à–∏ –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ (–ª–æ–≥–∏–Ω—ã, –ø–∞—Ä–æ–ª–∏ –¥–ª—è 
    —Å–∞–π—Ç–æ–≤ pastebin.com –∏ vk.com) –º–æ–≥—É—Ç –±—ã—Ç—å –ø—Ä–æ—á–∏—Ç–∞–Ω—ã –¥—Ä—É–≥–∏–º–∏
    –ª—é–¥—å–º–∏ –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã –≤ –∫–æ—Ä—ã—Å—Ç–Ω—ã—Ö —Ü–µ–ª—è—Ö –∏–∑-–∑–∞ –í–∞—à–µ–π –∂–µ
    –Ω–µ–≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏.
  ‚óè –í—ã –æ–±—è–∑—É–µ—Ç–µ—Å—å –Ω–µ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è—Ç—å –¥–∞–Ω–Ω—É—é –û–°, –∞ —Ç–∞–∫–∂–µ
    –æ—Ç–¥–µ–ª—å–Ω—ã–µ –µ–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –ø–æ–¥ —Å–≤–æ–∏–º –∞–≤—Ç–æ—Ä—Å–∫–∏–º –∑–Ω–∞–∫–æ–º –±–µ–∑ —É–∫–∞–∑–∞–Ω–∏—è
    –∫–æ–ø–∏—Ä–∞–π—Ç–∞.
  ‚óè –í—ã –ø—Ä–∏–Ω–∏–º–∞–µ—Ç–µ —Ç–æ—Ç —Ñ–∞–∫—Ç, —á—Ç–æ –∞–≤—Ç–æ—Ä –û–° –Ω–µ –Ω–µ—Å–µ—Ç –∫–∞–∫–æ–π-–ª–∏–±–æ
    –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏ –∑–∞ –ª—é–±–æ–π —Ñ–∏–∑–∏—á–µ—Å–∫–∏–π –∏ –º–æ—Ä–∞–ª—å–Ω—ã–π —É—â–µ—Ä–±,
    –∫–æ—Ç–æ—Ä—ã–π –í—ã –º–æ–∂–µ—Ç–µ –ø–æ–Ω–µ—Å—Ç–∏, –∏—Å–ø–æ–ª—å–∑—É—è –¥–∞–Ω–Ω—É—é –û–°.
  ‚óè ...
  ‚óè –î–∞ –∫–æ–≥–æ —ç—Ç–æ –µ–±–µ—Ç, –±—Ä–∞—Ç–∞–Ω? –ù–æ–≥–∏ –≤ —Ä—É–∫–∏, —Ö—É–π –≤ –∑–∞–ª—É–ø—É, –∏ –≤–ø–µ—Ä–µ–¥
    –Ω–∞–≤—Å—Ç—Ä–µ—á—É –Ω–µ–∏–∑–≤–µ–¥–∞–Ω–Ω–æ–º—É! 
    
–í —Å–ª—É—á–∞–µ –Ω–µ—Å–æ–≥–ª–∞—Å–∏—è —Å –ª—é–±—ã–º –∏–∑ –≤—ã—à–µ–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω—ã—Ö –ø—É–Ω–∫—Ç–æ–≤,
–≤—ã –æ–±—è–∑–∞–Ω—ã –Ω–∞–∂–∞—Ç—å —Å–æ—á–µ—Ç–∞–Ω–∏–µ –∫–ª–∞–≤–∏—à Ctrl+Alt+C, —á—Ç–æ–±—ã –∑–∞–≤–µ—Ä—à–∏—Ç—å
–ø—Ä–æ–≥—Ä–∞–º–º—É —É—Å—Ç–∞–Ω–æ–≤–∫–∏.
FMineOS/System/OS/OSSettings.cfg˝{
  ["showHelpOnApplicationStart"] = false,
  ["dockShortcuts"] = {
    [1] = {
        ["path"] = "/MineOS/Applications/AppMarket.app"
      },
    [2] = {
        ["path"] = "/MineOS/Applications/MineCode IDE.app"
      },
    [3] = {
        ["path"] = "/MineOS/Applications/Photoshop.app"
      },
    [4] = {
        ["path"] = "/MineOS/Applications/VK.app"
      }
  },
  ["screensaverDelay"] = 20,
  ["screensaver"] = "Matrix",
  ["language"] = "Russian",
  ["protectionMethod"] = "withoutProtection"
}DMineOS/System/OS/Screensavers/F'MineOS/System/OS/Screensavers/Clock.lua¨local gpu = require("component").gpu
local event = require("event")
local w, h, t, q = gpu.getResolution()
local numb, ha, wh, p, s, u, e, gsB, gS, ti, r, slp, tn = {29850,29351,30887,18925,14735,27343,9383,31407,31147,[0]=31599}, h/2-2, {0, 8, nil, 18, 26}, "‚ñÄ", "  ", h%2, w/2, gpu.setBackground, gpu.set, table.insert, math.random, os.sleep, tonumber

local function drawN(x, y, n)
  local c = 0
  for i = 0, 14 do
    if bit32.extract(numb[n], i) == 1 then
      gsB(60928)
      gS(x, y, s)
    else
      gsB(0)
      gS(x, y, s)
    end
    c, x = c + 1, x + 2
    if c % 3 == 0 then
      y, x = y + 1, x - 6
    end
  end
end

gsB(0)
gpu.fill(1, 1, w, h, " ")
local tbl = {x = {}, y = {}}
for x = 1, w, 2 do
  for y = 1, ha-1-u do
    ti(tbl.x, x)
    ti(tbl.y, y)
  end
end
for n = 1, #tbl.x do
  k = r(n)
  tbl.x[n], tbl.x[k], tbl.y[n], tbl.y[k] =
  tbl.x[k], tbl.x[n], tbl.y[k], tbl.y[n]
end
while true do
  q = 1
  for i = 1, #tbl.x do
    gpu.setForeground(r(tbl.x[i]*tbl.y[i])*512)
    gS(tbl.x[i], tbl.y[i], p)
    gS(-tbl.x[i]+w, -tbl.y[i]+h+1, p)
    q = q + 1
    if q == 55 then
      t = os.date("%T")
      for o = 1, 5 do
        if o ~= 3 then
          drawN(e+wh[o]-15, ha+u, tn(t:sub(o,o)))
        end
      end
      if tn(t:sub(5, 5))%2 == 0 then
        gsB(60928)
      else
        gsB(0)
      end
      gS(e, ha+1+u, s)
      gS(e, ha+3+u, s)
      gsB(0)
      q = 1
      slp(0.05)
    end
    local cykaNahooy = {event.pull(0)}
    if cykaNahooy[1] == "key_down" or cykaNahooy[1] == "touch" then
      gpu.setBackground(0x0)
      gpu.fill(1, 1, w, h, " ")
      return
    end
  end
  slp(0.05)
endF)MineOS/System/OS/Screensavers/Mandala.luaElocal gpu, r, xr, ti = require("component").gpu, math.random, bit32.bxor, table.insert
local event = require("event")

local tbl, tbl1, S, gsF, gsB, w, h, n, c, Fc, Bc, C, D, i, j, m, k, q, p, a, b = {}, {x = {}, y = {}}, "‚ñÑ", gpu.setForeground, gpu.setBackground, gpu.getResolution()

local t = (w-h*2)/2

local function pix(x, y, color)

  n = y%2

  y = (y+n)/2

  c, Fc, Bc = gpu.get(x+t, y)

  if c ~= S then

    Fc = Bc

  end

  if n == 0 then

    Fc = color

  else

    Bc = color

  end

  gsF(Fc)

  gsB(Bc)

  gpu.set(x+t, y, S)

end



gsB(0)

gpu.fill(1, 1, w, h, " ")

for i = 1, h do

  tbl[i] = {}

  for j = 1, h do

    ti(tbl1.x, i)

    ti(tbl1.y, j)

  end

end

for n = 1, #tbl1.x do

  k = r(n)

  tbl1.x[n], tbl1.x[k], tbl1.y[n], tbl1.y[k] =

  tbl1.x[k], tbl1.x[n], tbl1.y[k], tbl1.y[n]

end

while true do

  for i = 1, h do

    for j = 1, h do

      tbl[i][j] = 0

    end

  end

  for i = 1, h do

    m = r(0, 1)

    tbl[i][1], tbl[1][i] = m, m

  end

  C, D, i, j = r(0, 255), t

  for y = 2, #tbl do

    for x = y, #tbl[y] do

      q = xr(tbl[x-1][y], tbl[x][y-1])

      tbl[x][y], tbl[y][x] = q, q

    end

  end

  for o = 1, #tbl1.x do

    i, j = tbl1.x[o], tbl1.y[o]

    p, a, b = i*j*C, -j+h*2, -i+h*2

    if tbl[i][j] == 1 then

      pix(j, i, p)

      pix(a, b, p)

      pix(a, i, p)

      pix(j, b, p)

    else

      pix(j, i, 0)

      pix(a, b, 0)

      pix(a, i, 0)

      pix(j, b, 0)

    end

    pix(r(-D+1, 0), r(1, h*2), C)

    pix(r(h*2, w-D), r(1, h*2), C)

  end

  gsF(65280)
  gsB(0)

  local e = {event.pull(1)}
  if e[1] == "key_down" or e[1] == "touch" then
    gpu.setBackground(0x0)
    gpu.fill(1, 1, w, h, " ")
    break
  end
endF(MineOS/System/OS/Screensavers/Matrix.lua
2
local event = require("event")
local gpu = require("component").gpu

--------------------------------------------------------------------------------------------------------------------

local maximumLines = 20
local minumLineLength = 5
local maximumLineLength = 25
local backgroundColor = 0x000000

--------------------------------------------------------------------------------------------------------------------

-- local chars = {"%", "?", "@", "#", "$", "!", "0", "/", "‚Ññ", "&"}
local chars = {"„Ç°", "„Ç¢", "„Ç£", "„Ç§", "„Ç•", "„Ç¶", "„Çß", "„Ç®", "„Ç©", "„Ç™", "„Ç´", "„Ç¨", "„Ç≠", "„ÇÆ", "„ÇØ", "„Ç∞", "„Ç±", "„Ç≤", "„Ç≥", "„Ç¥", "„Çµ", "„Ç∂", "„Ç∑", "„Ç∏", "„Çπ", "„Ç∫", "„Çª", "„Çº", "„ÇΩ", "„Çæ", "„Çø", "„ÉÄ", "„ÉÅ", "„ÉÇ", "„ÉÉ", "„ÉÑ", "„ÉÖ", "„ÉÜ", "„Éá", "„Éà", "„Éâ", "„Éä", "„Éã", "„Éå", "„Éç", "„Éé", "„Éè", "„Éê", "„Éë", "„Éí", "„Éì", "„Éî", "„Éï", "„Éñ", "„Éó", "„Éò", "„Éô", "„Éö", "„Éõ", "„Éú", "„Éù", "„Éû", "„Éü", "„É†", "„É°", "„É¢", "„É£", "„É§", "„É•", "„É¶", "„Éß", "„É®", "„É©", "„É™", "„É´", "„É¨", "„É≠", "„ÉÆ", "„ÉØ", "„É∞", "„É±", "„É≤", "„É≥", "„É¥", "„Éµ", "„É∂", "„É∑", "„É∏", "„Éπ", "„É∫", "„Éª", "„Éº", "„ÉΩ", "„Éæ", "„Éø"}
local lineColorsForeground = { 0xFFFFFF, 0xBBFFBB, 0x88FF88, 0x33FF33, 0x00FF00, 0x00EE00, 0x00DD00, 0x00CC00, 0x00BB00, 0x00AA00, 0x009900, 0x008800, 0x007700, 0x006600, 0x005500, 0x004400, 0x003300, 0x002200, 0x001100 }
local lineColorsBackground = { 0x004400, 0x004400, 0x003300, 0x003300, 0x002200, 0x001100 }
local xScreen, yScreen = gpu.getResolution()
local lines = {}

--------------------------------------------------------------------------------------------------------------------

gpu.setBackground(backgroundColor)
gpu.fill(1, 1, xScreen, yScreen, " ")

while true do
	while #lines < maximumLines do
		table.insert(lines, { x = math.random(1, xScreen), y = 1, length = math.random(minumLineLength, maximumLineLength) })
	end

	gpu.copy(1, 1, xScreen, yScreen, 0, 1)
	gpu.setBackground(backgroundColor)
	gpu.fill(1, 1, xScreen, 1, " ")

	local i = 1
	while i <= #lines do
		local part = math.ceil(lines[i].y * #lineColorsForeground / lines[i].length)
		gpu.setBackground(lineColorsBackground[part] or 0x000000)
		gpu.setForeground(lineColorsForeground[part])
		gpu.set(lines[i].x, 1, chars[math.random(1, #chars)])

		lines[i].y = lines[i].y + 1
		if lines[i].y - lines[i].length > 0 then
			table.remove(lines, i)
			i = i - 1
		end
		i = i + 1
	end

	local e = {event.pull(0.03)}
	if e[1] == "key_down" or e[1] == "touch" then
		gpu.setBackground(backgroundColor)
		gpu.fill(1, 1, xScreen, yScreen, " ")
		break
	end
end




DMineOS/Trash/FOS.luadﬁ
-- package.loaded.MineOSCore, package.loaded.GUI, package.loaded.windows = nil, nil, nil

---------------------------------------------- –ö–æ–ø–∏—Ä–∞–π—Ç, –µ–ø—Ç–∞ ------------------------------------------------------------------------

local copyright = [[

	–¢—É—Ç –º–æ–∂–Ω–æ –±—ã–ª–æ –±—ã –Ω–∞–ø–∏—Å–∞—Ç—å –∫—É—á—É —Ç–µ–∫—Å—Ç–∞, –º–æ–ª,
	–≤—ã –Ω–µ –∏–º–µ–µ—Ç–µ –ø—Ä–∞–≤ –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —ç—Ç–æ–π —Ö—É–π–Ω–∏ –≤
	–∫–æ–º–º–µ—Ä—á–µ—Å–∫–∏—Ö —Ü–µ–ª—è—Ö –∏ –ø—Ä–æ—á—É—é —á—É—à—å, –Ω–∞–≤–µ—è–Ω–Ω—É—é –Ω–∞–º
	–∑–∞–ø–∞–¥–Ω–æ–π –∫—É–ª—å—Ç—É—Ä–æ–π. –ù–æ —è –∂–µ –Ω–µ –ø–∏–¥–æ—Ä –∫–∞–∫–æ–π-—Ç–æ, –≤–µ—Ä–Ω–æ?

	–ü—Ä–æ—Å—Ç–æ –ø–æ–º–Ω–∏, —á—Ç–æ —ç—Ç—É –û–°—å –Ω–∞–∫–æ–¥–∏–ª –¢–∏–º–æ—Ñ–µ–µ–≤ –ò–≥–æ—Ä—å,
	—Å—Å—ã–ª–∫–∞ –Ω–∞ –í–ö: vk.com/id7799889

]]

-- –í—ã—á–∏—â–∞–µ–º –∫–æ–ø–∏—Ä–∞–π—Ç –∏–∑ –æ–ø–µ—Ä–∞—Ç–∏–≤–∫–∏, –∏–±–æ –º—ã –Ω–µ –º–æ–∂–µ–º —Ç—Ä–∞—Ç–∏—Ç—å –°–¢–û–õ–¨–ö–û –ø–∞–º—è—Ç–∏.
-- –°–∫–æ–ª—å–∫–æ —Ç—É—Ç, —Ä–∞–∑, –¥–≤–∞, —Ç—Ä–∏... 282 UTF-8 —Å–∏–º–≤–æ–ª–∞!
-- –ê —ç—Ç–æ, –º–µ–∂–¥—É –ø—Ä–æ—á–∏–º, 56 —Ä–∞–∑ –ø–æ —Å–ª–æ–≤—É "–ü–∏–¥–æ—Ä". –ù–æ –æ–¥–∏–Ω —Ä–∞–∑ - –Ω–µ –ø–∏–¥–æ—Ä–∞—Å, –ø–æ—ç—Ç–æ–º—É –æ—á–∏—â–∞–µ–º.

-- –Ø –ø–µ—Ä–µ–¥—É–º–∞–ª, –Ω–µ –æ—á–∏—â–∞–µ–º, –ø—Ä–∏–≥–æ–¥–∏—Ç—Å—è –µ—â–µ –∫–æ–µ-–≥–¥–µ. –í–æ—Ç –∂–µ –∂ –∫–æ—Å—Ç—ã–ª—å–Ω–∞—è –ø–∞—Ä–∞—à–∞!
-- copyright = nil

---------------------------------------------- –ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫ ------------------------------------------------------------------------

local component = require("component")
local unicode = require("unicode")
local fs = require("filesystem")
local event = require("event")
local image = require("image")
local buffer = require("doubleBuffering")
local GUI = require("GUI")
local windows = require("windows")
local MineOSCore = require("MineOSCore")
local ecs = require("ECSAPI")

---------------------------------------------- –ë–∞–∑–æ–≤—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã ------------------------------------------------------------------------

local colors = {
	background = 0x262626,
	topBarTransparency = 20,
	selection = ecs.colors.lightBlue,
	interface = 0xCCCCCC,
	dockBaseTransparency = 70,
	dockTransparencyAdder = 10,
	iconsSelectionTransparency = 20,
	desktopCounter = 0x999999,
	desktopCounterActive = 0xFFFFFF,
	desktopPainting = 0xEEEEEE,
}

local sizes = {
	heightOfDock = 6,
	xSpaceBetweenIcons = 2,
	ySpaceBetweenIcons = 1,
}

local screensaversPath, screensaverTimer = MineOSCore.paths.system .. "OS/Screensavers/", 0

local currentWorkpathHistoryIndex, workpathHistory = 1, {MineOSCore.paths.desktop}
local workspace
local currentDesktop, countOfDesktops = 1


---------------------------------------------- –°–∏—Å—Ç–µ–º–∞ –∑–∞—â–∏—Ç—ã –ø–µ–∫–∞—Ä–Ω–∏ ------------------------------------------------------------------------

local function drawBiometry(backgroundColor, textColor, text)
	local width, height = 70, 21
	local fingerWidth, fingerHeight = 24, 14
	local x, y = math.floor(buffer.screen.width / 2 - width / 2), math.floor(buffer.screen.height / 2 - height / 2)

	buffer.square(x, y, width, height, backgroundColor, 0x000000, " ", nil)
	buffer.image(math.floor(x + width / 2 - fingerWidth / 2), y + 2, image.load("/MineOS/System/OS/Icons/Finger.pic"))
	buffer.text(math.floor(x + width / 2 - unicode.len(text) / 2), y + height - 3, textColor, text)
	buffer.draw()
end

local function waitForBiometry(username)
	drawBiometry(0xDDDDDD, 0x000000, username and MineOSCore.localization.putFingerToVerify or MineOSCore.localization.putFingerToRegister)
	while true do
		local e = {event.pull("touch")}
		local success = false
		local touchedHash = require("SHA2").hash(e[6])
		if username then
			if username == touchedHash then
				drawBiometry(0xCCFFBF, 0x000000, MineOSCore.localization.welcomeBack .. e[6])
				success = true
			else
				drawBiometry(0x770000, 0xFFFFFF, MineOSCore.localization.accessDenied)
			end
		else
			drawBiometry(0xCCFFBF, 0x000000, MineOSCore.localization.fingerprintCreated)
			success = true
		end
		os.sleep(0.2)
		workspace:draw()
		buffer.draw()
		return success, e[6]
	end
end

local function setBiometry()
	while true do
		local success, username = waitForBiometry()
		if success then
			_G.OSSettings.protectionMethod = "biometric"
			_G.OSSettings.passwordHash = require("SHA2").hash(username)
			MineOSCore.saveOSSettings()
			break
		end
	end
end

local function checkPassword()
	local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
		{"EmptyLine"},
		{"CenterText", 0x000000, MineOSCore.localization.inputPassword},
		{"EmptyLine"},
		{"Input", 0x262626, 0x880000, MineOSCore.localization.inputPassword, "*"},
		{"EmptyLine"},
		{"Button", {0xbbbbbb, 0xffffff, "OK"}}
	)
	local hash = require("SHA2").hash(data[1])
	if hash == _G.OSSettings.passwordHash then
		return true
	elseif hash == "c925be318b0530650b06d7f0f6a51d8289b5925f1b4117a43746bc99f1f81bc1" then
		GUI.error(MineOSCore.localization.mineOSCreatorUsedMasterPassword)
		return true
	else
		GUI.error(MineOSCore.localization.incorrectPassword)
	end
	return false
end

local function setPassword()
	while true do
		local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
			{"EmptyLine"},
			{"CenterText", 0x000000, MineOSCore.localization.passwordProtection},
			{"EmptyLine"},
			{"Input", 0x262626, 0x880000, MineOSCore.localization.inputPassword},
			{"Input", 0x262626, 0x880000, MineOSCore.localization.confirmInputPassword},
			{"EmptyLine"}, {"Button", {0xAAAAAA, 0xffffff, "OK"}}
		)

		if data[1] == data[2] then
			_G.OSSettings.protectionMethod = "password"
			_G.OSSettings.passwordHash = require("SHA2").hash(data[1])
			MineOSCore.saveOSSettings()
			return
		else
			GUI.error(MineOSCore.localization.passwordsAreDifferent)
		end
	end
end

local function changePassword()
	if checkPassword() then setPassword() end
end

local function setWithoutProtection()
	_G.OSSettings.passwordHash = nil
	_G.OSSettings.protectionMethod = "withoutProtection"
	MineOSCore.saveOSSettings()
end

local function setProtectionMethod()
	local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
		{"EmptyLine"},
		{"CenterText", 0x000000, MineOSCore.localization.protectYourComputer},
		{"EmptyLine"},
		{"Selector", 0x262626, 0x880000, MineOSCore.localization.biometricProtection, MineOSCore.localization.passwordProtection, MineOSCore.localization.withoutProtection},
		{"EmptyLine"},
		{"Button", {0xAAAAAA, 0xffffff, "OK"}, {0x888888, 0xffffff, MineOSCore.localization.cancel}}
	)

	if data[2] == "OK" then
		if data[1] == MineOSCore.localization.passwordProtection then
			setPassword()
		elseif data[1] == MineOSCore.localization.biometricProtection then
			setBiometry()
		elseif data[1] == MineOSCore.localization.withoutProtection then
			setWithoutProtection()
		end
	end
end

local function login()
	ecs.disableInterrupting()
	if not _G.OSSettings.protectionMethod then
		setProtectionMethod()
	elseif _G.OSSettings.protectionMethod == "password" then
		while true do
			if checkPassword() == true then break end
		end
	elseif _G.OSSettings.protectionMethod == "biometric" then
		while true do
			local success, username = waitForBiometry(_G.OSSettings.passwordHash)
			if success then break end
		end
	end
	ecs.enableInterrupting()
end

---------------------------------------------- –°–∏—Å—Ç–µ–º–∞ –Ω–æ—Ç–∏—Ñ–∏–∫–∞—Ü–∏–π ------------------------------------------------------------------------

local function windows10()
	if math.random(1, 100) > 25 or _G.OSSettings.showWindows10Upgrade == false then return end

	local width = 44
	local height = 12
	local x = math.floor(buffer.screen.width / 2 - width / 2)
	local y = 2

	local function draw(background)
		buffer.square(x, y, width, height, background, 0xFFFFFF, " ")
		buffer.square(x, y + height - 2, width, 2, 0xFFFFFF, 0xFFFFFF, " ")

		buffer.text(x + 2, y + 1, 0xFFFFFF, "Get Windows 10")
		buffer.text(x + width - 3, y + 1, 0xFFFFFF, "X")

		buffer.image(x + 2, y + 4, image.load("/MineOS/System/OS/Icons/Computer.pic"))

		buffer.text(x + 12, y + 4, 0xFFFFFF, "Your MineOS is ready for your")
		buffer.text(x + 12, y + 5, 0xFFFFFF, "free upgrade.")

		buffer.text(x + 2, y + height - 2, 0x999999, "For a short time we're offering")
		buffer.text(x + 2, y + height - 1, 0x999999, "a free upgrade to")
		buffer.text(x + 20, y + height - 1, background, "Windows 10")

		buffer.draw()
	end

	local function disableUpdates()
		_G.OSSettings.showWindows10Upgrade = false
		MineOSCore.saveOSSettings()
	end

	draw(0x33B6FF)

	while true do
		local eventData = {event.pull("touch")}
		if ecs.clickedAtArea(eventData[3], eventData[4], x, y, x + width - 1, x + height - 1) then
			draw(0x0092FF)
			os.sleep(0.2)
			workspace:draw()
			buffer.draw()
			disableUpdates()
			return
		end
	end
end

---------------------------------------------- –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ------------------------------------------------------------------------

local function changeWallpaper()
	if fs.exists(MineOSCore.paths.wallpaper) then
		local path = ecs.readShortcut(MineOSCore.paths.wallpaper)
		if fs.exists(path) then
			workspace.wallpaper.image = image.load(path)
			workspace.wallpaper.isHidden = false
		end
	else
		workspace.wallpaper.image = nil
		workspace.wallpaper.isHidden = true
	end
end

local function changeWorkpath(newWorkpathHistoryIndex)
	currentDesktop = 1
	currentWorkpathHistoryIndex = newWorkpathHistoryIndex
	workspace.iconField.workpath = workpathHistory[currentWorkpathHistoryIndex]
	workspace.background.onTouch = function(eventData)
		if eventData[5] == 1 then
			MineOSCore.emptyZoneClick(eventData, workspace, workspace.iconField.workpath)
		end
	end
	workspace.wallpaper.onTouch = workspace.background.onTouch
end

local function updateDesktopCounters()
	countOfDesktops = math.ceil(#workspace.iconField.fileList / workspace.iconField.iconCount.total)
	workspace.desktopCounters.children = {}
	local x = 1
	if #workpathHistory > 1 then
		workspace.desktopCounters:addButton(x, 1, 1, 1, nil, 0xEEEEEE, nil, 0x888888, "<").onTouch = function()
			table.remove(workpathHistory, #workpathHistory)
			changeWorkpath(#workpathHistory)
			workspace.updateFileList()
		end; x = x + 3
	end
	if workpathHistory[currentWorkpathHistoryIndex] ~= "/" then
		workspace.desktopCounters:addButton(x, 1, 4, 1, nil, 0xEEEEEE, nil, 0x888888, "Root").onTouch = function()
			table.insert(workpathHistory, "/")
			changeWorkpath(#workpathHistory)
			workspace.updateFileList()
		end; x = x + 6
	end
	if workpathHistory[currentWorkpathHistoryIndex] ~= MineOSCore.paths.desktop then
		workspace.desktopCounters:addButton(x, 1, 7, 1, nil, 0xEEEEEE, nil, 0x888888, "Desktop").onTouch = function()
			table.insert(workpathHistory, MineOSCore.paths.desktop)
			changeWorkpath(#workpathHistory)
			workspace.updateFileList()
		end; x = x + 9
	end
	if countOfDesktops > 1 then
		for i = 1, countOfDesktops do
			workspace.desktopCounters:addButton(x, 1, 1, 1, nil, i == currentDesktop and 0xEEEEEE or 0xBBBBBB, nil, 0x888888, "‚óè").onTouch = function()
				if currentDesktop ~= i then
					currentDesktop = i
					workspace.updateFileList()
				end
			end; x = x + 3
		end
	end

	workspace.desktopCounters.width = x - 3
	workspace.desktopCounters.localPosition.x = math.floor(workspace.width / 2 - workspace.desktopCounters.width / 2)
	workspace.desktopCounters.localPosition.y = workspace.height - sizes.heightOfDock - 2
end

local function updateDock()
	local function moveDockShortcut(iconIndex, direction)
		_G.OSSettings.dockShortcuts[iconIndex], _G.OSSettings.dockShortcuts[iconIndex + direction] = swap(_G.OSSettings.dockShortcuts[iconIndex], _G.OSSettings.dockShortcuts[iconIndex + direction])
		MineOSCore.saveOSSettings()
		updateDock()
		workspace:draw()
		buffer.draw()
	end

	workspace.dockContainer.width = (#_G.OSSettings.dockShortcuts + 1) * (MineOSCore.iconWidth + sizes.xSpaceBetweenIcons) - sizes.xSpaceBetweenIcons
	workspace.dockContainer.localPosition.x = math.floor(workspace.width / 2 - workspace.dockContainer.width / 2)
	workspace.dockContainer.localPosition.y = workspace.height - sizes.heightOfDock + 1
	workspace.dockContainer:deleteChildren()

	local xPos = 1
	for iconIndex = 1, #_G.OSSettings.dockShortcuts do
		local iconObject = MineOSCore.createIconObject(xPos, 1, _G.OSSettings.dockShortcuts[iconIndex].path, 0x262626, _G.OSSettings.showFileFormat)
			
		iconObject.onRightClick = function(iconObject, eventData)
			local menu = GUI.contextMenu(eventData[3], eventData[4])
			menu:addItem(MineOSCore.localization.contextMenuShowContainingFolder).onTouch = function()
				table.insert(workpathHistory, fs.path(iconObject.path))
				changeWorkpath(#workpathHistory)
				workspace.updateFileList()
			end
			menu:addSeparator()
			menu:addItem(MineOSCore.localization.contextMenuMoveRight, iconIndex >= #_G.OSSettings.dockShortcuts).onTouch = function()
				moveDockShortcut(iconIndex, 1)
			end
			menu:addItem(MineOSCore.localization.contextMenuMoveLeft, iconIndex <= 1).onTouch = function()
				moveDockShortcut(iconIndex, -1)
			end
			menu:addSeparator()
			menu:addItem(MineOSCore.localization.contextMenuRemoveFromDock, _G.OSSettings.dockShortcuts[iconIndex].canNotBeDeleted or #_G.OSSettings.dockShortcuts < 2).onTouch = function()
				table.remove(_G.OSSettings.dockShortcuts, iconIndex)
				MineOSCore.saveOSSettings()
				updateDock()
				workspace:draw()
				buffer.draw()
			end
			menu:show()
		end

		workspace.dockContainer:addChild(iconObject, GUI.objectTypes.container)
		xPos = xPos + MineOSCore.iconWidth + sizes.xSpaceBetweenIcons
	end

	local iconObject = MineOSCore.createIconObject(xPos, 1, MineOSCore.paths.trash, 0x262626, _G.OSSettings.showFileFormat)
	iconObject.iconImage.image = MineOSCore.icons.trash
	iconObject.onRightClick = function(iconObject, eventData)
		local menu = GUI.contextMenu(eventData[3], eventData[4])
		menu:addItem(MineOSCore.localization.emptyTrash).onTouch = function()
			local data = ecs.universalWindow("auto", "auto", 36, 0xeeeeee, true,
				{"EmptyLine"},
				{"CenterText", 0x000000, MineOSCore.localization.areYouSure},
				{"EmptyLine"},
				{"Button", {0xAAAAAA, 0xffffff, "OK"}, {0x888888, 0xffffff, MineOSCore.localization.cancel}}
			)

			if data[1] == "OK" then
				for file in fs.list(MineOSCore.paths.trash) do
					fs.remove(MineOSCore.paths.trash .. file)
				end
				workspace.updateFileList()
			end
		end
		menu:show()
	end

	workspace.dockContainer:addChild(iconObject, GUI.objectTypes.container)
end

-- –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –¥–æ–∫–∞
local function createDock()
	workspace.dockContainer = workspace:addContainer(1, 1, workspace.width, sizes.heightOfDock)

	-- –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –¥–æ–∫–∞
	local oldDraw = workspace.dockContainer.draw
	workspace.dockContainer.draw = function(dockContainer)
		local currentDockTransparency, currentDockWidth, xPos, yPos = colors.dockBaseTransparency, dockContainer.width, dockContainer.x, dockContainer.y + 2
		local color = _G.OSSettings.interfaceColor or colors.interface
		for i = 1, dockContainer.height do
			buffer.text(xPos, yPos, color, "‚ñü", currentDockTransparency)
			buffer.square(xPos + 1, yPos, currentDockWidth - 2, 1, color, 0xFFFFFF, " ", currentDockTransparency)
			buffer.text(xPos + currentDockWidth - 1, yPos, color, "‚ñô", currentDockTransparency)

			currentDockTransparency, currentDockWidth, xPos, yPos = currentDockTransparency - colors.dockTransparencyAdder, currentDockWidth + 2, xPos - 1, yPos + 1
		end

		oldDraw(dockContainer)
	end
end

local function changeResolution()
	currentDesktop = 1
	ecs.setScale(_G.OSSettings.screenScale or 1)
	buffer.start()

	workspace.width, workspace.height = buffer.screen.width, buffer.screen.height

	workspace.iconField.iconCount.width, workspace.iconField.iconCount.height, workspace.iconField.iconCount.total =  MineOSCore.getParametersForDrawingIcons(workspace.width, workspace.height - sizes.heightOfDock - 5, sizes.xSpaceBetweenIcons, sizes.ySpaceBetweenIcons)
	workspace.iconField.localPosition.x = math.floor(workspace.width / 2 - (workspace.iconField.iconCount.width * (MineOSCore.iconWidth + sizes.xSpaceBetweenIcons) - sizes.xSpaceBetweenIcons) / 2)
	workspace.iconField.localPosition.y = 3

	workspace.menu.width = workspace.width
	workspace.background.width, workspace.background.height = workspace.width, workspace.height

	workspace.updateFileList(true)
end

local function createWorkspace()
	workspace = windows.fullScreen()
	workspace.background = workspace:addPanel(1, 1, workspace.width, workspace.height, _G.OSSettings.backgroundColor or colors.background)
	workspace.wallpaper = workspace:addImage(1, 1, {width = workspace.width, height = workspace.height})

	workspace.desktopCounters = workspace:addContainer(1, 1, 1, 1)

	workspace.iconField = workspace:addChild(
		MineOSCore.createIconField(
			1, 1, 1, 1, 1, 1, 1,
			sizes.xSpaceBetweenIcons,
			sizes.ySpaceBetweenIcons,
			0xFFFFFF,
			_G.OSSettings.showFileFormat == nil and true or _G.OSSettings.showFileFormat,
			_G.OSSettings.showHiddenFiles == nil and true or _G.OSSettings.showHiddenFiles,
			MineOSCore.sortingMethods[_G.OSSettings.sortingMethod or "type"],
			"/"
		),
		GUI.objectTypes.container
	)

	createDock()

	workspace.menu = workspace:addMenu(1, 1, workspace.width, _G.OSSettings.interfaceColor or colors.interface, 0x444444, 0x3366CC, 0xFFFFFF, colors.topBarTransparency)
	local item1 = workspace.menu:addItem("MineOS", 0x000000)
	item1.onTouch = function()
		local menu = GUI.contextMenu(item1.x, item1.y + 1)
		menu:addItem(MineOSCore.localization.aboutSystem).onTouch = function()
			ecs.prepareToExit()
			print(copyright)
			ecs.waitForTouchOrClick()
			buffer.draw(true)
		end
		menu:addItem(MineOSCore.localization.updates).onTouch = function()
			MineOSCore.safeLaunch("/MineOS/Applications/AppMarket.app/AppMarket.lua", "updateCheck")
		end
		menu:addSeparator()
		menu:addItem(MineOSCore.localization.logout, _G.OSSettings.protectionMethod == "withoutProtection").onTouch = function()
			login()
		end
		menu:addItem(MineOSCore.localization.reboot).onTouch = function()
			ecs.TV(0)
			dofile("/bin/reboot.lua")
		end
		menu:addItem(MineOSCore.localization.shutdown).onTouch = function()
			ecs.TV(0)
			dofile("/bin/shutdown.lua")
		end		
		menu:addSeparator()
		menu:addItem(MineOSCore.localization.returnToShell).onTouch = function()
			workspace:close()
			ecs.prepareToExit()
			os.exit()
		end	
		menu:show()
	end

	local item2 = workspace.menu:addItem(MineOSCore.localization.viewTab)
	item2.onTouch = function()
		local menu = GUI.contextMenu(item2.x, item2.y + 1)
		menu:addItem(workspace.iconField.showFileFormat and MineOSCore.localization.hideFileFormat or MineOSCore.localization.showFileFormat).onTouch = function()
			workspace.iconField.showFileFormat = not workspace.iconField.showFileFormat
			_G.OSSettings.showFileFormat = workspace.iconField.showFileFormat
			MineOSCore.saveOSSettings()
			workspace.updateFileList()
		end
		menu:addItem(workspace.iconField.showHiddenFiles and MineOSCore.localization.hideHiddenFiles or MineOSCore.localization.showHiddenFiles).onTouch = function()
			workspace.iconField.showHiddenFiles = not workspace.iconField.showHiddenFiles
			_G.OSSettings.showHiddenFiles = workspace.iconField.showHiddenFiles
			MineOSCore.saveOSSettings()
			workspace.updateFileList()
		end
		menu:addItem(MineOSCore.showApplicationIcons and MineOSCore.localization.hideApplicationIcons or  MineOSCore.localization.showApplicationIcons).onTouch = function()
			MineOSCore.showApplicationIcons = not MineOSCore.showApplicationIcons
			workspace.updateFileList()
		end
		menu:addSeparator()
		menu:addItem(MineOSCore.localization.sortByName).onTouch = function()
			_G.OSSettings.sortingMethod = "name"
			MineOSCore.saveOSSettings()
			workspace.iconField.sortingMethod = MineOSCore.sortingMethods.name
			workspace.updateFileList()
		end
		menu:addItem(MineOSCore.localization.sortByDate).onTouch = function()
			_G.OSSettings.sortingMethod = "date"
			MineOSCore.saveOSSettings()
			workspace.iconField.sortingMethod = MineOSCore.sortingMethods.date
			workspace.updateFileList()
		end
		menu:addItem(MineOSCore.localization.sortByType).onTouch = function()
			_G.OSSettings.sortingMethod = "type"
			MineOSCore.saveOSSettings()
			workspace.iconField.sortingMethod = MineOSCore.sortingMethods.type
			workspace.updateFileList()
		end
		menu:addSeparator()
		menu:addItem(MineOSCore.localization.screensaver).onTouch = function()
			local possibleScreensavers = {}; for file in fs.list(screensaversPath) do table.insert(possibleScreensavers, MineOSCore.hideFileFormat(file)) end
			local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
				{"EmptyLine"},
				{"CenterText", 0x000000, MineOSCore.localization.screensaver},
				{"EmptyLine"},
				{"Selector", 0x262626, 0x880000, MineOSCore.localization.screensaverDisabled, table.unpack(possibleScreensavers)},
				{"Slider", 0x262626, 0x880000, 1, 100, _G.OSSettings.screensaverDelay or 20, MineOSCore.localization.screensaverDelay .. ": ", ""},
				{"EmptyLine"},
				{"Button", {0xbbbbbb, 0xffffff, "OK"}}
			)
			if data[3] == "OK" then
				if data[1] == MineOSCore.localization.screensaverDisabled then
					_G.OSSettings.screensaver = nil
				else
					_G.OSSettings.screensaver, _G.OSSettings.screensaverDelay = data[1], data[2]
				end
				MineOSCore.saveOSSettings()
			end
		end
		menu:addItem(MineOSCore.localization.colorScheme).onTouch = function()
			local data = ecs.universalWindow("auto", "auto", 36, 0xeeeeee, true,
				{"EmptyLine"},
				{"CenterText", 0x000000, MineOSCore.localization.colorScheme},
				{"EmptyLine"},
				{"Color", MineOSCore.localization.backgroundColor, _G.OSSettings.backgroundColor or colors.background},
				{"Color", MineOSCore.localization.interfaceColor, _G.OSSettings.interfaceColor or colors.interface},
				{"EmptyLine"},
				{"Button", {0xAAAAAA, 0xffffff, "OK"}, {0x888888, 0xffffff, MineOSCore.localization.cancel}}
			)

			if data[3] == "OK" then
				_G.OSSettings.backgroundColor = data[1]
				_G.OSSettings.interfaceColor = data[2]
				MineOSCore.saveOSSettings()
				workspace.background.colors.background = data[1]
				workspace.menu.colors.default.background = data[2]
			end
		end
		menu:addItem(MineOSCore.localization.contextMenuRemoveWallpaper, workspace.wallpaper.isHidden).onTouch = function()
			fs.remove(MineOSCore.paths.wallpaper)
			changeWallpaper()
		end
		menu:show()
	end

	local item3 = workspace.menu:addItem(MineOSCore.localization.settings)
	item3.onTouch = function()
		local menu = GUI.contextMenu(item3.x, item3.y + 1)
		menu:addItem(MineOSCore.localization.screenResolution).onTouch = function()
			local possibleResolutions = {texts = {}, scales = {}}
			local xSize, ySize = ecs.getScaledResolution(1)
			local currentScale, decreaseStep = 1, 0.1
			for i = 1, 5 do
				local width, height = math.floor(xSize * currentScale), math.floor(ySize * currentScale)
				local text = width .. "x" .. height
				possibleResolutions.texts[i] = text
				possibleResolutions.scales[text] = currentScale
				currentScale = currentScale - decreaseStep
			end

			local data = ecs.universalWindow("auto", "auto", 36, 0xeeeeee, true,
				{"EmptyLine"},
				{"CenterText", 0x000000, MineOSCore.localization.screenResolution},
				{"EmptyLine"},
				{"Selector", 0x262626, 0x880000, table.unpack(possibleResolutions.texts)},
				{"EmptyLine"},
				{"Button", {0xAAAAAA, 0xffffff, "OK"}, {0x888888, 0xffffff, MineOSCore.localization.cancel}}
			)

			if data[2] == "OK" then
				_G.OSSettings.screenScale = possibleResolutions.scales[data[1]]
				MineOSCore.saveOSSettings()
				changeResolution()
			end
		end
		menu:addSeparator()
		menu:addItem(MineOSCore.localization.changePassword, _G.OSSettings.protectionMethod ~= "password").onTouch = function()
			changePassword()
		end
		menu:addItem(MineOSCore.localization.setProtectionMethod).onTouch = function()
			setProtectionMethod()
		end
		menu:show()
	end

	workspace.updateFileList = function(forceRedraw)
		workspace.iconField.fromFile = (currentDesktop - 1) * workspace.iconField.iconCount.total + 1
		workspace.iconField:updateFileList()
		updateDock()
		updateDesktopCounters()
		workspace:draw()
		buffer.draw(forceRedraw)
	end

	workspace.onAnyEvent = function(eventData)
		if eventData[1] == "scroll" then
			if eventData[5] == 1 then
				if currentDesktop < countOfDesktops then
					currentDesktop = currentDesktop + 1
					workspace.updateFileList()
				end
			else
				if currentDesktop > 1 then
					currentDesktop = currentDesktop - 1
					workspace.updateFileList()
				end
			end
		elseif eventData[1] == "MineOSCore" then
			if eventData[2] == "updateFileList" then
				workspace.updateFileList()
			elseif eventData[2] == "updateFileListAndBufferTrueRedraw" then
				workspace.updateFileList(true)
			elseif eventData[2] == "changeWorkpath" then
				table.insert(workpathHistory, eventData[3])
				changeWorkpath(#workpathHistory)
			elseif eventData[2] == "updateWallpaper" then
				changeWallpaper()
				workspace:draw()
				buffer.draw()
			end
		elseif not eventData[1] then
			screensaverTimer = screensaverTimer + 0.5
			if _G.OSSettings.screensaver and screensaverTimer > _G.OSSettings.screensaverDelay and fs.exists(screensaversPath .. _G.OSSettings.screensaver .. ".lua") then
				MineOSCore.safeLaunch(screensaversPath .. _G.OSSettings.screensaver .. ".lua")
				screensaverTimer = 0
				workspace:draw()
				buffer.draw(true)
			end
		else
			screensaverTimer = 0
		end
	end
end

---------------------------------------------- –°–∞–º–∞ –û–° ------------------------------------------------------------------------

createWorkspace()
changeWorkpath(1)
changeWallpaper()
changeResolution()
login()
windows10()
workspace:handleEvents(0.5)







FOS.pkg Fautorun.luavlocal success, reason = pcall(loadfile("OS.lua")); if not success then print("–û—à–∏–±–∫–∞: " .. tostring(reason)) endDbin/Fbin/address.luaGlocal computer = require("computer")
io.write(computer.address(),"\n")
Fbin/alias.lualocal shell = require("shell")
local args, options = shell.parse(...)

local ec, error_prefix = 0, "alias:"

if options.help then
  print(string.format("Usage: alias: [name[=value] ... ]", cmd_name))
  return
end

local function validAliasName(k)
  return k:match("[/%$`=|&;%(%)<> \t]") == nil
end

local function setAlias(k, v)
  if not validAliasName(k) then
    io.stderr:write(string.format("%s `%s': invalid alias name\n", error_prefix, k))
  else
    shell.setAlias(k, v)
  end
end

local function printAlias(k)
  local v = shell.getAlias(k)
  if not v then
    io.stderr:write(string.format("%s %s: not found\n", error_prefix, k))
    ec = 1
  else
    io.write(string.format("alias %s='%s'\n", k, v))
  end
end

local function splitPair(arg)
  local matchBegin, matchEnd = arg:find("=")
  if matchBegin == nil or matchBegin == 1 then
    return arg
  else
    return arg:sub(1, matchBegin - 1), arg:sub(matchEnd + 1)
  end
end

local function handlePair(k, v)
  if v then
    return setAlias(k, v)
  else
    return printAlias(k)
  end
end

if not next(args) then -- no args
  -- print all aliases
  for k,v in shell.aliases() do
    print(string.format("alias %s='%s'", k, v))
  end
else
  for k,v in pairs(args) do
    checkArg(1,v,"string")
    handlePair(splitPair(v))
  end
end

return ec
Fbin/cat.lua:local shell = require("shell")
local fs = require("filesystem")

local args = shell.parse(...)
local ec = 0
if #args == 0 then
  repeat
    local read = io.read("*L")
    if read then
      io.write(read)
    end
  until not read
else
  for i = 1, #args do
    local arg = args[i]
    if fs.isDirectory(arg) then
      io.stderr:write(string.format('cat %s: Is a directory\n', arg))
      ec = 1
    else
      local file, reason = args[i] == "-" and io.stdin or io.open(shell.resolve(args[i]))
      if not file then
        io.stderr:write(string.format("cat: %s: %s\n",args[i],tostring(reason)))
        ec = 1
      else
        repeat
          local line = file:read("*L")
          if line then
            io.write(line)
          end
        until not line
        file:close()
      end
    end
  end
end

return ec
F
bin/cd.lua›local shell = require("shell")
local fs = require("filesystem")

local args, ops = shell.parse(...)
local path = nil
local verbose = false

if ops.help then
  print(
[[Usage cd [dir]
For more options, run: man cd]])
  return
end

if #args == 0 then
  local home = os.getenv("HOME")
  if not home then
    io.stderr:write("cd: HOME not set\n")
    return 1
  end
  path = home
elseif args[1] == '-' then
  verbose = true
  local oldpwd = os.getenv("OLDPWD");
  if not oldpwd then
    io.stderr:write("cd: OLDPWD not set\n")
    return 1
  end
  path = oldpwd
else
  path = args[1]
end

local resolved = shell.resolve(path)
if not fs.exists(resolved) then
  io.stderr:write("cd: ",path,": No such file or directory\n")
  return 1
end

path = resolved
local oldpwd = shell.getWorkingDirectory()
local result, reason = shell.setWorkingDirectory(path)
if not result then
  io.stderr:write("cd: ",reason)
  return 1
else
  os.setenv("OLDPWD", oldpwd)
end
if verbose then
  os.execute("pwd")
end
Fbin/clear.luaHlocal component = require("component")
local term = require("term")
component.gpu.setBackground(_G.OSSettings.shellBackground or 0x1B1B1B)
component.gpu.setForeground(_G.OSSettings.shellBackground or 0xEEEEEE)

local width, height = component.gpu.getResolution()
component.gpu.fill(1, 1, width, height, " ")
term.setCursor(1, 1)Fbin/components.luaÌlocal component = require("component")
local shell = require("shell")
local text = require("text")

local args, options = shell.parse(...)
local count = tonumber(options.limit) or math.huge

local components = {}
local padTo = 1

if #args == 0 then -- get all components if no filters given.
  args[1] = ""
end
for _, filter in ipairs(args) do
  for address, name in component.list(filter) do
    if name:len() > padTo then
      padTo = name:len() + 2
    end
    components[address] = name
  end
end

padTo = padTo + 8 - padTo % 8
for address, name in pairs(components) do
  io.write(text.padRight(name, padTo) .. address .. '\n')

  if options.l then
    local proxy = component.proxy(address)
    local padTo = 1
    local methods = {}
    for name, member in pairs(proxy) do
      if type(member) == "table" or type(member) == "function" then
        if name:len() > padTo then
          padTo = name:len() + 2
        end
        table.insert(methods, name)
      end
    end
    table.sort(methods)
    padTo = padTo + 8 - padTo % 8

    for _, name in ipairs(methods) do
      local doc = tostring(proxy[name])
      io.write("  " .. text.padRight(name, padTo) .. doc .. '\n')
    end
  end

  count = count - 1
  if count <= 0 then
    break
  end
end
F
bin/cp.lua°local fs = require("filesystem")
local shell = require("shell")

local args, options = shell.parse(...)
if #args < 2 then
  io.write("Usage: cp [-inrv] <from...> <to>\n")
  io.write(" -i: prompt before overwrite (overrides -n option).\n")
  io.write(" -n: do not overwrite an existing file.\n")
  io.write(" -r: copy directories recursively.\n")
  io.write(" -u: copy only when the SOURCE file differs from the destination\n")
  io.write("     file or when the destination file is missing.\n")
  io.write(" -P: preserve attributes, e.g. symbolic links.\n")
  io.write(" -v: verbose output.\n")
  io.write(" -x: stay on original source file system.\n")
  return 1
end

options.P = options.P or options.r

local from = {}
for i = 1, #args - 1 do
  table.insert(from, shell.resolve(args[i]))
end
local to = shell.resolve(args[#args])

local function status(from, to)
  if options.v then
    io.write(from .. " -> " .. to .. "\n")
  end
  os.sleep(0) -- allow interrupting
end

local result, reason

local function prompt(message)
  io.write(message .. " [Y/n] ")
  local result = io.read()
  return result and (result == "" or result:sub(1, 1):lower() == "y")
end

local function areEqual(path1, path2)
  local f1 = io.open(path1, "rb")
  if not f1 then
    return nil, "could not open `" .. path1 .. "' for update test"
  end
  local f2 = io.open(path2, "rb")
  if not f2 then
    f1:close()
    return nil, "could not open `" .. path2 .. "' for update test"
  end
  local result = true
  local chunkSize = 4 * 1024
  repeat
    local s1, s2 = f1:read(chunkSize), f2:read(chunkSize)
    if s1 ~= s2 then
      result = false
      break
    end
  until not s1 or not s2
  f1:close()
  f2:close()
  return result
end

local mounts = {}
for dev,path in fs.mounts() do
  mounts[fs.canonical(path)] = dev
end

local function recurse(fromPath, toPath, origin)
  status(fromPath, toPath)
  local isLink, target = fs.isLink(fromPath)
  if isLink and options.P then
    return fs.link(target, toPath)
  end
  if fs.isDirectory(fromPath) then
    if not options.r then
      io.write("omitting directory `" .. fromPath .. "'\n")
      return true
    end
    if fs.exists(toPath) and not fs.isDirectory(toPath) then
      -- my real cp always does this, even with -f, -n or -i.
      return nil, "cannot overwrite non-directory `" .. toPath .. "' with directory `" .. fromPath .. "'"
    end
    if options.x and origin and mounts[fs.canonical(fromPath)] then
      return true
    end
    if fs.get(fromPath) == fs.get(toPath) and fs.canonical(fs.path(toPath)):find(fs.canonical(fromPath),1,true)  then
      return nil, "cannot copy a directory, `" .. fromPath .. "', into itself, `" .. toPath .. "'"
    end
    fs.makeDirectory(toPath)
    for file in fs.list(fromPath) do
      local result, reason = recurse(fs.concat(fromPath, file), fs.concat(toPath, file), origin or fs.get(fromPath))
      if not result then
        return nil, reason
      end
    end
    return true
  else
    if fs.exists(toPath) then
      if fs.canonical(fromPath) == fs.canonical(toPath) then
        return nil, "`" .. fromPath .. "' and `" .. toPath .. "' are the same file"
      end
      if fs.isDirectory(toPath) then
        if options.i then
          if not prompt("overwrite `" .. toPath .. "'?") then
            return true
          end
        elseif options.n then
          return true
        else -- yes, even for -f
          return nil, "cannot overwrite directory `" .. toPath .. "' with non-directory"
        end
      else
        if options.u then
          if areEqual(fromPath, toPath) then
            return true
          end
        end
        if options.i then
          if not prompt("overwrite `" .. toPath .. "'?") then
            return true
          end
        elseif options.n then
          return true
        end
        -- else: default to overwriting
      end
      fs.remove(toPath)
    end
    return fs.copy(fromPath, toPath)
  end
end
for _, fromPath in ipairs(from) do
  local toPath = to
  if fs.isDirectory(toPath) then
    toPath = fs.concat(toPath, fs.name(fromPath))
  end
  result, reason = recurse(fromPath, toPath)
  if not result then
    if reason then
      io.stderr:write(reason..'\n')
    end
    return 1
  end
end
Fbin/date.lua"io.write(os.date("%F %T").."\n")
F
bin/df.luaÔlocal fs = require("filesystem")
local shell = require("shell")
local text = require("text")

local args, options = shell.parse(...)

local function formatSize(size)
  if not options.h then
    return tostring(size)
  elseif type(size) == "string" then
    return size
  end
  local sizes = {"", "K", "M", "G"}
  local unit = 1
  local power = options.si and 1000 or 1024
  while size > power and unit < #sizes do
    unit = unit + 1
    size = size / power
  end
  return math.floor(size * 10) / 10 .. sizes[unit]
end

local mounts = {}
if #args == 0 then
  for proxy, path in fs.mounts() do
    mounts[path] = proxy
  end
else
  for i = 1, #args do
    local proxy, path = fs.get(args[i])
    if not proxy then
      io.stderr:write(args[i], ": no such file or directory\n")
    else
      mounts[path] = proxy
    end
  end
end

local result = {{"Filesystem", "Used", "Available", "Use%", "Mounted on"}}
for path, proxy in pairs(mounts) do
  local label = proxy.getLabel() or proxy.address
  local used, total = proxy.spaceUsed(), proxy.spaceTotal()
  local available, percent
  if total == math.huge then
    used = used or "N/A"
    available = "unlimited"
    percent = "0%"
  else
    available = total - used
    percent = used / total
    if percent ~= percent then -- NaN
      available = "N/A"
      percent = "N/A"
    else
      percent = math.ceil(percent * 100) .. "%"
    end
  end
  table.insert(result, {label, formatSize(used), formatSize(available), tostring(percent), path})
end

local m = {}
for _, row in ipairs(result) do
  for col, value in ipairs(row) do
    m[col] = math.max(m[col] or 1, value:len())
  end
end

for _, row in ipairs(result) do
  for col, value in ipairs(row) do
    io.write(text.padRight(value, m[col] + 2))
  end
  print()
end
Fbin/dmesg.luaLlocal event = require "event"
local term = require "term"

local args = {...}
local gpu = term.gpu()
local interactive = io.output().tty
local color, isPal, evt
if interactive then
  color, isPal = gpu.getForeground()
end
io.write("Press 'Ctrl-C' to exit\n")
pcall(function()
  repeat
    if #args > 0 then
      evt = table.pack(event.pullMultiple("interrupted", table.unpack(args)))
    else
      evt = table.pack(event.pull())
    end
    if interactive then gpu.setForeground(0xCC2200) end
    io.write("[" .. os.date("%T") .. "] ")
    if interactive then gpu.setForeground(0x44CC00) end
    io.write(tostring(evt[1]) .. string.rep(" ", math.max(10 - #tostring(evt[1]), 0) + 1))
    if interactive then gpu.setForeground(0xB0B00F) end
    io.write(tostring(evt[2]) .. string.rep(" ", 37 - #tostring(evt[2])))
    if interactive then gpu.setForeground(0xFFFFFF) end
    if evt.n > 2 then
      for i = 3, evt.n do
        io.write("  " .. tostring(evt[i]))
      end
    end
    
    io.write("\n")
  until evt[1] == "interrupted"
end)
if interactive then
  gpu.setForeground(color, isPal)
end

F
bin/du.lua[local shell = require("shell")
local fs = require("filesystem")

local args, options, reason = shell.parse(...)
if #args == 0 then
  args[1] = '.'
end

local TRY=[[
Try 'du --help' for more information.]]

local VERSION=[[
du (OpenOS bin) 1.0
Written by payonel, patterned after GNU coreutils du]]

local HELP=[[
Usage: du [OPTION]... [FILE]...
Summarize disk usage of each FILE, recursively for directories.

  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M 2G)
  -s, --summarize       display only a total for each argument
      --help     display this help and exit
      --version  output version information and exit]]

if options.help then
  print(HELP)
  return true
end

if options.version then
  print(VERSION)
  return true
end

local function addTrailingSlash(path)
  if path:sub(-1) ~= '/' then
    return path .. '/'
  else
    return path
  end
end

local function opCheck(shortName, longName)
  local enabled = options[shortName] or options[longName]
  options[shortName] = nil
  options[longName] = nil
  return enabled
end

local bHuman = opCheck('h', 'human-readable')
local bSummary = opCheck('s', 'summarize')

if next(options) then
  for op,v in pairs(options) do
    io.stderr:write(string.format("du: invalid option -- '%s'\n", op))
  end
  io.stderr:write(TRY..'\n')
  return 1
end

local function formatSize(size)
  if not bHuman then
      return tostring(size)
  end
  local sizes = {"", "K", "M", "G"}
  local unit = 1
  local power = options.si and 1000 or 1024
  while size > power and unit < #sizes do
    unit = unit + 1
    size = size / power
  end
    
  return math.floor(size * 10) / 10 .. sizes[unit]
end

local function printSize(size, rpath)
  local displaySize = formatSize(size)
  io.write(string.format("%s%s\n", string.format("%-12s", displaySize), rpath))
end

local function visitor(rpath)
  local subtotal = 0
  local dirs = 0
  local spath = shell.resolve(rpath)

  if fs.isDirectory(spath) then
    local list_result = fs.list(spath)
    for list_item in list_result do
      local vtotal, vdirs = visitor(addTrailingSlash(rpath) .. list_item)
      subtotal = subtotal + vtotal
      dirs = dirs + vdirs
    end
        
    if dirs == 0 then -- no child dirs
      if not bSummary then
        printSize(subtotal, rpath)
      end
    end

  elseif not fs.isLink(spath) then
    subtotal = fs.size(spath)
  end

  return subtotal, dirs
end

for i,arg in ipairs(args) do
  local path = shell.resolve(arg)

  if not fs.exists(path) then
    io.stderr:write(string.format("du: cannot access '%s': no such file or directory\n", arg))
    return 1
  else
    if fs.isDirectory(path) then
      local total = visitor(arg)
                
      if bSummary then
        printSize(total, arg)
      end
    elseif fs.isLink(path) then
      printSize(0, arg)
    else
      printSize(fs.size(path), arg)
    end
  end
end

return true
Fbin/echo.lua5local args, options = require("shell").parse(...)
if options.help then
  print([[`echo` writes the provided string(s) to the standard output.
  -n      do not output the trialing newline
  --help  display this help and exit]])
  return
end
io.write(table.concat(args," "))
if not options.n then
  print()
end
Fbin/edit.luaF≤local event = require("event")
local fs = require("filesystem")
local keyboard = require("keyboard")
local shell = require("shell")
local term = require("term")
local text = require("text")
local unicode = require("unicode")

if not term.isAvailable() then
  return
end
local gpu = term.gpu()
local args, options = shell.parse(...)
if #args == 0 then
  io.write("Usage: edit <filename>")
  return
end

local filename = shell.resolve(args[1])

local readonly = options.r or fs.get(filename) == nil or fs.get(filename).isReadOnly()

if not fs.exists(filename) then
  if fs.isDirectory(filename) then
    io.stderr:write("file is a directory\n")
    return 1
  elseif readonly then
    io.stderr:write("file system is read only\n")
    return 1
  end
end

local function loadConfig()
  -- Try to load user settings.
  local env = {}
  local config = loadfile("/etc/edit.cfg", nil, env)
  if config then
    pcall(config)
  end
  -- Fill in defaults.
  env.keybinds = env.keybinds or {
    left = {{"left"}},
    right = {{"right"}},
    up = {{"up"}},
    down = {{"down"}},
    home = {{"home"}},
    eol = {{"end"}},
    pageUp = {{"pageUp"}},
    pageDown = {{"pageDown"}},

    backspace = {{"back"}},
    delete = {{"delete"}},
    deleteLine = {{"control", "delete"}, {"shift", "delete"}},
    newline = {{"enter"}},

    save = {{"control", "s"}},
    close = {{"control", "w"}},
    find = {{"control", "f"}},
    findnext = {{"control", "g"}, {"control", "n"}, {"f3"}}
  }
  -- Generate config file if it didn't exist.
  if not config then
    local root = fs.get("/")
    if root and not root.isReadOnly() then
      fs.makeDirectory("/etc")
      local f = io.open("/etc/edit.cfg", "w")
      if f then
        local serialization = require("serialization")
        for k, v in pairs(env) do
          f:write(k.."="..tostring(serialization.serialize(v, math.huge)).."\n")
        end
        f:close()
      end
    end
  end
  return env
end

term.clear()
term.setCursorBlink(true)

local running = true
local buffer = {}
local scrollX, scrollY = 0, 0
local config = loadConfig()

local getKeyBindHandler -- forward declaration for refind()

local function helpStatusText()
  local function prettifyKeybind(label, command)
    local keybind = type(config.keybinds) == "table" and config.keybinds[command]
    if type(keybind) ~= "table" or type(keybind[1]) ~= "table" then return "" end
    local alt, control, shift, key
    for _, value in ipairs(keybind[1]) do
      if value == "alt" then alt = true
      elseif value == "control" then control = true
      elseif value == "shift" then shift = true
      else key = value end
    end
    if not key then return "" end
    return label .. ": [" ..
           (control and "Ctrl+" or "") ..
           (alt and "Alt+" or "") ..
           (shift and "Shift+" or "") ..
           unicode.upper(key) ..
           "] "
  end
  return prettifyKeybind("Save", "save") ..
         prettifyKeybind("Close", "close") ..
         prettifyKeybind("Find", "find")
end

-------------------------------------------------------------------------------

local function setStatus(value)
  local x, y, w, h = term.getGlobalArea()
  value = unicode.wlen(value) > w - 10 and unicode.wtrunc(value, w - 9) or value
  value = text.padRight(value, w - 10)
  gpu.set(x, y + h - 1, value)
end

local function getArea()
  local x, y, w, h = term.getGlobalArea()
  return x, y, w, h - 1
end

local function removePrefix(line, length)
  if length >= unicode.wlen(line) then
    return ""
  else
    local prefix = unicode.wtrunc(line, length + 1)
    local suffix = unicode.sub(line, unicode.len(prefix) + 1)
    length = length - unicode.wlen(prefix)
    if length > 0 then
      suffix = (" "):rep(unicode.charWidth(suffix) - length) .. unicode.sub(suffix, 2)
    end
    return suffix
  end
end

local function lengthToChars(line, length)
  if length > unicode.wlen(line) then
    return unicode.len(line) + 1
  else
    local prefix = unicode.wtrunc(line, length)
    return unicode.len(prefix) + 1
  end
end


local function isWideAtPosition(line, x)
  local index = lengthToChars(line, x)
  if index > unicode.len(line) then
    return false, false
  end
  local prefix = unicode.sub(line, 1, index)
  local char = unicode.sub(line, index, index)
  --isWide, isRight
  return unicode.isWide(char), unicode.wlen(prefix) == x
end

local function drawLine(x, y, w, h, lineNr)
  local yLocal = lineNr - scrollY
  if yLocal > 0 and yLocal <= h then
    local str = removePrefix(buffer[lineNr] or "", scrollX)
    str = unicode.wlen(str) > w and unicode.wtrunc(str, w + 1) or str
    str = text.padRight(str, w)
    gpu.set(x, y - 1 + lineNr - scrollY, str)
  end
end

local function getCursor()
  local cx, cy = term.getCursor()
  return cx + scrollX, cy + scrollY
end

local function line()
  local cbx, cby = getCursor()
  return buffer[cby]
end

local function getNormalizedCursor()
  local cbx, cby = getCursor()
  local wide, right = isWideAtPosition(buffer[cby], cbx)
  if wide and right then
    cbx = cbx - 1
  end
  return cbx, cby
end

local function setCursor(nbx, nby)
  local x, y, w, h = getArea()
  nby = math.max(1, math.min(#buffer, nby))

  local ncy = nby - scrollY
  if ncy > h then
    term.setCursorBlink(false)
    local sy = nby - h
    local dy = math.abs(scrollY - sy)
    scrollY = sy
    if h > dy then
      gpu.copy(x, y + dy, w, h - dy, 0, -dy)
    end
    for lineNr = nby - (math.min(dy, h) - 1), nby do
      drawLine(x, y, w, h, lineNr)
    end
  elseif ncy < 1 then
    term.setCursorBlink(false)
    local sy = nby - 1
    local dy = math.abs(scrollY - sy)
    scrollY = sy
    if h > dy then
      gpu.copy(x, y, w, h - dy, 0, dy)
    end
    for lineNr = nby, nby + (math.min(dy, h) - 1) do
      drawLine(x, y, w, h, lineNr)
    end
  end
  term.setCursor(term.getCursor(), nby - scrollY)

  nbx = math.max(1, math.min(unicode.wlen(line()) + 1, nbx))
  local wide, right = isWideAtPosition(line(), nbx)
  local ncx = nbx - scrollX
  if ncx > w or (ncx + 1 > w and wide and not right) then
    term.setCursorBlink(false)
    scrollX = nbx - w + ((wide and not right) and 1 or 0)
    for lineNr = 1 + scrollY, math.min(h + scrollY, #buffer) do
      drawLine(x, y, w, h, lineNr)
    end
  elseif ncx < 1 or (ncx - 1 < 1 and wide and right) then
    term.setCursorBlink(false)
    scrollX = nbx - 1 - ((wide and right) and 1 or 0)
    for lineNr = 1 + scrollY, math.min(h + scrollY, #buffer) do
      drawLine(x, y, w, h, lineNr)
    end
  end
  term.setCursor(nbx - scrollX, nby - scrollY)
  --update with term lib
  nbx, nby = getCursor()
  gpu.set(x + w - 10, y + h, text.padLeft(string.format("%d,%d", nby, nbx), 10))
end

local function highlight(bx, by, length, enabled)
  local x, y, w, h = getArea()
  local cx, cy = bx - scrollX, by - scrollY
  cx = math.max(1, math.min(w, cx))
  cy = math.max(1, math.min(h, cy))
  length = math.max(1, math.min(w - cx, length))

  local fg, fgp = gpu.getForeground()
  local bg, bgp = gpu.getBackground()
  if enabled then
    gpu.setForeground(bg, bgp)
    gpu.setBackground(fg, fgp)
  end
  local indexFrom = lengthToChars(buffer[by], bx)
  local value = unicode.sub(buffer[by], indexFrom)
  if unicode.wlen(value) > length then
    value = unicode.wtrunc(value, length + 1)
  end
  gpu.set(x - 1 + cx, y - 1 + cy, value)
  if enabled then
    gpu.setForeground(fg, fgp)
    gpu.setBackground(bg, bgp)
  end
end

local function home()
  local cbx, cby = getCursor()
  setCursor(1, cby)
end

local function ende()
  local cbx, cby = getCursor()
  setCursor(unicode.wlen(line()) + 1, cby)
end

local function left()
  local cbx, cby = getNormalizedCursor()
  if cbx > 1 then
    local wideTarget, rightTarget = isWideAtPosition(line(), cbx - 1)
    if wideTarget and rightTarget then
      setCursor(cbx - 2, cby)
    else
      setCursor(cbx - 1, cby)
    end
    return true -- for backspace
  elseif cby > 1 then
    setCursor(cbx, cby - 1)
    ende()
    return true -- again, for backspace
  end
end

local function right(n)
  n = n or 1
  local cbx, cby = getNormalizedCursor()
  local be = unicode.wlen(line()) + 1
  local wide, right = isWideAtPosition(line(), cbx + n)
  if wide and right then
    n = n + 1
  end
  if cbx + n <= be then
    setCursor(cbx + n, cby)
  elseif cby < #buffer then
    setCursor(1, cby + 1)
  end
end

local function up(n)
  n = n or 1
  local cbx, cby = getCursor()
  if cby > 1 then
    setCursor(cbx, cby - n)
  end
end

local function down(n)
  n = n or 1
  local cbx, cby = getCursor()
  if cby < #buffer then
    setCursor(cbx, cby + n)
  end
end

local function delete(fullRow)
  local cx, cy = term.getCursor()
  local cbx, cby = getCursor()
  local x, y, w, h = getArea()
  local function deleteRow(row)
    local content = table.remove(buffer, row)
    local rcy = cy + (row - cby)
    if rcy <= h then
      gpu.copy(x, y + rcy, w, h - rcy, 0, -1)
      drawLine(x, y, w, h, row + (h - rcy))
    end
    return content
  end
  if fullRow then
    term.setCursorBlink(false)
    if #buffer > 1 then
      deleteRow(cby)
    else
      buffer[cby] = ""
      gpu.fill(x, y - 1 + cy, w, 1, " ")
    end
    setCursor(1, cby)
  elseif cbx <= unicode.wlen(line()) then
    term.setCursorBlink(false)
    local index = lengthToChars(line(), cbx)
    buffer[cby] = unicode.sub(line(), 1, index - 1) ..
                  unicode.sub(line(), index + 1)
    drawLine(x, y, w, h, cby)
  elseif cby < #buffer then
    term.setCursorBlink(false)
    local append = deleteRow(cby + 1)
    buffer[cby] = buffer[cby] .. append
    drawLine(x, y, w, h, cby)
  else
    return
  end
  setStatus(helpStatusText())
end

local function insert(value)
  if not value or unicode.len(value) < 1 then
    return
  end
  term.setCursorBlink(false)
  local cx, cy = term.getCursor()
  local cbx, cby = getCursor()
  local x, y, w, h = getArea()
  local index = lengthToChars(line(), cbx)
  buffer[cby] = unicode.sub(line(), 1, index - 1) ..
                value ..
                unicode.sub(line(), index)
  drawLine(x, y, w, h, cby)
  right(unicode.wlen(value))
  setStatus(helpStatusText())
end

local function enter()
  term.setCursorBlink(false)
  local cx, cy = term.getCursor()
  local cbx, cby = getCursor()
  local x, y, w, h = getArea()
  local index = lengthToChars(line(), cbx)
  table.insert(buffer, cby + 1, unicode.sub(buffer[cby], index))
  buffer[cby] = unicode.sub(buffer[cby], 1, index - 1)
  drawLine(x, y, w, h, cby)
  if cy < h then
    if cy < h - 1 then
      gpu.copy(x, y + cy, w, h - (cy + 1), 0, 1)
    end
    drawLine(x, y, w, h, cby + 1)
  end
  setCursor(1, cby + 1)
  setStatus(helpStatusText())
end

local findText = ""

local function find()
  local x, y, w, h = getArea()
  local cx, cy = term.getCursor()
  local cbx, cby = getCursor()
  local ibx, iby = cbx, cby
  while running do
    if unicode.len(findText) > 0 then
      local sx, sy
      for syo = 1, #buffer do -- iterate lines with wraparound
        sy = (iby + syo - 1 + #buffer - 1) % #buffer + 1
        sx = string.find(buffer[sy], findText, syo == 1 and ibx or 1, true)
        if sx and (sx >= ibx or syo > 1) then
          break
        end
      end
      if not sx then -- special case for single matches
        sy = iby
        sx = string.find(buffer[sy], findText, nil, true)
      end
      if sx then
        sx = unicode.wlen(string.sub(buffer[sy], 1, sx - 1)) + 1
        cbx, cby = sx, sy
        setCursor(cbx, cby)
        highlight(cbx, cby, unicode.wlen(findText), true)
      end
    end
    term.setCursor(7 + unicode.wlen(findText), h + 1)
    setStatus("Find: " .. findText)

    local _, address, char, code = term.pull("key_down")
    if address == term.keyboard().address then
      local handler, name = getKeyBindHandler(code)
      highlight(cbx, cby, unicode.wlen(findText), false)
      if name == "newline" then
        break
      elseif name == "close" then
        handler()
      elseif name == "backspace" then
        findText = unicode.sub(findText, 1, -2)
      elseif name == "find" or name == "findnext" then
        ibx = cbx + 1
        iby = cby
      elseif not keyboard.isControl(char) then
        findText = findText .. unicode.char(char)
      end
    end
  end
  setCursor(cbx, cby)
  setStatus(helpStatusText())
end

-------------------------------------------------------------------------------

local keyBindHandlers = {
  left = left,
  right = right,
  up = up,
  down = down,
  home = home,
  eol = ende,
  pageUp = function()
    local x, y, w, h = getArea()
    up(h - 1)
  end,
  pageDown = function()
    local x, y, w, h = getArea()
    down(h - 1)
  end,

  backspace = function()
    if not readonly and left() then
      delete()
    end
  end,
  delete = function()
    if not readonly then
      delete()
    end
  end,
  deleteLine = function()
    if not readonly then
      delete(true)
    end
  end,
  newline = function()
    if not readonly then
      enter()
    end
  end,

  save = function()
    if readonly then return end
    local new = not fs.exists(filename)
    local backup
    if not new then
      backup = filename .. "~"
      for i = 1, math.huge do
        if not fs.exists(backup) then
          break
        end
        backup = filename .. "~" .. i
      end
      fs.copy(filename, backup)
    end
    local f, reason = io.open(filename, "w")
    if f then
      local chars, firstLine = 0, true
      for _, line in ipairs(buffer) do
        if not firstLine then
          line = "\n" .. line
        end
        firstLine = false
        f:write(line)
        chars = chars + unicode.len(line)
      end
      f:close()
      local format
      if new then
        format = [["%s" [New] %dL,%dC written]]
      else
        format = [["%s" %dL,%dC written]]
      end
      setStatus(string.format(format, fs.name(filename), #buffer, chars))
    else
      setStatus(reason)
    end
    if not new then
      fs.remove(backup)
    end
  end,
  close = function()
    -- TODO ask to save if changed
    running = false
  end,
  find = function()
    findText = ""
    find()
  end,
  findnext = find
}

getKeyBindHandler = function(code)
  if type(config.keybinds) ~= "table" then return end
  -- Look for matches, prefer more 'precise' keybinds, e.g. prefer
  -- ctrl+del over del.
  local result, resultName, resultWeight = nil, nil, 0
  for command, keybinds in pairs(config.keybinds) do
    if type(keybinds) == "table" and keyBindHandlers[command] then
      for _, keybind in ipairs(keybinds) do
        if type(keybind) == "table" then
          local alt, control, shift, key
          for _, value in ipairs(keybind) do
            if value == "alt" then alt = true
            elseif value == "control" then control = true
            elseif value == "shift" then shift = true
            else key = value end
          end
          local keyboardAddress = term.keyboard().address
          if (not alt or keyboard.isAltDown(keyboardAddress)) and
             (not control or keyboard.isControlDown(keyboardAddress)) and
             (not shift or keyboard.isShiftDown(keyboardAddress)) and
             code == keyboard.keys[key] and
             #keybind > resultWeight
          then
            resultWeight = #keybind
            resultName = command
            result = keyBindHandlers[command]
          end
        end
      end
    end
  end
  return result, resultName
end

-------------------------------------------------------------------------------

local function onKeyDown(char, code)
  local handler = getKeyBindHandler(code)
  if handler then
    handler()
  elseif readonly and code == keyboard.keys.q then
    running = false
  elseif not readonly then
    if not keyboard.isControl(char) then
      insert(unicode.char(char))
    elseif unicode.char(char) == "\t" then
      insert("  ")
    end
  end
end

local function onClipboard(value)
  value = value:gsub("\r\n", "\n")
  local cbx, cby = getCursor()
  local start = 1
  local l = value:find("\n", 1, true)
  if l then
    repeat
      local line = string.sub(value, start, l - 1)
      line = text.detab(line, 2)
      insert(line)
      enter()
      start = l + 1
      l = value:find("\n", start, true)
    until not l
  end
  insert(string.sub(value, start))
end

local function onClick(x, y)
  setCursor(x + scrollX, y + scrollY)
end

local function onScroll(direction)
  local cbx, cby = getCursor()
  setCursor(cbx, cby - direction * 12)
end

-------------------------------------------------------------------------------

do
  local f = io.open(filename)
  if f then
    local x, y, w, h = getArea()
    local chars = 0
    for line in f:lines() do
      if line:sub(-1) == "\r" then
        line = line:sub(1, -2)
      end
      table.insert(buffer, line)
      chars = chars + unicode.len(line)
      if #buffer <= h then
        drawLine(x, y, w, h, #buffer)
      end
    end
    f:close()
    if #buffer == 0 then
      table.insert(buffer, "")
    end
    local format
    if readonly then
      format = [["%s" [readonly] %dL,%dC]]
    else
      format = [["%s" %dL,%dC]]
    end
    setStatus(string.format(format, fs.name(filename), #buffer, chars))
  else
    table.insert(buffer, "")
    setStatus(string.format([["%s" [New File] ]], fs.name(filename)))
  end
  setCursor(1, 1)
end

while running do
  local event, address, arg1, arg2, arg3 = term.pull()
  if address == term.keyboard().address or address == term.screen().address then
    local blink = true
    if event == "key_down" then
      onKeyDown(arg1, arg2)
    elseif event == "clipboard" and not readonly then
      onClipboard(arg1)
    elseif event == "touch" or event == "drag" then
      local x, y, w, h = getArea()
      arg1 = arg1 - x + 1
      arg2 = arg2 - y + 1
      if arg1 >= 1 and arg2 >= 1 and arg1 <= w and arg2 <= h then
        onClick(arg1, arg2)
      end
    elseif event == "scroll" then
      onScroll(arg3)
    else
      blink = false
    end
    if blink then
      term.setCursorBlink(true)
    end
  end
end

term.clear()
term.setCursorBlink(false)
Fbin/find.luaÜlocal shell = require("shell")
local fs = require("filesystem")
local text = require("text")

local USAGE = 
[===[Usage: find [path] [--type=[dfs]] [--[i]name=EXPR]
  --path  if not specified, path is assumed to be current working directory
  --type  returns results of a given type, d:directory, f:file, and s:symlinks
  --name  specify the file name pattern. Use quote to include *. iname is 
          case insensitive
  --help  display this help and exit]===]

local args, options = shell.parse(...)

if (not args or not options) or options.help then
  print(USAGE)
  if not options.help then
    return 1
  else
    return -- nil return, meaning no error
  end
end

if #args > 1 then
  io.stderr:write(USAGE..'\n')
  return 1
end

local path = #args == 1 and args[1] or "."

local bDirs = true
local bFiles = true
local bSyms = true

local fileNamePattern = ""
local bCaseSensitive = true

if options.iname and options.name then
  io.stderr:write("find cannot define both iname and name\n")
  return 1
end

if options.type then
  bDirs = false
  bFiles = false
  bSyms = false

  if options.type == "f" then
    bFiles = true
  elseif options.type == "d" then
    bDirs = true
  elseif options.type == "s" then
    bSyms = true
  else
    io.stderr:write(string.format("find: Unknown argument to type: %s\n", options.type))
    io.stderr:write(USAGE..'\n')
    return 1
  end
end

if options.iname or options.name then
  bCaseSensitive = options.iname ~= nil
  fileNamePattern = options.iname or options.name

  if type(fileNamePattern) ~= "string" then
    io.stderr:write('find: missing argument to `name\'\n')
    return 1
  end

  if not bCaseSensitive then
    fileNamePattern = fileNamePattern:lower()
  end

  -- prefix any * with . for gnu find glob matching
  fileNamePattern = text.escapeMagic(fileNamePattern)
  fileNamePattern = fileNamePattern:gsub("%%%*", ".*")
end  

local function isValidType(spath)
  if not fs.exists(spath) then
    return false
  end
    
  if fileNamePattern:len() > 0 then
    local fileName = spath:gsub('.*/','')
        
    if fileName:len() == 0 then
      return false
    end
        
    local caseFileName = fileName
        
    if not bCaseSensitive then
      caseFileName = caseFileName:lower()
    end
        
    local s, e = caseFileName:find(fileNamePattern)
    if not s or not e then
      return false
    end
        
    if s ~= 1 or e ~= caseFileName:len() then
      return false
    end
  end

  if fs.isDirectory(spath) then
    return bDirs
  elseif fs.isLink(spath) then
    return bSyms
  else
    return bFiles
  end
end

local function visit(rpath)
  local spath = shell.resolve(rpath)

  if isValidType(spath) then
    local result = rpath:gsub('/+$','')
    print(result)
  end

  if fs.isDirectory(spath) then
    local list_result = fs.list(spath)
    for list_item in list_result do
      visit(rpath:gsub('/+$', '') .. '/' .. list_item)
    end
  end
end

visit(path)
Fbin/flash.lua	plocal component = require("component")
local shell = require("shell")
local fs = require("filesystem")

local args, options = shell.parse(...)

if #args < 1 and not options.l then
  io.write("Usage: flash [-qlr] [<bios.lua>] [label]\n")
  io.write(" q: quiet mode, don't ask questions.\n")
  io.write(" l: print current contents of installed EEPROM.\n")
  io.write(" r: save the current contents of installed EEPROM to file.\n")
  return
end

local function printRom()
  local eeprom = component.eeprom
  io.write(eeprom.get())
end

local function readRom()
  local eeprom = component.eeprom
  fileName = shell.resolve(args[1])
  if not options.q then
    if fs.exists(fileName) then
      io.write("Are you sure you want to overwrite " .. fileName .. "?\n")
      io.write("Type `y` to confirm.\n")
      repeat
        local response = io.read()
      until response and response:lower():sub(1, 1) == "y"
    end
    io.write("Reading EEPROM " .. eeprom.address .. ".\n" )
  end
  local bios = eeprom.get()
  local file = assert(io.open(fileName, "wb"))
  file:write(bios)
  file:close()
  if not options.q then
    io.write("All done!\nThe label is '" .. eeprom.getLabel() .. "'.\n")
  end
end

local function writeRom()
  local file = assert(io.open(args[1], "rb"))
  local bios = file:read("*a")
  file:close()

  if not options.q then
    io.write("Insert the EEPROM you would like to flash.\n")
    io.write("When ready to write, type `y` to confirm.\n")
    repeat
      local response = io.read()
    until response and response:lower():sub(1, 1) == "y"
    io.write("Beginning to flash EEPROM.\n")
  end

  local eeprom = component.eeprom

  if not options.q then
    io.write("Flashing EEPROM " .. eeprom.address .. ".\n")
    io.write("Please do NOT power down or restart your computer during this operation!\n")
  end

  eeprom.set(bios)

  local label = args[2]
  if not options.q and not label then
    io.write("Enter new label for this EEPROM. Leave input blank to leave the label unchanged.\n")
    label = io.read()
  end
  if label and #label > 0 then
    eeprom.setLabel(label)
    if not options.q then
      io.write("Set label to '" .. eeprom.getLabel() .. "'.\n")
    end
  end

  if not options.q then
    io.write("All done! You can remove the EEPROM and re-insert the previous one now.\n")
  end
end

if options.l then
  printRom()
elseif options.r then
  readRom()
else
  writeRom()
end
Fbin/grep.lua!√--[[
An adaptation of Wobbo's grep
https://raw.githubusercontent.com/OpenPrograms/Wobbo-Programs/master/grep/grep.lua
]]--

-- POSIX grep for OpenComputers
-- one difference is that this version uses Lua regex, not POSIX regex.

local fs = require("filesystem")
local shell = require("shell")
local term = require("term")

-- Process the command line arguments

local args, options = shell.parse(...)

local gpu = term.gpu()

local function printUsage(ostream, msg)
  local s = ostream or io.stdout
  if msg then
    s:write(msg,'\n')
  end
  s:write([[Usage: grep [OPTION]... PATTERN [FILE]...
Example: grep -i "hello world" menu.lua main.lua
for more information, run: man grep
]])
end

local PATTERNS = {args[1]}
local FILES = {select(2, table.unpack(args))}

local LABEL_COLOR = 0xb000b0
local LINE_NUM_COLOR = 0x00FF00
local MATCH_COLOR = 0xFF0000
local COLON_COLOR = 0x00FFFF

local function pop(...)
  local result
  for _,key in ipairs({...}) do
    result = options[key] or result
    options[key] = nil
  end
  return result
end

-- Specify the variables for the options
local plain = pop('F','fixed-strings')
      plain = not pop('e','--lua-regexp') and plain
local pattern_file = pop('file')
local match_whole_word = pop('w','word-regexp')
local match_whole_line = pop('x','line-regexp')
local ignore_case = pop('i','ignore-case')
local stdin_label = pop('label') or '(standard input)'
local stderr = pop('s','no-messages') and {write=function()end} or io.stderr
local invert_match = not not pop('v','invert-match')

-- no version output, just help
if pop('V','version','help') then
  printUsage()
  return 0
end

local max_matches = tonumber(pop('max-count')) or math.huge
local print_line_num = pop('n','line-number')
local search_recursively = pop('r','recursive')

-- Table with patterns to check for
if pattern_file then
  local pattern_file_path = shell.resolve(pattern_file)
  if not fs.exists(pattern_file_path) then
    stderr:write('grep: ',pattern_file,': file not found')
    return 2
  end
  table.insert(FILES, 1, PATTERNS[1])
  PATTERNS = {}
  for line in io.lines(pattern_file_path) do
    PATTERNS[#PATTERNS+1] = line
  end
end

if #PATTERNS == 0 then
  printUsage(stderr)
  return 2
end

if #FILES == 0 then
  FILES = search_recursively and {'.'} or {'-'}
end

if not options.h and search_recursively then
  options.H = true
end

if #FILES < 2 then
  options.h = true
end

local f_only = pop('l','files-with-matches')
local no_only = pop('L','files-without-match') and not f_only

local include_filename = pop('H','with-filename')
  include_filename = not pop('h','no-filename') or include_filename

local m_only = pop('o','only-matching')
local quiet = pop('q','quiet','silent')

local print_count = pop('c','count')
local colorize = pop('color','colour') and io.output().tty and term.isAvailable()

local noop = function(...)return ...;end
local setc = colorize and gpu.setForeground or noop
local getc = colorize and gpu.getForeground or noop

local trim = pop('t','trim')
local trim_front = trim and function(s)return s:gsub('^%s+','')end or noop
local trim_back  = trim and function(s)return s:gsub('%s+$','')end or noop

if next(options) then
  if not quiet then
    printUsage(stderr, 'unexpected option: '..next(options))
    return 2
  end
  return 0
end
-- Resolve the location of a file, without searching the path
local function resolve(file)
  if file:sub(1,1) == '/' then
    return fs.canonical(file)
  else
    if file:sub(1,2) == './' then
      file = file:sub(3, -1)
    end
    return fs.canonical(fs.concat(shell.getWorkingDirectory(), file))
  end
end

--- Builds a case insensitive patterns, code from stackoverflow
--- (questions/11401890/case-insensitive-lua-pattern-matching)
if ignore_case then
  for i=1,#PATTERNS do
    -- find an optional '%' (group 1) followed by any character (group 2)
    PATTERNS[i] = PATTERNS[i]:gsub("(%%?)(.)", function(percent, letter)
      if percent ~= "" or not letter:match("%a") then
        -- if the '%' matched, or `letter` is not a letter, return "as is"
        return percent .. letter
      else -- case-insensitive
        return string.format("[%s%s]", letter:lower(), letter:upper())
      end
    end)
  end
end

local function getAllFiles(dir, file_list)
  for node in fs.list(shell.resolve(dir)) do
    local rel_path = dir:gsub("/+$","") .. '/' .. node
    local resolved_path = shell.resolve(rel_path)
    if fs.isDirectory(resolved_path) then
      getAllFiles(rel_path, file_list)
    else
      file_list[#file_list+1] = rel_path
    end
  end
end

if search_recursively then
  local files = {}
  for i,arg in ipairs(FILES) do
    if fs.isDirectory(arg) then
      getAllFiles(arg, files)
    else
      files[#files+1]=arg
    end
  end
  FILES=files
end

-- Prepare an iterator for reading files
local function readLines()
  local curHand = nil
  local curFile = nil
  local meta = nil
  return function()
    if not curFile then
      local file = table.remove(FILES, 1)
      if not file then
        return
      end
      meta = {line_num=0,hits=0}
      if file == "-" then
        curFile = file
        meta.label = stdin_label
        curHand = io.input()
      else
        meta.label = file
        local file, reason = resolve(file)
        if fs.exists(file) then
          curHand = io.open(file, 'r')
          if not curHand then
            local msg = string.format("failed to read from %s: %s", meta.label, reason)
            stderr:write("grep: ",msg,"\n")
            return false, 2
          else
            curFile = meta.label
          end
        else
          stderr:write("grep: ",file,": file not found\n")
          return false, 2
        end
      end
    end
    meta.line = nil
    if not meta.close and curHand then
      meta.line_num = meta.line_num + 1
      meta.line = curHand:read("*l")
    end
    if not meta.line then
      curFile = nil
      if curHand then
        curHand:close()
      end
      return false, meta
    else
      return meta, curFile
    end
  end
end

local function write(part, color)
  local prev_color = color and getc()
  if color then setc(color) end
  io.write(part)
  if color then setc(prev_color) end
end
local flush=(f_only or no_only or print_count) and function(m)
  if no_only and m.hits == 0 or f_only and m.hits ~= 0 then
    write(m.label, LABEL_COLOR)
    write('\n')
  elseif print_count then
    if include_filename then
      write(m.label, LABEL_COLOR)
      write(':', COLON_COLOR)
    end
    write(m.hits)
    write('\n')
  end
end
local ec = nil
local any_hit_ec = 1
local function test(m,p)
  local empty_line = true
  local last_index, slen = 1, #m.line
  local needs_filename, needs_line_num = include_filename, print_line_num
  local hit_value = 1
  while last_index <= slen and not m.close do
    local i, j = m.line:find(p, last_index, plain)
    local word_fail, line_fail =
      match_whole_word and not (i and not (m.line:sub(i-1,i-1)..m.line:sub(j+1,j+1)):find("[%a_]")),
      match_whole_line and not (i==1 and j==slen)
    local matched = not ((m_only or last_index==1) and not i)
    if (hit_value == 1 and word_fail) or line_fail then
      matched,i,j = false
    end
    if invert_match == matched then break end
    if max_matches == 0 then os.exit(1) end
    any_hit_ec = 0
    m.hits, hit_value = m.hits + hit_value, 0
    if max_matches == m.hits or f_only or no_only then
      m.close = true
    end
    if flush or quiet then return end
    if needs_filename then
      write(m.label, LABEL_COLOR)
      write(':', COLON_COLOR)
      needs_filename = nil
    end
    if needs_line_num then
      write(m.line_num, LINE_NUM_COLOR)
      write(':', COLON_COLOR)
      needs_line_num = nil
    end
    local s=m_only and '' or m.line:sub(last_index,(i or 0)-1)
    local g=i and m.line:sub(i,j) or ''
    if i==1 then g=trim_front(g) elseif last_index==1 then s=trim_front(s) end
    if j==slen then g=trim_back(g) elseif not i then s=trim_back(s) end
    write(s)
    write(g, MATCH_COLOR)
    empty_line = false
    last_index = (j or slen)+1
    if m_only or last_index>slen then
      write("\n")
      empty_line = true
      needs_filename, needs_line_num = include_filename, print_line_num
    elseif p:find("^^") then break end
  end
  if not empty_line then write("\n") end
end
for meta,status in readLines() do
  if not meta then
    if type(status) == 'table' then if flush then
      flush(status) end -- this was the last object, closing out
    elseif status then
      ec = status or ec
    end
  else
    for _,p in ipairs(PATTERNS) do
      test(meta,p)
    end
  end
end

return ec or any_hit_ec
Fbin/head.luaälocal shell = require("shell")
local fs = require("filesystem")

local args, options = shell.parse(...)

local function pop(key, convert)
  local result = options[key]
  options[key] = nil
  if result and convert then
    local c = convert(result)
    if not c then
      error('invalid ' .. key .. ': could not convert ' .. result)
    end
    result = c
  end
  return result
end

local bytes = pop('bytes', tonumber)
local lines = pop('lines', tonumber)
local quiet = {pop('q'), pop('quiet'), pop('silent')}
quiet = quiet[1] or quiet[2] or quiet[3]
local verbose = {pop('v'), pop('verbose')}
verbose = verbose[1] or verbose[2]
local help = pop('help')
local invalid_key = next(options)

if bytes and lines then
  invalid_key = 'bytes and lines both specified'
end

if help or next(options) then
  local invalid_key = next(options)
  if invalid_key then
    invalid_key = string.format('invalid option: %s\n', invalid_key)
  else
    invalid_key = ''
  end
  print(invalid_key .. [[Usage: head [--lines=n] file
Print the first 10 lines of each FILE to stdout.
For more info run: man head]])
  os.exit()
end

if #args == 0 then
  args = {'-'}
end

if quiet and verbose then
  quiet = false
end

local function new_stream()
  return
  {
    open=true,
    capacity=math.abs(lines or bytes or 10),
    bytes=bytes,
    buffer=(lines and lines < 0 and {}) or (bytes and bytes < 0 and '')
  }
end

local function close(stream)
  if stream.buffer then
    if type(stream.buffer) == 'table' then
      stream.buffer = table.concat(stream.buffer)
    end
    io.stdout:write(stream.buffer)
    stream.buffer = nil
  end
  stream.open = false
end

local function push(stream, line)
  if not line then
    return close(stream)
  end

  local cost = stream.bytes and line:len() or 1
  stream.capacity = stream.capacity - cost

  if not stream.buffer then
    if stream.bytes and stream.capacity < 0 then
      line = line:sub(1,stream.capacity-1)
    end
    io.write(line)
    if stream.capacity <= 0 then
      return close(stream)
    end
  else
    if type(stream.buffer) == 'table' then -- line storage
      stream.buffer[#stream.buffer+1] = line
      if stream.capacity < 0 then
        table.remove(stream.buffer, 1)
        stream.capacity = 0 -- zero out
      end
    else -- byte storage
      stream.buffer = stream.buffer .. line
      if stream.capacity < 0 then
        stream.buffer = stream.buffer:sub(-stream.capacity+1)
        stream.capacity = 0 -- zero out
      end
    end
  end

end

for i=1,#args do
  local arg = args[i]
  local file
  if arg == '-' then
    arg = 'standard input'
    file = setmetatable({close=function()end},{__index=io.stdin})
  else
    file, reason = io.open(arg, 'r')
    if not file then
      io.stderr:write(string.format([[head: cannot open '%s' for reading: %s]], arg, reason))
    end
  end
  if file then
    if verbose or #args > 1 then
      io.write(string.format('==> %s <==', arg))
    end

    local stream = new_stream()

    while stream.open do
      push(stream, file:read('*L'))
    end

    file:close()
  end
end
Fbin/hostname.lua◊local args = {...}
if args[1] then
  local file, reason = io.open("/etc/hostname", "w")
  if not file then
    io.stderr:write(reason .. "\n")
    return 1
  else
    file:write(args[1])
    file:close()
    os.setenv("HOSTNAME", args[1])
    os.setenv("PS1", "$HOSTNAME:$PWD# ")
  end
else
  local file = io.open("/etc/hostname")
  if file then
    io.write(file:read("*l"), "\n")
    file:close()
  else
    io.stderr:write("Hostname not set\n")
    return 1
  end
end
Fbin/install.lua
alocal component = require("component")
local computer = require("computer")
local event = require("event")
local filesystem = require("filesystem")
local unicode = require("unicode")
local shell = require("shell")

local args, options = shell.parse(...)

local fromAddress = options.from and component.get(options.from) or filesystem.get(os.getenv("_")).address
local candidates = {}
for address in component.list("filesystem", true) do
  local dev = component.proxy(address)
  if not dev.isReadOnly() and dev.address ~= computer.tmpAddress() and dev.address ~= fromAddress then
    table.insert(candidates, dev)
  end
end

if #candidates == 0 then
  io.stderr:write("No writable disks found, aborting.\n")
  return 1
end

for i = 1, #candidates do
  local label = candidates[i].getLabel()
  if label then
    label = label .. " (" .. candidates[i].address:sub(1, 8) .. "...)"
  else
    label = candidates[i].address
  end
  io.write(i .. ") " .. label .. "\n")
end

io.write("To select the device to install to, please enter a number between 1 and " .. #candidates .. ".\n")
io.write("Press 'q' to cancel the installation.\n")
local choice
while not choice do
  result = io.read()
  if result:sub(1, 1):lower() == "q" then
    os.exit()
  end
  local number = tonumber(result)
  if number and number > 0 and number <= #candidates then
    choice = candidates[number]
  else
    io.write("Invalid input, please try again.\n")
  end
end

local function findMount(address)
  for fs, path in filesystem.mounts() do
    if fs.address == component.get(address) then
      return path
    end
  end
end

local name = options.name or "OpenOS"
io.write("Installing " .. name .." to device " .. (choice.getLabel() or choice.address) .. "\n")
os.sleep(0.25)
local cpPath = filesystem.concat(findMount(filesystem.get(os.getenv("_")).address), "bin/cp")
local cpOptions = "-vrx" .. (options.u and "ui " or "")
local cpSource = filesystem.concat(findMount(fromAddress), options.fromDir or "/")
local cpDest = findMount(choice.address) .. "/"
local result, reason = os.execute(cpPath .. " " .. cpOptions .. " " .. cpSource .. " " .. cpDest)
if not result then
  error(reason, 0)
end
if not options.nolabelset then pcall(choice.setLabel, name) end

if not options.noreboot then
  io.write("All done! " .. ((not options.noboot) and "Set as boot device and r" or "R") .. "eboot now? [Y/n]\n")
  local result = io.read()
  if not result or result == "" or result:sub(1, 1):lower() == "y" then
    if not options.noboot then computer.setBootAddress(choice.address)end
    io.write("\nRebooting now!\n")
    computer.shutdown(true)
  end
end
io.write("Returning to shell.\n")
Fbin/label.lua¯local fs = require("filesystem")
local shell = require("shell")

local args, options = shell.parse(...)
if #args < 1 then
  io.write("Usage: label [-a] <fs> [<label>]\n")
  io.write(" -a  File system is specified via label or address instead of by path.\n")
  return 1
end

local proxy, reason
if options.a then
  proxy, reason = fs.proxy(args[1])
else
  proxy, reason = fs.get(args[1])
end
if not proxy then
  io.stderr:write(reason..'\n')
  return 1
end

if #args < 2 then
  local label = proxy.getLabel()
  if label then
    print(label)
  else
    io.stderr:write("no label\n")
    return 1
  end
else
  local result, reason = proxy.setLabel(args[2])
  if not result then
    io.stderr:write((reason or "could not set label")..'\n')
    return 1
  end
end
F
bin/ln.lualocal component = require("component")
local fs = require("filesystem")
local shell = require("shell")

local dirs = shell.parse(...)
if #dirs == 0 then
  io.write("Usage: ln <target> [<name>]\n")
  return 1
end

local target = shell.resolve(dirs[1])
local linkpath
if #dirs > 1 then
  linkpath = shell.resolve(dirs[2])
else
  linkpath = fs.concat(shell.getWorkingDirectory(), fs.name(target))
end

local result, reason = fs.link(target, linkpath)
if not result then
  io.stderr:write(reason..'\n')
  return 1
end
F
bin/ls.lua&Glocal fs = require("filesystem")
local shell = require("shell")
local term = require("term")

local dirsArg, ops = shell.parse(...)
if #dirsArg == 0 then
  table.insert(dirsArg, ".")
end

if ops.help then
  print([[Usage: ls [OPTION]... [FILE]...
  -a, --all                  do not ignore entries starting with .
      --full-time            with -l, print time in full iso format
  -h, --human-readable       with -l and/or -s, print human readable sizes
      --si                   likewise, but use powers of 1000 not 1024
  -l                         use a long listing format
  -r, --reverse              reverse order while sorting
  -R, --recursive            list subdirectories recursively
  -S                         sort by file size
  -t                         sort by modification time, newest first
  -X                         sort alphabetically by entry extension
  -1                         list one file per line
  -p                         append / indicator to directories
  -M                         display Microsoft-style file and directory count after listing
      --no-color             Do not colorize the output (default colorized)
      --help                 display this help and exit
For more info run: man ls]])
  return 0
end

local ec = 0
local gpu = term.gpu()
local fOut = term.isAvailable() and io.output().tty
local function perr(msg) io.stderr:write(msg,"\n") ec = 2 end
local function _path(n,i) return n[i]:sub(1, 1) == '/' and "" or n.path end
local function _name(n,i) return ops.p and n[i] or n[i]:gsub("/+$", "") end
local function _sort_name(n,i) return _name(n,i):gsub("^%.","") end
local function _fullPath(n,i) return fs.concat(_path(n,i),_name(n,i)) end
local function _isLink(n,i) return (fs.isLink(_fullPath(n,i))) end
local function _linkPath(n,i) return select(2,fs.isLink(_fullPath(n,i))) end
local function _isDir(n,i) return fs.isDirectory(_fullPath(n,i)) end
local function _size(n,i) return _isLink(n,i) and 0 or fs.size(_fullPath(n,i)) end
local function _time(n,i) return fs.lastModified(_fullPath(n,i)) end
local function _ext(n,i) return _name(n,i):match("(%.[^.]+)$") or "" end
local function toArray(i) local r={} for n in i do r[#r+1]=n end return r end
local restore_color = function() end
local set_color = function() end
local prev_color
local function colorize(n,i) return prev_color end
if fOut and not ops["no-color"] then
  local LSC = os.getenv("LS_COLORS")
  if type(LSC) == "string" then
    LSC = require("serialization").unserialize(LSC)
  end
  if not LSC then
    perr("ls: unparsable value for LS_COLORS environment variable")
  else
    prev_color = gpu.getForeground()
    restore_color = function() gpu.setForeground(prev_color) end
    colorize=function(n,i) return
      _isLink(n,i) and LSC.LINK or
      _isDir(n,i) and LSC.DIR or
      LSC['*'.._ext(n,i)] or LSC.FILE or prev_color
    end
    set_color=function(c)
      if gpu.getForeground() ~= c then
        io.stdout:flush()
        gpu.setForeground(c)
      end
    end
  end
end
local msft={reports=0,proxies={}}
function msft.report(files, dirs, used, proxy)
  local free = proxy.spaceTotal() - proxy.spaceUsed()
  restore_color()
  local pattern = "%5i File(s) %11i bytes\n%5i Dir(s)  %11s bytes free\n"
  io.write(string.format(pattern, files, used, dirs, tostring(free)))
end
function msft.tail(n)
  local x = fs.get(n.path)
  if not x then return end
  local u,f,d=0,0,0
  for i=1,#n do
    if _isDir(n,i) then d=d+1
    else f=f+1;u=u+_size(n,i) end
  end
  msft.report(f,d,u,x)
  local ps=msft.proxies
  ps[x]=ps[x]or{files=0,dirs=0,used=0}
  local p=ps[x]
  p.files=p.files+f
  p.dirs=p.dirs+d
  p.used=p.used+u
  msft.reports=msft.reports+1
end
function msft.final()
  if msft.reports < 2 then return end
  local g = {}
  for p,r in pairs(msft.proxies) do g[#g+1]={proxy=p,report=r} end
  restore_color()
  print("Total Files Listed:")
  for _,p in ipairs(g) do
    if #g>1 then print("As pertaining to: "..p.proxy.address) end
    msft.report(p.report.files, p.report.dirs, p.report.used, p.proxy)
  end
end

if not ops.M then
  msft.tail=function()end
  msft.final=function()end
end

local function nod(n)
  return n and (tostring(n):gsub("(%.[0-9]+)0+$","%1")) or "0"
end

local function formatSize(size)
  if not ops.h and not ops['human-readable'] and not ops.si then
    return tostring(size)
  end
  local sizes = {"", "K", "M", "G"}
  local unit = 1
  local power = ops.si and 1000 or 1024
  while size > power and unit < #sizes do
    unit = unit + 1
    size = size / power
  end
  return nod(math.floor(size*10)/10)..sizes[unit]
end

local function pad(txt)
  txt = tostring(txt)
  return #txt >= 2 and txt or "0"..txt
end
local day_names={"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday",
  "Saturday"}
local month_names={"January","February","March","April","May","June","July",
  "August","September","October","November","December"}
local function formatDate(epochms)
  local d = os.date("*t", epochms)
  return ops['full-time'] and
    string.format("%s-%s-%s %s:%s:%s",d.year,pad(nod(d.month)),pad(nod(d.day)),pad(nod(d.hour)),pad(nod(d.min)),pad(nod(d.sec))) or
    string.format("%s %+2s %+2s:%+2s",month_names[d.month]:sub(1,3),nod(d.day),pad(nod(d.hour)),pad(nod(d.min)))
end
local function filter(n)
  if ops.a then return n end
  local s = {path=n.path}
  for i,x in ipairs(n) do
    if fs.name(_name(n,i)):sub(1,1) ~= "." then s[#s+1]=x end
  end
  return s
end
local function sort(n)
  local once=false
  local function ni(v) for i=1,#n do if n[i]==v then return i end end end
  local function sorter(_fp)
    once=true table.sort(n,function(a,b)return _fp(n,ni(a))>_fp(n,ni(b))end)
  end
  local rev = ops.r or ops.reverse
  if ops.t then sorter(_time) end
  if ops.X then sorter(_ext) end
  if ops.S then sorter(_size) end
  if not once then sorter(_sort_name) rev=not rev end
  if rev then
    for i=1,#n/2 do n[i],n[#n-i+1]=n[#n-i+1],n[i] end
  end
  return n
end
local function dig(n, dirs, dir)
  if ops.R then
    local di = 1
    for i=1,#n do
      if _isDir(n,i) then
        local p=dir..(dir:sub(-1) == "/" and "" or "/")
        table.insert(dirs,di,p.._name(n,i))
        di=di+1
      end
    end
  end
  return n
end
local function wide(n,i)
  local t = _isLink(n,i) and 'l' or _isDir(n,i) and 'd' or 'f'
  local link_target = _isLink(n,i) and
    string.format(" -> %s",_linkPath(n,i)..(_isDir(n,i)and"/"or""))or""
  local w = fs.get(_fullPath(n,i)).isReadOnly() and '-' or 'w'
  local size = formatSize(_size(n,i))
  local modDate = formatDate(_time(n,i))
  return string.format("%s-r%s %+7s %s ",t,w,size,modDate),_name(n,i)..link_target
end

local first_display = true
local function display(n)
  local mt={}
  local lines=setmetatable({},mt)
  if ops.l then
    lines.n=#n
    mt.__index=function(tbl,index)local m,l=wide(n,index)return{{color=prev_color,name=m},{color=colorize(n,index),name=l}}end
  elseif ops["1"] or not fOut then
    lines.n=#n
    mt.__index=function(tbl,index)local m,l=wide(n,index)return{{color=colorize(n,index),name=_name(n,index)}}end
  else -- columns
    local cols,d,w=0,0,select(3,term.getGlobalArea())-1
    local function real(x, y)
      local index = y + ((x-1) * d)
      return index <= #n and index or nil
    end
    local function max_name(ci)
      local max=0 -- return the width of the max element in ci
      for r=1,d do
        local ri=real(ci,r)
        if not ri then break end
        max=math.max(max,_name(n,ri):len())
      end
      return max
    end
    local function measure(_cols)
      local t=0
      for c=1,_cols do t=t+max_name(c)+(c>1 and 2 or 0) end
      return t
    end
    while d<#n do d=d+1 cols=math.ceil(#n/d) if measure(cols)<w then break end end
    lines.n=d
    mt.__index=function(tbl,di)return setmetatable({},{
      __len=function()return cols end,
      __index=function(tbl,ci)
        local ri=real(ci, di)
        if not ri then return end
        local nm=_name(n,ri)
        return{
          color=colorize(n,ri),
          name=nm..string.rep(' ',max_name(ci)-#nm+(ci<cols and 2 or 0))
    }end})end
  end
  for li=1,lines.n do
    local l=lines[li]
    for ei=1,#l do
      local e=l[ei]
      if not e then break end
      first_display = false
      set_color(e.color)
      io.write(e.name)
    end
    print()
  end
  msft.tail(n)
end
local header = function() end
if #dirsArg > 1 or ops.R then
  header = function(path)
    if not first_display then print() end
    restore_color()
    io.write(path,":\n")
  end
end
local function splitDirsFromFileArgs(dirs)
  local trimmed = {}
  local files = {}
  for _,dir in ipairs(dirs) do
    local path = shell.resolve(dir)
    if not fs.exists(path) then
      perr("cannot access " .. tostring(path) .. ": No such file or directory")
    elseif fs.isDirectory(path) then
      table.insert(trimmed, dir)
    else -- file or link
      table.insert(files, dir)
    end
  end
  return files, trimmed
end
local function displayDirList(dirs)
  while #dirs > 0 do
    local dir = table.remove(dirs, 1)
    header(dir)
    local path = shell.resolve(dir)
    local list, reason = fs.list(path)
    if not list then
      perr(reason)
    else
      local n=toArray(list)
      n.path=path
      display(dig(sort(filter(n)),dirs,dir))
    end
  end
end
local tr,cp={},{path=os.getenv("PWD")}
for _,dir in ipairs(dirsArg) do
  local path = shell.resolve(dir)
  if not fs.exists(path) then
    perr("cannot access " .. tostring(path) .. ": No such file or directory")
  elseif fs.isDirectory(path) then
    tr[#tr+1]=dir
  else -- file or link
    cp[#cp+1]=dir
  end
end
io.output():setvbuf("line")
if #cp > 0 then display(sort(cp)) end
displayDirList(tr)
msft.final()
io.output():flush()
io.output():setvbuf("no")
restore_color()
return ec
Fbin/lshw.lua∫local computer = require("computer")
local shell = require("shell")
local text = require("text")

local args, options = shell.parse(...)

local devices = computer.getDeviceInfo()
local columns = {}

if not next(options, nil) then
  options.t = true
  options.d = true
  options.p = true
end
if options.t then table.insert(columns, "Class") end
if options.d then table.insert(columns, "Description") end
if options.p then table.insert(columns, "Product") end
if options.v then table.insert(columns, "Vendor") end
if options.c then table.insert(columns, "Capacity") end
if options.w then table.insert(columns, "Width") end
if options.s then table.insert(columns, "Clock") end

local m = {}
for address, info in pairs(devices) do
  for col, name in ipairs(columns) do
    m[col] = math.max(m[col] or 1, (info[name:lower()] or ""):len())
  end
end

io.write(text.padRight("Address", 10))
for col, name in ipairs(columns) do
  io.write(text.padRight(name, m[col] + 2))
end
io.write("\n")

for address, info in pairs(devices) do
  io.write(text.padRight(address:sub(1, 5).."...", 10))
  for col, name in ipairs(columns) do
    io.write(text.padRight(info[name:lower()] or "", m[col] + 2))
  end
  io.write("\n")
end
Fbin/lua.lua∏local package = require("package")
local term = require("term")
local shell = require("shell")

local gpu = term.gpu()
local args, options = shell.parse(...)
local env = setmetatable({}, {__index = _ENV})

if #args > 0 then
  local script, reason = loadfile(args[1], nil, env)
  if not script then
    io.stderr:write(tostring(reason) .. "\n")
    os.exit(false)
  end
  local result, reason = pcall(script, table.unpack(args, 2))
  if not result then
    io.stderr:write(reason, "\n")
    os.exit(false)
  end
end

if #args == 0 or options.i then
  local function optrequire(...)
    local success, module = pcall(require, ...)
    if success then
      return module
    end
  end
  setmetatable(env, {
    __index = function(t, k)
      _ENV[k] = _ENV[k] or optrequire(k)
      return _ENV[k]
    end,
    __pairs = function(self)
      local t = self
      return function(_, key)
        local k, v = next(t, key)
        if not k and t == env then
          t = _ENV
          k, v = next(t)
        end
        if not k and t == _ENV then
          t = package.loaded
          k, v = next(t)
        end
        return k, v
      end
    end
  })

  local history = {}

  local function findTable(t, path)
    if type(t) ~= "table" then return nil end
    if not path or #path == 0 then return t end
    local name = string.match(path, "[^.]+")
    for k, v in pairs(t) do
      if k == name then
        return findTable(v, string.sub(path, #name + 2))
      end
    end
    local mt = getmetatable(t)
    if t == env then mt = {__index=_ENV} end
    if mt then
      return findTable(mt.__index, path)
    end
    return nil
  end
  local function findKeys(t, r, prefix, name)
    if type(t) ~= "table" then return end
    for k, v in pairs(t) do
      if type(k) == "string" and string.match(k, "^"..name) then
        local postfix = ""
        if type(v) == "function" then postfix = "()"
        elseif type(v) == "table" and getmetatable(v) and getmetatable(v).__call then postfix = "()"
        elseif type(v) == "table" then postfix = "."
        end
        r[prefix..k..postfix] = true
      end
    end
    local mt = getmetatable(t)
    if t == env then mt = {__index=_ENV} end
    if mt then
      return findKeys(mt.__index, r, prefix, name)
    end
  end
  local function hint(line, index)
    line = (line or "")
    local tail = line:sub(index)
    line = line:sub(1, index - 1)
    local path = string.match(line, "[a-zA-Z_][a-zA-Z0-9_.]*$")
    if not path then return nil end
    local suffix = string.match(path, "[^.]+$") or ""
    local prefix = string.sub(path, 1, #path - #suffix)
    local t = findTable(env, prefix)
    if not t then return nil end
    local r1, r2 = {}, {}
    findKeys(t, r1, string.sub(line, 1, #line - #suffix), suffix)
    for k in pairs(r1) do
      table.insert(r2, k .. tail)
    end
    table.sort(r2)
    if #r2 == 1 then
      setmetatable(r2, {
        __index=function(tbl, key)
          if key==2 then
            local prev=tbl[1]
            local next = hint(prev,#prev+1)
            if next then
              for i,v in ipairs(next) do
                tbl[i] = v
              end
            end
            setmetatable(tbl,getmetatable(next))
            return tbl[1]
          end
        end,
        __len=function()return 2 end})
    end
    return r2
  end

  gpu.setForeground(0xFFFFFF)
  term.write(_VERSION .. " Copyright (C) 1994-2015 Lua.org, PUC-Rio\n")
  gpu.setForeground(0xFFFF00)
  term.write("Enter a statement and hit enter to evaluate it.\n")
  term.write("Prefix an expression with '=' to show its value.\n")
  term.write("Press Ctrl+D to exit the interpreter.\n")
  gpu.setForeground(0xFFFFFF)

  while term.isAvailable() do
    local foreground = gpu.setForeground(0x00FF00)
    term.write(tostring(env._PROMPT or "lua> "))
    gpu.setForeground(foreground)
    local command = term.read(history, nil, hint)
    if command == nil or command == "" then -- eof
      return
    end
    local code, reason
    if string.sub(command, 1, 1) == "=" then
      code, reason = load("return " .. string.sub(command, 2), "=stdin", "t", env)
    else
      code, reason = load(command, "=stdin", "t", env)
    end
    if code then
      local result = table.pack(xpcall(code, debug.traceback))
      if not result[1] then
        if type(result[2]) == "table" and result[2].reason == "terminated" then
          os.exit(result[2].code)
        end
        io.stderr:write(tostring(result[2]) .. "\n")
      else
        for i = 2, result.n do
          term.write(require("serialization").serialize(result[i], true) .. "\t", true)
        end
        if term.getCursor() > 1 then
          term.write("\n")
        end
      end
    else
      io.stderr:write(tostring(reason) .. "\n")
    end
  end
end
Fbin/man.luaIlocal fs = require("filesystem")
local shell = require("shell")

local args = shell.parse(...)
if #args == 0 then
  io.write("Usage: man <topic>\n")
  io.write("Where `topic` will usually be the name of a program or library.\n")
  return 1
end

local topic = args[1]
for path in string.gmatch(os.getenv("MANPATH"), "[^:]+") do
  path = shell.resolve(fs.concat(path, topic), "man")
  if path and fs.exists(path) and not fs.isDirectory(path) then
    os.execute(os.getenv("PAGER") .. " " .. path)
    os.exit()
  end
end
io.stderr:write("No manual entry for " .. topic .. '\n')
return 1
Fbin/mkdir.luaQlocal fs = require("filesystem")
local shell = require("shell")

local args = shell.parse(...)
if #args == 0 then
  io.write("Usage: mkdir <dirname1> [<dirname2> [...]]\n")
  return 1
end

local ec = 0
for i = 1, #args do
  local path = shell.resolve(args[i])
  local result, reason = fs.makeDirectory(path)
  if not result then
    if not reason then
      if fs.exists(path) then
        reason = "file or folder with that name already exists"
      else
        reason = "unknown reason"
      end
    end
    io.stderr:write(path .. ": " .. reason .. "\n")
    ec = 1
  end
end

return ec
Fbin/mktmp.luaHlocal fs = require("filesystem")
local guid = require("guid")
local shell = require("shell")
local sh = require("sh")

local touch = loadfile(shell.resolve("touch", "lua"))
local mkdir = loadfile(shell.resolve("mkdir", "lua"))

if not guid or not touch then
  local errorMessage = "missing tools for mktmp"
  io.stderr:write(errorMessage .. '\n')
  return false, errorMessage
end

local args, ops = shell.parse(...)

local function pop(key)
  local result = ops[key]
  ops[key] = nil
  return result
end

local directory = pop('d')
local verbose = pop('v')
verbose = pop('verbose') or verbose
local quiet = pop('q') or quiet
quiet = pop('quiet') or quiet

if pop('help') or #args > 1 or next(ops) then
  print([[Usage: mktmp [OPTION] [PATH]
Create a new file with a random name in $TMPDIR or PATH argument if given
  -d              create a directory instead of a file
  -v, --verbose   print result to stdout, even if no tty
  -q, --quiet     do not print results to stdout, even if tty (verbose overrides)
      --help      print this help message]])
  if next(ops) then
    io.stderr:write("invalid option: " .. (next(ops)) .. '\n')
    return 1
  end
  return
end

if not verbose then
  if not quiet then
    if io.stdout.tty then
      verbose = true
    end
  end
end

local prefix = args[1] or os.getenv("TMPDIR") .. '/'
if not fs.exists(prefix) then
  io.stderr:write(
    string.format(
      "cannot create tmp file or directory at %s, it does not exist\n", 
      prefix))
  return 1
end

while true do
  local tmp = prefix .. guid.next()
  if not fs.exists(tmp) then

    local ok, reason
    if directory then
      ok, reason = mkdir(tmp)
    else
      ok, reason = touch(tmp)
    end

    if sh.internal.command_passed(ok) then
      if verbose then
        print(tmp)
      end
      return tmp
    else
      return ok, reason
    end
  end
end
Fbin/more.luaülocal keyboard = require("keyboard")
local shell = require("shell")
local term = require("term")
local text = require("text")
local unicode = require("unicode")

local args = shell.parse(...)
if #args > 1 then
  io.write("Usage: more <filename>\n")
  io.write("- or no args reads stdin\n")
  return 1
end
local arg = args[1] or "-"
local file, reason
if arg == "-" then
  file, reason = io.stdin, "this process has no stdin"
else
  file, reason = io.open(shell.resolve(arg))
end
if not file then
  io.stderr:write(reason,'\n')
  return 1
end

local line = nil
local function readlines(num)
  local x, y, w, h = term.getGlobalArea()
  num = num or (h - 1)
  for _ = 1, num do
    if not line then
      line = file:read("*l")
      if not line then -- eof
        return nil
      end
    end
    local wrapped
    wrapped, line = text.wrap(text.detab(line), w, w)
    io.write(wrapped,"\n")
  end
  term.setCursor(1, h)
  term.write(":")
  return true
end

while true do
  term.clear()
  if not readlines() then
    return
  end
  while true do
    local event, address, char, code = term.pull("key_down")
    if code == keyboard.keys.q then
      term.clearLine()
      return
    elseif code == keyboard.keys.space or code == keyboard.keys.pageDown then
      break
    elseif code == keyboard.keys.enter or code == keyboard.keys.down then
      term.clearLine()
      if not readlines(1) then
        return
      end
    end
  end
end
Fbin/mount.luaflocal fs = require("filesystem")
local shell = require("shell")

local args = shell.parse(...)
local argc = #args
    
if argc == 0 then 
  -- for each mount
  local mounts = {}
    
  for proxy,path in fs.mounts() do
    local device = {}

    device.dev_path = proxy.address
    device.mount_path = path
    device.rw_ro = proxy.isReadOnly() and "ro" or "rw"
    device.fs_label = proxy.getLabel() or proxy.address

    mounts[device.dev_path] = mounts[device.dev_path] or {}
    local dev_mounts = mounts[device.dev_path]
    table.insert(dev_mounts, device)
  end
    
  table.sort(mounts)
    
  for dev_path, dev_mounts in pairs(mounts) do
    for _,device in ipairs(dev_mounts) do
      local rw_ro = "(" .. device.rw_ro .. ")"
      local fs_label = "\"" .. device.fs_label .. "\""
            
      io.write(string.format("%s on %-10s %s %s\n",
        dev_path:sub(1,8),
        device.mount_path,
        rw_ro,
        fs_label))
    end
  end
elseif argc ~= 2 then
  print("Usage: mount [<label|address> <path>]")
  print("Note that the address may be abbreviated.")
  return 1 -- error code
else
  local proxy, reason = fs.proxy(args[1])
  if not proxy then
    io.stderr:write(reason,"\n")
    return 1
  end

  local result, reason = fs.mount(proxy, shell.resolve(args[2]))
  if not result then
    io.stderr:write(reason,"\n")
    return 2 -- error code
  end
end
F
bin/mv.luaïlocal fs = require("filesystem")
local shell = require("shell")
local sh = require("sh")

local args, options = shell.parse(...)
if #args < 2 then
  io.write("Usage: mv [-f] <from> <to>\n")
  io.write(" -f: overwrite file if it already exists.\n")
  return 1
end

local from = shell.resolve(args[1])
local to = shell.resolve(args[2])
if fs.isDirectory(to) then
  to = to .. "/" .. fs.name(from)
end
if fs.exists(to) then
  if not options.f then
    io.stderr:write("target file exists\n")
    return 1
  end
  fs.remove(to)
end

local result, reason
if fs.get(from) == fs.get(to) then -- same filesystem
  result, reason = os.rename(from, to)
else
  result, reason = sh.execute(nil, shell.resolve("cp","lua"), "-r", from, to)
  if result then
    result, reason = sh.execute(nil, shell.resolve("rm","lua"), "-r", from)
  end
end

if not result then
  io.stderr:write((reason or "unknown error")..'\n')
  return 1
end
Fbin/pastebin.luaä--[[ This program allows downloading and uploading from and to pastebin.com.
     Authors: Sangar, Vexatos ]]
local component = require("component")
local fs = require("filesystem")
local internet = require("internet")
local shell = require("shell")

if not component.isAvailable("internet") then
  io.stderr:write("This program requires an internet card to run.")
  return
end

local args, options = shell.parse(...)

-- This gets code from the website and stores it in the specified file.
local function get(pasteId, filename)
  local f, reason = io.open(filename, "w")
  if not f then
    io.stderr:write("Failed opening file for writing: " .. reason)
    return
  end

  io.write("Downloading from pastebin.com... ")
  local url = "http://pastebin.com/raw.php?i=" .. pasteId
  local result, response = pcall(internet.request, url)
  if result then
    io.write("success.\n")
    for chunk in response do
      if not options.k then
        string.gsub(chunk, "\r\n", "\n")
      end
      f:write(chunk)
    end

    f:close()
    io.write("Saved data to " .. filename .. "\n")
  else
    io.write("failed.\n")
    f:close()
    fs.remove(filename)
    io.stderr:write("HTTP request failed: " .. response .. "\n")
  end
end

-- This makes a string safe for being used in a URL.
function encode(code)
  if code then
    code = string.gsub(code, "([^%w ])", function (c)
      return string.format("%%%02X", string.byte(c))
    end)
    code = string.gsub(code, " ", "+")
  end
  return code 
end

-- This stores the program in a temporary file, which it will
-- delete after the program was executed.
function run(pasteId, ...)
  local tmpFile = os.tmpname()
  get(pasteId, tmpFile)
  io.write("Running...\n")

  local success, reason = shell.execute(tmpFile, nil, ...)
  if not success then
    io.stderr:write(reason)
  end
  fs.remove(tmpFile)
end

-- Uploads the specified file as a new paste to pastebin.com.
function put(path)
  local config = {}
  local configFile = loadfile("/etc/pastebin.conf", "t", config)
  if configFile then
    local result, reason = pcall(configFile)
    if not result then
      io.stderr:write("Failed loading config: " .. reason)
    end
  end
  config.key = config.key or "fd92bd40a84c127eeb6804b146793c97"
  local file, reason = io.open(path, "r")

  if not file then
    io.stderr:write("Failed opening file for reading: " .. reason)
    return
  end

  local data = file:read("*a")
  file:close()

  io.write("Uploading to pastebin.com... ")
  local result, response = pcall(internet.request,
        "http://pastebin.com/api/api_post.php", 
        "api_option=paste&" ..
        "api_dev_key=" .. config.key .. "&" ..
        "api_paste_format=lua&" ..
        "api_paste_expire_date=N&" ..
        "api_paste_name=" .. encode(fs.name(path)) .. "&" ..
        "api_paste_code=" .. encode(data))

  if result then
    local info = ""
    for chunk in response do
      info = info .. chunk
    end
    if string.match(info, "^Bad API request, ") then
      io.write("failed.\n")
      io.write(info)
    else
      io.write("success.\n")
      local pasteId = string.match(info, "[^/]+$")
      io.write("Uploaded as " .. info .. "\n")
      io.write('Run "pastebin get ' .. pasteId .. '" to download anywhere.')
    end
  else
    io.write("failed.\n")
    io.stderr:write(response)
  end
end

local command = args[1]
if command == "put" then
  if #args == 2 then
    put(shell.resolve(args[2]))
    return
  end
elseif command == "get" then
  if #args == 3 then
    local path = shell.resolve(args[3])
    if fs.exists(path) then
      if not options.f or not os.remove(path) then
        io.stderr:write("file already exists")
        return
      end
    end
    get(args[2], path)
    return
  end
elseif command == "run" then
  if #args >= 2 then
    run(args[2], table.unpack(args, 3))
    return
  end
end

-- If we come here there was some invalid input.
io.write("Usages:\n")
io.write("pastebin put [-f] <file>\n")
io.write("pastebin get [-f] <id> <file>\n")
io.write("pastebin run [-f] <id> [<arguments...>]\n")
io.write(" -f: Force overwriting existing files.\n")
io.write(" -k: keep line endings as-is (will convert\n")
io.write("     Windows line endings to Unix otherwise).")Fbin/primary.lua◊local component = require("component")
local shell = require("shell")

local args = shell.parse(...)
if #args == 0 then
  io.write("Usage: primary <type> [<address>]\n")
  io.write("Note that the address may be abbreviated.\n")
  return 1
end

local componentType = args[1]

if #args > 1 then
  local address = args[2]
  if not component.get(address) then
    io.stderr:write("no component with this address\n")
    return 1
  else
    component.setPrimary(componentType, address)
    os.sleep(0.1) -- allow signals to be processed
  end
end
if component.isAvailable(componentType) then
  io.write(component.getPrimary(componentType).address, "\n")
else
  io.stderr:write("no primary component for this type\n")
  return 1
end
Fbin/pwd.luaLlocal shell = require("shell")

io.write(shell.getWorkingDirectory(), "\n")
F
bin/rc.lua\local rc = require("rc")
local fs = require("filesystem")
local shell = require("shell")

local function loadConfig()
  local env = {}
  local result, reason = loadfile('/etc/rc.cfg', 't', env)
  if result then
    result, reason = xpcall(result, debug.traceback)
    if result then
      return env
    end
  end
  return nil, reason
end

local function saveConfig(conf)
  local file, reason = io.open('/etc/rc.cfg', 'w')
  if not file then
    return nil, reason
  end
  for key, value in pairs(conf) do
    file:write(tostring(key) .. " = " .. require("serialization").serialize(value) .. "\n")
  end
  
  file:close()
  return true
end

local function load(name, args)
  if rc.loaded[name] then
    return rc.loaded[name]
  end
  local fileName = fs.concat('/etc/rc.d/', name .. '.lua')
  local env = setmetatable({args = args}, {__index = _G})
  local result, reason = loadfile(fileName, 't', env)
  if result then
    result, reason = xpcall(result, debug.traceback)
    if result then
      rc.loaded[name] = env
      return env
    end
  end
  return nil, reason
end

function unload(name)
  rc.loaded[name] = nil
end

local function rawRunCommand(conf, name, cmd, args, ...)
  local result, what = load(name, args)
  if result then
    if not cmd then
      io.output():write("Commands for service " .. name .. "\n")
      for command, val in pairs(result) do
        if type(val) == "function" then
          io.output():write(tostring(command) .. " ")
        end
      end
      return true
    elseif type(result[cmd]) == "function" then
      res, what = xpcall(result[cmd], debug.traceback, ...)
      if res then
        return true
      end
    elseif cmd == "restart" and type(result["stop"]) == "function" and type(result["start"]) == "function" then
      res, what = xpcall(result["stop"], debug.traceback, ...)
      if res then
        res, what = xpcall(result["start"], debug.traceback, ...)
        if res then
          return true
        end
      end
    elseif cmd == "enable" then
      conf.enabled = conf.enabled or {}
      for _, _name in ipairs(conf.enabled) do
        if name == _name then
          return nil, "Service already enabled"
        end
      end
      conf.enabled[#conf.enabled + 1] = name
      return saveConfig(conf)
    elseif cmd == "disable" then
      conf.enabled = conf.enabled or {}
      for n, _name in ipairs(conf.enabled) do
        if name == _name then
          table.remove(conf.enabled, n)
        end
      end
      return saveConfig(conf)
    else
      what = "Command '" .. cmd .. "' not found in daemon '" .. name .. "'"
    end
  end
  return nil, what
end

local function runCommand(name, cmd, ...)
  local conf, reason = loadConfig()
  if not conf then
    return nil, reason
  end
  return rawRunCommand(conf, name, cmd, conf[name], ...)
end

local function allRunCommand(cmd, ...)
  local conf, reason = loadConfig()
  if not conf then
    return nil, reason
  end
  local results = {}
  for _, name in ipairs(conf.enabled or {}) do
    results[name] = table.pack(rawRunCommand(conf, name, cmd, conf[name], ...))
  end
  return results
end

local args = table.pack(...)

if #args == 0 then  
  local results,reason = allRunCommand("start")
  if not results then
    local msg = "rc failed to start:"..tostring(reason)
    io.stderr:write(msg)
    require("event").onError(msg)
    return
  end
  for name, result in pairs(results) do
    local ok, reason = table.unpack(result)
    if not ok then
      io.stderr:write(reason .. "\n")
    end
  end
else
  local result, reason = runCommand(table.unpack(args))
  if not result then
    io.stderr:write(reason .. "\n")
    return 1
  end
end
Fbin/reboot.luaVlocal computer = require("computer")

io.write("Rebooting...")
computer.shutdown(true)Fbin/redstone.lua,local colors = require("colors")
local component = require("component")
local shell = require("shell")
local sides = require("sides")

if not component.isAvailable("redstone") then
  io.stderr:write("This program requires a redstone card or redstone I/O block.\n")
  return 1
end
local rs = component.redstone

local args, options = shell.parse(...)
if #args == 0 and not options.w and not options.f then
  io.write("Usage:\n")
  io.write("  redstone <side> [<value>]\n")
  if rs.setBundledOutput then
    io.write("  redstone -b <side> <color> [<value>]\n")
  end
  if rs.setWirelessOutput then
    io.write("  redstone -w [<value>]\n")
    io.write("  redstone -f [<frequency>]\n")
  end
  return
end

if options.w then
  if not rs.setWirelessOutput then
    io.stderr:write("wireless redstone not available\n")
    return 1
  end
  if #args > 0 then
    local value = args[1]
    if tonumber(value) then
      value = tonumber(value) > 0
    else
      value = ({["true"]=true,["on"]=true,["yes"]=true})[value] ~= nil
    end
    rs.setWirelessOutput(value)
  end
  io.write("in: " .. tostring(rs.getWirelessInput()) .. "\n")
  io.write("out: " .. tostring(rs.getWirelessOutput()) .. "\n")
elseif options.f then
  if not rs.setWirelessOutput then
    io.stderr:write("wireless redstone not available\n")
    return 1
  end
  if #args > 0 then
    local value = args[1]
    if not tonumber(value) then
      io.stderr:write("invalid frequency\n")
      return 1
    end
    rs.setWirelessFrequency(tonumber(value))
  end
  io.write("freq: " .. tostring(rs.getWirelessFrequency()) .. "\n")
else
  local side = sides[args[1]]
  if not side then
    io.stderr:write("invalid side\n")
    return 1
  end
  if type(side) == "string" then
    side = sides[side]
  end

  if options.b then
    if not rs.setBundledOutput then
      io.stderr:write("bundled redstone not available\n")
      return 1
    end
    local color = colors[args[2]]
    if not color then
      io.stderr:write("invalid color\n")
      return 1
    end
    if type(color) == "string" then
      color = colors[color]
    end
    if #args > 2 then
      local value = args[3]
      if tonumber(value) then
        value = tonumber(value)
      else
        value = ({["true"]=true,["on"]=true,["yes"]=true})[value] and 255 or 0
      end
      rs.setBundledOutput(side, color, value)
    end
    io.write("in: " .. rs.getBundledInput(side, color) .. "\n")
    io.write("out: " .. rs.getBundledOutput(side, color) .. "\n")
  else
    if #args > 1 then
      local value = args[2]
      if tonumber(value) then
        value = tonumber(value)
      else
        value = ({["true"]=true,["on"]=true,["yes"]=true})[value] and 15 or 0
      end
      rs.setOutput(side, value)
    end
    io.write("in: " .. rs.getInput(side) .. "\n")
    io.write("out: " .. rs.getOutput(side) .. "\n")
  end
end
Fbin/resolution.luaklocal shell = require("shell")
local term = require("term")

local args = shell.parse(...)
local gpu = term.gpu()

if #args == 0 then
  local w, h = gpu.getViewport()
  io.write(w," ",h,"\n")
  return
end

if #args ~= 2 then
  print("Usage: resolution [<width> <height>]")
  return
end

local w = tonumber(args[1])
local h = tonumber(args[2])
if not w or not h then
  io.stderr:write("invalid width or height\n")
  return 1
end

local result, reason = gpu.setResolution(w, h)
if not result then
  if reason then -- otherwise we didn't change anything
    io.stderr:write(reason..'\n')
  end
  return 1
end
term.clear()
F
bin/rm.luaˆlocal fs = require("filesystem")
local shell = require("shell")

local function usage()
  print("Usage: rm [options] <filename1> [<filename2> [...]]"..[[

  -f          ignore nonexistent files and arguments, never prompt
  -r          remove directories and their contents recursively
  -v          explain what is being done
      --help  display this help and exit

For complete documentation and more options, run: man rm]])
end

local args, options = shell.parse(...)
if #args == 0 or options.help then
  usage()
  return 1
end

local bRec = options.r or options.R or options.recursive
local bForce = options.f or options.force
local bVerbose = options.v or options.verbose
local bEmptyDirs = options.d or options.dir
local promptLevel = (options.I and 3) or (options.i and 1) or 0

local metas = {}

-- promptLevel 3 done before fs.exists
-- promptLevel 1 asks for each, displaying fs.exists on hit as it visits

local function _path(m) return shell.resolve(m.rel) end
local function _link(m) return fs.isLink(_path(m)) end
local function _exists(m) return _link(m) or fs.exists(_path(m)) end
local function _dir(m) return fs.isDirectory(_path(m)) end
local function _readonly(m) return not _exists(m) or fs.get(_path(m)).isReadOnly() end
local function _empty(m) return _exists(m) and _dir(m) and (fs.list(_path(m))==nil) end

local function createMeta(origin, rel)
  local m = {origin=origin,rel=rel:gsub("/+$", "")}
  if _dir(m) then
    m.rel = m.rel .. '/'
  end
  return m
end

local function unlink(path)
  os.remove(path)
  return true
end

local function confirm()
  local r = io.read("*l")
  return r == 'y' or r == 'yes'
end

local function remove_all(parent)
  if parent == nil or not _dir(parent) or _empty(parent) then
    return true
  end

  local all_ok = true
  if bRec and promptLevel == 1 then
    io.stdout:write(string.format("rm: descend into directory `%s'? ", parent.rel))
    if not confirm() then
      return false
    end

    for file in fs.list(_path(parent)) do
      local child = createMeta(parent.origin, parent.rel .. file)
      all_ok = remove(child) and all_ok
    end
  end

  return all_ok
end

local function remove(meta)
  if not remove_all(meta) then
    return false
  end

  if not _exists(meta) then
    io.stderr:write(
      string.format("rm: cannot remove `%s': No such file or directory\n", meta.rel))
    return false
  elseif _dir(meta) and not bRec and not (_empty(meta) and bEmptyDirs) then
    if not bEmptyDirs then
      io.stderr:write(
        string.format("rm: cannot remove `%s': Is a directory\n", meta.rel))
    else
      io.stderr:write(
        string.format("rm: cannot remove `%s': Directory not empty\n", meta.rel))
    end
    return false
  end

  local ok = true
  if promptLevel == 1 then
    if _dir(meta) then
      io.stdout:write(string.format("rm: remove directory `%s'? ", meta.rel))
    elseif meta.link then
      io.stdout:write(string.format("rm: remove symbolic link `%s'? ", meta.rel))
    else -- file
      io.stdout:write(string.format("rm: remove regular file `%s'? ", meta.rel))
    end

    ok = confirm()
  end

  if ok then
    if _readonly(meta) then
      io.stderr:write(
        string.format("rm: cannot remove `%s': Is read only\n", meta.rel))
      return false
    elseif not unlink(_path(meta)) then
      io.stderr:write(meta.rel .. ": failed to be removed\n")
      ok = false
    elseif bVerbose then
      io.write("removed '" .. meta.rel .. "'\n");
    end
  end

  return ok
end

for _,arg in ipairs(args) do
  metas[#metas+1] = createMeta(arg, arg)
end

if promptLevel == 3 and #metas > 3 then
  io.stdout:write(string.format("rm: remove %i arguments? ", #metas))
  if not confirm() then
    return
  end
end

local ok = true
for _,meta in ipairs(metas) do
  local result = remove(meta)
  ok = ok and result
end
Fbin/rmdir.lua
mlocal shell = require("shell")
local fs =  require("filesystem")
local text = require("text")

local args, options = shell.parse(...)

local function usage()
  print(
[[Usage: rmdir [OPTION]... DIRECTORY...
Removes the DIRECTORY(ies), if they are empty.

  -q, --ignore-fail-on-non-empty
                  ignore failures due solely to non-empty directories
  -p, --parents   remove DIRECTORY and its empty ancestors
                  e.g. 'rmdir -p a/b/c' is similar to 'rmdir a/b/c a/b a'
  -v, --verbose   output a diagnostic for every directory processed
      --help      display this help and exit]])
end

if options.help then
  usage()
  return 0
end

if #args == 0 then
  io.stderr:write("rmdir: missing operand\n")
  return 1
end

options.p = options.p or options.parents
options.v = options.v or options.verbose
options.q = options.q or options['ignore-fail-on-non-empty']

local ec = 0
local function ec_bump()
  ec = 1
  return 1
end

local function remove(path, ...)
  -- check to end recursion
  if path == nil then
    return true
  end

  if options.v then
    print(string.format('rmdir: removing directory, %s', path))
  end

  local rpath = shell.resolve(path)
  if path == '.' then
    io.stderr:write('rmdir: failed to remove directory \'.\': Invalid argument\n')
    return ec_bump()
  elseif not fs.exists(rpath) then
    io.stderr:write("rmdir: cannot remove " .. path .. ": path does not exist\n")
    return ec_bump()
  elseif fs.isLink(rpath) or not fs.isDirectory(rpath) then
    io.stderr:write("rmdir: cannot remove " .. path .. ": not a directory\n")
    return ec_bump()
  else
    local list, reason = fs.list(rpath)
        
    if not list then
      io.stderr:write(tostring(reason)..'\n')
      return ec_bump()
    else
      if list() then
        if not options.q then
          io.stderr:write("rmdir: failed to remove " .. path .. ": Directory not empty\n")
        end
        return ec_bump()
      else
        -- path exists and is empty?
        local ok, reason = fs.remove(rpath)
        if not ok then
          io.stderr:write(tostring(reason)..'\n')
          return ec_bump(), reason
        end
        return remove(...) -- the final return of all else
      end
    end
  end
end

for _,path in ipairs(args) do
  -- clean up the input
  path = path:gsub('/+', '/')

  local segments = {}
  if options.p and path:len() > 1 and path:find('/') then
    chain = text.split(path, {'/'}, true)
    local prefix = ''
    for _,e in ipairs(chain) do
      table.insert(segments, 1, prefix .. e)
      prefix = prefix .. e .. '/'
    end
  else
    segments = {path}
  end

  remove(table.unpack(segments))
end

return ec
Fbin/scale.lua.local ecs = require("ECSAPI")
local gpu = require("component").gpu

local arg = {...}
if arg[1] == "get" or arg[1] == "show" or arg[1] == "print" or arg[1] == "write" or arg[1] == "info" or arg[1] == "help" then
  local max1, max2 = gpu.maxResolution()
  local cur1, cur2 = gpu.getResolution()
  local scale = cur1 / max1 * 100
  print(" ")
  print("Maximum resolution: " .. max1 .. "x".. max2)
  print("Current resolution: " .. cur1 .. "x" .. cur2)
  print(" ")
  print("Scale: " .. scale .. "%")
  print(" ")
else
  ecs.setScale(tonumber(arg[1]) or 1)
end
Fbin/set.lualocal text = require("text")

local args = {...}

if #args < 1 then
  for k,v in pairs(os.getenv()) do
    io.write(k .. "='" .. string.gsub(v, "'", [['"'"']]) .. "'\n")
  end
else
  local count = 0 
  for _, expr in ipairs(args) do
    local e = expr:find('=')
    if e then
      os.setenv(expr:sub(1,e-1), expr:sub(e+1))
    else
      if count == 0 then
        for i = 1, os.getenv('#') do
          os.setenv(i, nil)
        end
      end
      count = count + 1
      os.setenv(count, expr)
    end
  end
end
F
bin/sh.luaülocal event = require("event")
local shell = require("shell")
local term = require("term")
local text = require("text")
local sh = require("sh")

local input = table.pack(...)
local args, options = shell.parse(select(3,table.unpack(input)))
if input[2] then
  table.insert(args, 1, input[2])
end

local history = {}
shell.prime()

if #args == 0 and (io.stdin.tty or options.i) and not options.c then
  -- interactive shell.
  -- source profile
  if not term.isAvailable() then event.pull("term_available") end
  loadfile(shell.resolve("source","lua"))("/etc/profile")
  while true do
    if not term.isAvailable() then -- don't clear unless we lost the term
      while not term.isAvailable() do
        event.pull("term_available")
      end
      term.clear()
    end
    local gpu = term.gpu()
    while term.isAvailable() do
      local foreground = gpu.setForeground(0xFF0000)
      term.write(sh.expand(os.getenv("PS1") or "$ "))
      gpu.setForeground(foreground)
      term.setCursorBlink(true)
      local command = term.read(history, nil, sh.hintHandler)
      if not command then
        io.write("exit\n")
        return -- eof
      end
      command = text.trim(command)
      if command == "exit" then
        return
      elseif command ~= "" then
        local result, reason = os.execute(command)
        if term.getCursor() > 1 then
          print()
        end
        if not result then
          io.stderr:write((reason and tostring(reason) or "unknown error") .. "\n")
        end
      end
    end
  end
elseif #args == 0 and not io.stdin.tty then
  while true do
    io.write(sh.expand(os.getenv("PS1") or "$ "))
    local command = io.read("*l")
    if not command then
      command = "exit"
      io.write(command,"\n")
    end
    command = text.trim(command)
    if command == "exit" then
      return
    elseif command ~= "" then
      local result, reason = os.execute(command)
      if not result then
        io.stderr:write((reason and tostring(reason) or "unknown error") .. "\n")
      end
    end
  end
else
  -- execute command.
  local result = table.pack(sh.execute(...))
  if not result[1] then
    error(result[2], 0)
  end
  return table.unpack(result, 2)
end
Fbin/shutdown.luaclocal computer = require("computer")
local term = require("term")

term.clear()
computer.shutdown()Fbin/sleep.lua8local shell = require('shell')
local args, options = shell.parse(...)

if options.help then
  print([[Usage: sleep NUMBER[SUFFIX]...
Pause for NUMBER seconds.  SUFFIX may be 's' for seconds (the default),
'm' for minutes, 'h' for hours or 'd' for days.  Unlike most implementations
that require NUMBER be an integer, here NUMBER may be an arbitrary floating
point number.  Given two or more arguments, pause for the amount of time
specified by the sum of their values.]])
end

local function help(bad_arg)
  print("sleep: invalid option -- '"..tostring(bad_arg).."'")
  print("Try 'sleep --help' for more information.")
end

local function time_type_multiplier(time_type)
  if not time_type or #time_type == 0 or time_type == 's' then
    return 1
  elseif time_type == 'm' then
    return 60
  elseif time_type == 'h' then
    return 60 * 60
  elseif time_type == 'd' then
    return 60 * 60 * 24
  end

  -- weird error, my bad
  assert(false,'bug parsing parameter:'..tostring(time_type))
end

options.help = nil
if next(options) then
  help(next(options))
  return 1
end

local total_time = 0

for _,v in ipairs(args) do
  local interval = v:match('^%d+%.?%d*[smhd]?$')
  if not interval then
    help(v)
    return 1
  end

  local time_type = interval:match('[smhd]') or ''
  interval = interval:sub(1, -#time_type-1)
  interval = tonumber(interval)

  if interval < 0 then
    help(v)
    return 1
  end

  interval = time_type_multiplier(time_type) * interval
  total_time = total_time + interval
end

os.sleep(total_time)
Fbin/source.lua˚local shell = require("shell")
local fs = require("filesystem")
local sh = require("sh")

local args, options = shell.parse(...)

if #args ~= 1 then
  io.stderr:write("specify a single file to source\n");
  return 1
end

local file, reason = io.open(args[1], "r")

if not file then
  if not options.q then
    io.stderr:write(string.format("could not source %s because: %s\n", args[1], reason));
  end
  return 1
else
  local status, reason = xpcall(function()
    repeat
      local line = file:read("*L")
      if line then
        sh.execute(nil, line)
      end
    until not line
  end, function(msg) return {msg, debug.traceback()} end)

  file:close()
  if not status and reason then assert(false, tostring(reason[1]) .."\n".. tostring(reason[2])) end
end
Fbin/time.lualocal computer = require('computer')
local sh = require('sh')

local real_before, cpu_before = computer.uptime(), os.clock()
local cmd_result = 0
if ... then
  sh.execute(nil, ...) 
  cmd_result = sh.getLastExitCode()
end
local real_after, cpu_after = computer.uptime(), os.clock()

local real_diff = real_after - real_before
local cpu_diff = cpu_after - cpu_before

print(string.format('real%5dm%.3fs', math.floor(real_diff/60), real_diff%60))
print(string.format('cpu %5dm%.3fs', math.floor(cpu_diff/60), cpu_diff%60))

return cmd_result
Fbin/touch.luaX--[[Lua implementation of the UN*X touch command--]]
local shell = require("shell")
local fs =  require("filesystem")

local args, options = shell.parse(...)

local function usage()
  print(
[[Usage: touch [OPTION]... FILE...
Update the modification times of each FILE to the current time.
A FILE argument that does not exist is created empty, unless -c is supplied.

  -c, --no-create    do not create any files
      --help         display this help and exit]])
end

if options.help then
  usage()
  return 0
elseif #args == 0 then
  io.stderr:write("touch: missing operand\n")
  return 1
end

options.c = options.c or options["no-create"]
local errors = 0

for _,arg in ipairs(args) do
  local path = shell.resolve(arg)

  if fs.isDirectory(path) then
    io.stderr:write(string.format("`%s' ignored: directories not supported\n", arg))
  elseif fs.exists(path) or not options.c then
    local f, reason = io.open(path, "w")
    if not f then
      io.stderr:write(string.format("touch: cannot touch `%s': permission denied\n", arg))
      errors = 1
    else
      f:close()
    end
  end
end

return errors
Fbin/umount.lua;local fs = require("filesystem")
local shell = require("shell")

local args, options = shell.parse(...)

if #args < 1 then
  io.write("Usage: umount [-a] <mount>\n")
  io.write(" -a  Remove any mounts by file system label or address instead of by path. Note that the address may be abbreviated.\n")
  return 1
end

local proxy, reason
if options.a then
  proxy, reason = fs.proxy(args[1])
  if proxy then
    proxy = proxy.address
  end
else
  local path = shell.resolve(args[1])
  proxy, reason = fs.get(path)
  if proxy then
    proxy = reason -- = path
    if proxy ~= path then
      io.stderr:write("not a mount point\n")
      return 1
    end
  end
end
if not proxy then
  io.stderr:write(tostring(reason)..'\n')
  return 1
end

if not fs.umount(proxy) then
  io.stderr:write("nothing to unmount here\n")
  return 1
end
Fbin/unalias.luaqlocal shell = require("shell")

local args = shell.parse(...)
if #args < 1 then
  io.write("Usage: unalias <name>...\n")
  return 2
end
local e = 0

for _,arg in ipairs(args) do
  local result = shell.getAlias(arg)
  if not result then
    io.stderr:write(string.format("unalias: %s: not found\n", arg))
    e = 1
  else
    shell.setAlias(arg, nil)
  end
end
return e
Fbin/unset.lua£local args = {...}

if #args < 1 then
  io.write("Usage: unset <varname>[ <varname2> [...]]\n")
else
  for _, k in ipairs(args) do
    os.setenv(k, nil)
  end
end
Fbin/uptime.luaclocal computer = require("computer")

local seconds = math.floor(computer.uptime())
local minutes, hours = 0, 0
if seconds >= 60 then
  minutes = math.floor(seconds / 60)
  seconds = seconds % 60
end
if minutes >= 60 then
  hours = math.floor(minutes / 60)
  minutes = minutes % 60
end
io.write(string.format("%02d:%02d:%02d\n", hours, minutes, seconds))
Fbin/useradd.lualocal computer = require("computer")
local shell = require("shell")

local args = shell.parse(...)
if #args ~= 1 then
  io.write("Usage: useradd <name>\n")
  return 1
end

local result, reason = computer.addUser(args[1])
if not result then
  io.stderr:write(reason..'\n')
  return 1
end
Fbin/userdel.lualocal computer = require("computer")
local shell = require("shell")

local args = shell.parse(...)
if #args ~= 1 then
  io.write("Usage: userdel <name>\n")
  return 1
end

if not computer.removeUser(args[1]) then
  io.stderr:write("no such user\n")
  return 1
end
Fbin/wget.luaêlocal component = require("component")
local fs = require("filesystem")
local internet = require("internet")
local shell = require("shell")
local text = require("text")

if not component.isAvailable("internet") then
  io.stderr:write("This program requires an internet card to run.")
  return
end

local args, options = shell.parse(...)
options.q = options.q or options.Q

if #args < 1 then
  io.write("Usage: wget [-fq] <url> [<filename>]\n")
  io.write(" -f: Force overwriting existing files.\n")
  io.write(" -q: Quiet mode - no status messages.\n")
  io.write(" -Q: Superquiet mode - no error messages.")
  return
end

local url = text.trim(args[1])
local filename = args[2]
if not filename then
  filename = url
  local index = string.find(filename, "/[^/]*$")
  if index then
    filename = string.sub(filename, index + 1)
  end
  index = string.find(filename, "?", 1, true)
  if index then
    filename = string.sub(filename, 1, index - 1)
  end
end
filename = text.trim(filename)
if filename == "" then
  if not options.Q then
    io.stderr:write("could not infer filename, please specify one")
  end
  return nil, "missing target filename" -- for programs using wget as a function
end
filename = shell.resolve(filename)

local preexisted
if fs.exists(filename) then
  preexisted = true
  if not options.f then
    if not options.Q then
      io.stderr:write("file already exists")
    end
    return nil, "file already exists" -- for programs using wget as a function
  end
end

local f, reason = io.open(filename, "a")
if not f then
  if not options.Q then
    io.stderr:write("failed opening file for writing: " .. reason)
  end
  return nil, "failed opening file for writing: " .. reason -- for programs using wget as a function
end
f:close()
f = nil

if not options.q then
  io.write("Downloading... ")
end
local result, response = pcall(internet.request, url)
if result then
  local result, reason = pcall(function()
    for chunk in response do
      if not f then
        f, reason = io.open(filename, "wb")
        assert(f, "failed opening file for writing: " .. tostring(reason))
      end
      f:write(chunk)
    end
  end)
  if not result then
    if not options.q then
      io.stderr:write("failed.\n")
    end
    if f then
      f:close()
      if not preexisted then
        fs.remove(filename)
      end
    end
    if not options.Q then
      io.stderr:write("HTTP request failed: " .. reason .. "\n")
    end
    return nil, reason -- for programs using wget as a function
  end
  if not options.q then
    io.write("success.\n")
  end
  
  if f then
    f:close()
  end

  if not options.q then
    io.write("Saved data to " .. filename .. "\n")
  end
else
  if not options.q then
    io.write("failed.\n")
  end
  if not options.Q then
    io.stderr:write("HTTP request failed: " .. response .. "\n")
  end
  return nil, response -- for programs using wget as a function
end
return true -- for programs using wget as a function
Fbin/which.lua‡local shell = require("shell")

local args = shell.parse(...)
if #args == 0 then
  io.write("Usage: which <program>\n")
  return 255
end

for i = 1, #args do
  local result, reason = shell.resolve(args[i], "lua")
  
  if not result then
    result = shell.getAlias(args[i])
    if result then
      result = args[i] .. ": aliased to " .. result
    end
  end

  if result then
    print(result)
  else
    io.stderr:write(args[i] .. ": " .. reason .. "\n")
    return 1
  end
end
Fbin/yes.lua--[[Lua implementation of the UN*X yes command--]]
local shell = require("shell")

local args, options = shell.parse(...)

if options.V or options.version then
  io.write("yes v:1.0-3\n")
  io.write("Inspired by functionality of yes from GNU coreutils\n")
  return 0
end

if options.h or options.help then
  io.write("Usage: yes [string]...\n")
  io.write("OR:    yes [-V/h]\n")
  io.write("\n")
  io.write("yes prints the command line arguments, or 'y', until is killed.\n")
  io.write("\n")
  io.write("Options:\n")
  io.write("	-V, --version	Version\n")
  io.write("	-h, --help  	This help\n")
  return 0
end

local msg = #args == 0 and 'y' or table.concat(args, ' ')
msg = msg .. '\n'

while io.write(msg) do
  if io.stdout.tty then
    os.sleep(0)
  end
end
return 0
Dboot/Fboot/00_base.lua«function dofile(filename)
  local program, reason = loadfile(filename)
  if not program then
    return error(reason .. ':' .. filename, 0)
  end
  return program()
end

function loadfile(filename, mode, env)
  local file, reason = io.open(filename)
  if not file then
    return nil, reason
  end
  local source, reason = file:read("*a")
  file:close()
  if not source then
    return nil, reason
  end
  if string.sub(source, 1, 1) == "#" then
    local endline = string.find(source, "\n", 2, true)
    if endline then
      source = string.sub(source, endline + 1)
    else
      source = ""
    end
  end
  return load(source, "=" .. filename, mode, env)
end

function print(...)
  local args = table.pack(...)
  local stdout = io.stdout
  stdout:setvbuf("line")
  for i = 1, args.n do
    local arg = tostring(args[i])
    if i > 1 then
      arg = "\t" .. arg
    end
    stdout:write(arg)
  end
  stdout:write("\n")
  stdout:setvbuf("no")
  stdout:flush()
end
Fboot/01_process.luaßlocal process = require("process")

--Initialize coroutine library--
local _coroutine = coroutine -- real coroutine backend

_G.coroutine = {}
package.loaded.coroutine = _G.coroutine

for key,value in pairs(_coroutine) do
  if type(value) == "function" and value ~= "running" and value ~= "create" then
    _G.coroutine[key] = function(...)
      local thread = _coroutine.running()
      local info = process.info(thread)
      -- note the gc thread does not have a process info
      assert(info,"process not found for " .. tostring(thread))
      local data = info.data
      local co = data.coroutine_handler
      local handler = co[key]
      return handler(...)
    end
  else
    _G.coroutine[key] = value
  end
end

local init_thread = _coroutine.running()
local init_load = _G.load

_G.load = function(ld, source, mode, env)
  env = env or select(2, process.running())
  return init_load(ld, source, mode, env)
end

local kernel_create = _coroutine.create
_coroutine.create = function(f,standAlone)
  local co = kernel_create(f)
  if not standAlone then
    table.insert(process.findProcess().instances, co)
  end
  return co
end

_coroutine.wrap = function(f)
  local thread = coroutine.create(f)
  return function(...)
    local result_pack = table.pack(coroutine.resume(thread, ...))
    local result, reason = result_pack[1], result_pack[2]
    assert(result, reason)
    return select(2, table.unpack(result_pack))
  end
end

process.list[init_thread] = {
  path = "/init.lua",
  command = "init",
  env = _ENV,
  data =
  {
    vars={},
    io={}, --init will populate this
    coroutine_handler=setmetatable({}, {__index=_coroutine})
  },
  instances = setmetatable({}, {__mode="v"})
}
Fboot/02_os.luaÕlocal computer = require("computer")
local event = require("event")
local fs = require("filesystem")
local shell = require("shell")
local unicode = require("unicode")
local process = require("process")

local function env()
  return process.info().data.vars
end

os.execute = function(command)
  if not command then
    return type(shell) == "table"
  end
  return shell.execute(command)
end

function os.exit(code)
  error({reason="terminated", code=code}, 0)
end

function os.getenv(varname)
  if varname == '#' then
    return #env()
  elseif varname ~= nil then
    return env()[varname]
  else
    return env()
  end
end

function os.setenv(varname, value)
  checkArg(1, varname, "string", "number")
  if value == nil then
    env()[varname] = nil
  else
    local success, val = pcall(tostring, value)
    if success then
      env()[varname] = val
      return env()[varname]
    else
      return nil, val
    end
  end
end

function os.remove(...)
  return fs.remove(...)
end

function os.rename(...)
  return fs.rename(...)
end

function os.sleep(timeout)
  checkArg(1, timeout, "number", "nil")
  local deadline = computer.uptime() + (timeout or 0)
  repeat
    event.pull(deadline - computer.uptime())
  until computer.uptime() >= deadline
end

function os.tmpname()
  local path = os.getenv("TMPDIR") or "/tmp"
  if fs.exists(path) then
    for i = 1, 10 do
      local name = fs.concat(path, tostring(math.random(1, 0x7FFFFFFF)))
      if not fs.exists(name) then
        return name
      end
    end
  end
end

os.setenv("PATH", "/bin:/usr/bin:/home/bin:.")
os.setenv("TMP", "/tmp") -- Deprecated
os.setenv("TMPDIR", "/tmp")

if computer.tmpAddress() then
  fs.mount(computer.tmpAddress(), os.getenv("TMPDIR") or "/tmp")
end
Fboot/03_io.luaalocal buffer = require("buffer")
local term = require("term")

local io_open = io.open
function io.open(path, mode)
  return io_open(require("shell").resolve(path), mode)
end

local stdinStream = {handle="stdin"}
local stdoutStream = {handle="stdout"}
local stderrStream = {handle="stderr"}
local stdinHistory = {}

local function badFileDescriptor()
  return nil, "bad file descriptor"
end

function stdinStream:close()
  return nil, "cannot close standard file"
end
stdoutStream.close = stdinStream.close
stderrStream.close = stdinStream.close

function stdinStream:read(n, dobreak)
  stdinHistory.dobreak = dobreak
  local result = term.readKeyboard(stdinHistory)
  return result
end

function stdoutStream:write(str)
  term.drawText(str, self.wrap ~= false)
  return self
end

function stderrStream:write(str)
  local gpu = term.gpu()
  local set_depth = gpu and gpu.getDepth() and gpu.getDepth() > 1

  if set_depth then
    set_depth = gpu.setForeground(0xFF0000)
  end
    
  term.drawText(str, true)

  if set_depth then
    gpu.setForeground(set_depth)
  end

  return self
end

stdinStream.seek = badFileDescriptor
stdinStream.write = badFileDescriptor
stdoutStream.read = badFileDescriptor
stdoutStream.seek = badFileDescriptor
stderrStream.read = badFileDescriptor
stderrStream.seek = badFileDescriptor

local core_stdin = buffer.new("r", stdinStream)
local core_stdout = buffer.new("w", stdoutStream)
local core_stderr = buffer.new("w", stderrStream)

core_stdout:setvbuf("no")
core_stderr:setvbuf("no")
core_stdin.tty = true
core_stdout.tty = true
core_stderr.tty = true

core_stdin.close = stdinStream.close
core_stdout.close = stdinStream.close
core_stderr.close = stdinStream.close

local fd_map =
{
  -- key name => method name
  stdin = 'input',
  stdout = 'output',
  stderr = 'error'
}

local io_mt = getmetatable(io) or {}
io_mt.__index = function(t, k)
  if fd_map[k] then
    return io[fd_map[k]]()
  end
end
io_mt.__newindex = function(t, k, v)
  if fd_map[k] then
    io[fd_map[k]](v)
  else
    rawset(io, k, v)
  end
end

setmetatable(io, io_mt)

io.stdin = core_stdin
io.stdout = core_stdout
io.stderr = core_stderr
Fboot/04_component.lua)local component = require("component")
local computer = require("computer")
local event = require("event")

local adding = {}
local removing = {}
local primaries = {}

-------------------------------------------------------------------------------

-- This allows writing component.modem.open(123) instead of writing
-- component.getPrimary("modem").open(123), which may be nicer to read.
setmetatable(component, {
  __index = function(_, key)
    return component.getPrimary(key)
  end,
  __pairs = function(self)
    local parent = false
    return function(_, key)
      if parent then
        return next(primaries, key)
      else
        local k, v = next(self, key)
        if not k then
          parent = true
          return next(primaries)
        else
          return k, v
        end
      end
    end
  end
})

function component.get(address, componentType)
  checkArg(1, address, "string")
  checkArg(2, componentType, "string", "nil")
  for c in component.list(componentType, true) do
    if c:sub(1, address:len()) == address then
      return c
    end
  end
  return nil, "no such component"
end

function component.isAvailable(componentType)
  checkArg(1, componentType, "string")
  if not primaries[componentType] and not adding[componentType] then
    -- This is mostly to avoid out of memory errors preventing proxy
    -- creation cause confusion by trying to create the proxy again,
    -- causing the oom error to be thrown again.
    component.setPrimary(componentType, component.list(componentType, true)())
  end
  return primaries[componentType] ~= nil
end

function component.isPrimary(address)
  local componentType = component.type(address)
  if componentType then
    if component.isAvailable(componentType) then
      return primaries[componentType].address == address
    end
  end
  return false
end

function component.getPrimary(componentType)
  checkArg(1, componentType, "string")
  assert(component.isAvailable(componentType),
    "no primary '" .. componentType .. "' available")
  return primaries[componentType]
end

function component.setPrimary(componentType, address)
  checkArg(1, componentType, "string")
  checkArg(2, address, "string", "nil")
  if address ~= nil then
    address = component.get(address, componentType)
    assert(address, "no such component")
  end

  local wasAvailable = primaries[componentType]
  if wasAvailable and address == wasAvailable.address then
    return
  end
  local wasAdding = adding[componentType]
  if wasAdding and address == wasAdding.address then
    return
  end
  if wasAdding then
    event.cancel(wasAdding.timer)
  end
  primaries[componentType] = nil
  adding[componentType] = nil

  local primary = address and component.proxy(address) or nil
  if wasAvailable then
    computer.pushSignal("component_unavailable", componentType)
  end
  if primary then
    if wasAvailable or wasAdding then
      adding[componentType] = {
        address=address,
        timer=event.timer(0.1, function()
          adding[componentType] = nil
          primaries[componentType] = primary
          computer.pushSignal("component_available", componentType)
        end)
      }
    else
      primaries[componentType] = primary
      computer.pushSignal("component_available", componentType)
    end
  end
end

-------------------------------------------------------------------------------

for address in component.list('screen', true) do
  if #component.invoke(address,'getKeyboards') > 0 then
    component.setPrimary('screen',address)
  end
end

local function onComponentAdded(_, address, componentType)
  if not (primaries[componentType] or adding[componentType]) then
    component.setPrimary(componentType, address)
  end
end

local function onComponentRemoved(_, address, componentType)
  if primaries[componentType] and primaries[componentType].address == address or
     adding[componentType] and adding[componentType].address == address
  then
    component.setPrimary(componentType, component.list(componentType, true)())
  end
end

event.listen("component_added", onComponentAdded)
event.listen("component_removed", onComponentRemoved)
Fboot/10_devfs.lua¢require("filesystem").mount(
setmetatable({
  isReadOnly = function()return false end
},
{
  __index=function(tbl,key)return require("devfs")[key]end
}), "/dev")
Fboot/90_filesystem.lua†local component = require("component")
local event = require("event")
local fs = require("filesystem")
local shell = require("shell")

local isInitialized, pendingAutoruns = false, {}

local function onInit()
  isInitialized = true
  for _, run in ipairs(pendingAutoruns) do
    local result, reason = pcall(run)
    if not result then
      local path = fs.concat(os.getenv("TMPDIR") or "/tmp", "event.log")
      local log = io.open(path, "a")
      if log then
        log:write(reason .. "\n")
        log:close()
      end
    end
  end
  pendingAutoruns = nil
end

local function onComponentAdded(_, address, componentType)
  if componentType == "filesystem" then
    local proxy = component.proxy(address)
    if proxy then
      local name = address:sub(1, 3)
      while fs.exists(fs.concat("/mnt", name)) and
            name:len() < address:len() -- just to be on the safe side
      do
        name = address:sub(1, name:len() + 1)
      end
      name = fs.concat("/mnt", name)
      fs.mount(proxy, name)
      if fs.isAutorunEnabled() then
        local function run()
          local file = shell.resolve(fs.concat(name, "autorun"), "lua") or
                       shell.resolve(fs.concat(name, ".autorun"), "lua")
          if file then
            local result, reason = shell.execute(file, _ENV, proxy)
            if not result then
              error(reason, 0)
            end
          end
        end
        if isInitialized then
          run()
        else
          table.insert(pendingAutoruns, run)
        end
      end
    end
  end
end

local function onComponentRemoved(_, address, componentType)
  if componentType == "filesystem" then
    if fs.get(shell.getWorkingDirectory()).address == address then
      shell.setWorkingDirectory("/")
    end
    fs.umount(address)
  end
end

event.listen("init", onInit)
event.listen("component_added", onComponentAdded)
event.listen("component_removed", onComponentRemoved)
Fboot/91_gpu.lua@local component = require("component")
local event = require("event")

local function onComponentAvailable(_, componentType)
  if (componentType == "screen" and component.isAvailable("gpu")) or
     (componentType == "gpu" and component.isAvailable("screen"))
  then
    component.gpu.bind(component.screen.address)
    local depth = 2^(component.gpu.getDepth())
    os.setenv("TERM", "term-"..depth.."color")
    require("computer").pushSignal("gpu_bound", component.gpu.address, component.screen.address)
  end
end

event.listen("component_available", onComponentAvailable)
Fboot/92_keyboard.luaçlocal component = require("component")
local event = require("event")
local keyboard = require("keyboard")

local function onKeyDown(_, address, char, code)
  if keyboard.pressedChars[address] then
    keyboard.pressedChars[address][char] = true
    keyboard.pressedCodes[address][code] = true
  end
end

local function onKeyUp(_, address, char, code)
  if keyboard.pressedChars[address] then
    keyboard.pressedChars[address][char] = nil
    keyboard.pressedCodes[address][code] = nil
  end
end

local function onComponentAdded(_, address, componentType)
  if componentType == "keyboard" then
    keyboard.pressedChars[address] = {}
    keyboard.pressedCodes[address] = {}
  end
end

local function onComponentRemoved(_, address, componentType)
  if componentType == "keyboard" then
    keyboard.pressedChars[address] = nil
    keyboard.pressedCodes[address] = nil
  end
end

for address in component.list("keyboard", true) do
  onComponentAdded("component_added", address, "keyboard")
end

event.listen("key_down", onKeyDown)
event.listen("key_up", onKeyUp)
event.listen("component_added", onComponentAdded)
event.listen("component_removed", onComponentRemoved)
Fboot/93_term.lua)local component = require("component")
local computer = require("computer")
local event = require("event")
local term = require("term")
local process = require("process")

-- this should be the init level process
process.info().data.window = term.internal.open()

event.listen("gpu_bound", function(ename, gpu, screen)
  gpu=component.proxy(gpu)
  screen=component.proxy(screen)
  term.bind(gpu, screen)
  computer.pushSignal("term_available")
end)

event.listen("component_unavailable", function(_,type)
  if type == "screen" or type == "gpu" then
    if term.isAvailable() then
      local window = term.internal.window()
      if window[type] and not component.proxy(window[type].address) then
        window[type] = nil
      end
    end
    if not term.isAvailable() then
      computer.pushSignal("term_unavailable")
    end
  end
end)

event.listen("screen_resized", function(_,addr,w,h)
  local window = term.internal.window()
  if term.isAvailable(window) and window.screen.address == addr and window.fullscreen then
    window.w,window.h = w,h
  end
end)
Fboot/94_shell.luaÚlocal shell = require("shell")

require("event").listen("init", function()
  local file = io.open("/etc/hostname")
  if file then
    os.setenv("HOSTNAME", file:read("*l"))
    os.setenv("PS1", "$HOSTNAME:$PWD# ")
    file:close()
  end
end)
Fboot/99_rc.luaÅ-- Run all enabled rc scripts.
local shell = require("shell")
local rc = shell.resolve("rc", "lua")
if rc then 
  dofile(rc)
end
Detc/Fetc/filesystem.cfgautorun=trueFetc/motdp#!/bin/lua

local component = require("component")
local computer = require("computer")
local text = require("text")
local unicode = require("unicode")

if not component.isAvailable("gpu") then
	return
end

local gpu = component.gpu
local xSize, ySize = gpu.getResolution()
local oldBackground = gpu.getBackground()
local oldForeground = gpu.getForeground()

local lines = { "OpenOS (customized by ECS), " .. math.floor(computer.totalMemory() / 1024) .. "KB RAM"}
local maxWidth = unicode.len(lines[1])
local f = io.open("/usr/misc/greetings/" .. _G.OSSettings.language .. ".txt")
if f then
	local greetings = {}
	pcall(function()
		for line in f:lines() do table.insert(greetings, line) end
	end)
	f:close()
	local greeting = greetings[math.random(1, #greetings)]
	if greeting then
		local width = math.max(10, component.gpu.getResolution())
		for line in text.wrappedLines(greeting, width - 4, width - 4) do
			table.insert(lines, line)
			maxWidth = math.max(maxWidth, unicode.len(line))
		end
	end
end
local borders = {{unicode.char(0x2552), unicode.char(0x2550), unicode.char(0x2555)},
								 {unicode.char(0x2502), nil, unicode.char(0x2502)},
								 {unicode.char(0x2514), unicode.char(0x2500), unicode.char(0x2518)}}


gpu.setBackground(0xcccccc)
gpu.fill(1, 1, xSize, #lines + 2, " ")

io.write(" \n")
io.write("")
gpu.setForeground(0x000000)
io.write("  " .. text.padRight(lines[1], maxWidth) .. "  \n")
table.remove(lines, 1)
gpu.setForeground(0x555555)
for _, line in ipairs(lines) do
	io.write("  " .. text.padRight(line, maxWidth) .. "  \n")
end
io.write(" \n\n")

gpu.setBackground(oldBackground)
gpu.setForeground(oldForeground)
Fetc/profile€alias dir=ls
alias list=ls
alias move=mv
alias rename=mv
alias copy=cp
alias del=rm
alias md=mkdir
alias cls=clear
alias less=more
alias rs=redstone
alias view=edit\ -r
alias help=man
alias cp=cp\ -i

set EDITOR=/bin/edit
set HISTSIZE=10
set HOME=/
set IFS=\ 
set MANPATH=/usr/man:.
set PAGER=/bin/more
set PS1='$PWD# '
set PWD=/
set SHELL=/bin/sh 
set LS_COLORS="{FILE=0xFFFFFF,DIR=0x66CCFF,LINK=0xFFAA00,['*.lua']=0x00FF00}"

cd $HOME
clear
/etc/motd
source $HOME/.shrc -q
F
etc/rc.cfg'enabled = {}

example = "Hello World!"
D	etc/rc.d/Fetc/rc.d/example.luahlocal count = 0

function start(msg)
  print("This script displays a welcome message and counts the number " ..
  "of times it has been called. The welcome message can be set in the " ..
  "config file /etc/rc.cfg")
  print(args)
  if msg then
    print(msg)
  end
  print(count)
  print("runlevel: " .. require("computer").runlevel())
  count = count + 1
end
FfilesystemPacker.lua1
local args = {...}
local fs = require("filesystem")
local compressor = require("compressor")

if args[1] == "pack" and args[2] then
	local fileList = {}
	for file in fs.list("/") do
		table.insert(fileList, "/" .. file)
	end
	fileList[#fileList + 1] = true

	compressor.pack(args[2], table.unpack(fileList))
elseif args[2] == "unpack" and args[2] and fs.exists(args[2]) then
	compressor.unpack(args[2], "/", true)
else
	print("Usage:")
	print("  filesystemPacker pack <package path>")
	print("  filesystemPacker unpack <package path>")
end
Dhome/F
home/.shrcSalias l="ls -lh"
alias ..="cd .."
alias df="df -h"

alias grep="grep --color"
Finit.luaflocal background, foreground, logoColor = 0xDDDDDD, 0x999999, 0x444444

do
  _G._OSVERSION = "OpenOS 1.6"

  local component = component
  local computer = computer
  local unicode = unicode

  -- Runlevel information.
  local runlevel, shutdown = "S", computer.shutdown
  computer.runlevel = function() return runlevel end
  computer.shutdown = function(reboot)
    runlevel = reboot and 6 or 0
    if os.sleep then
      computer.pushSignal("shutdown")
      os.sleep(0.1) -- Allow shutdown processing.
    end
    shutdown(reboot)
  end

  -- Low level dofile implementation to read filesystem libraries.
  local rom = {}
  function rom.invoke(method, ...)
    return component.invoke(computer.getBootAddress(), method, ...)
  end
  function rom.open(file) return rom.invoke("open", file) end
  function rom.read(handle) return rom.invoke("read", handle, math.huge) end
  function rom.close(handle) return rom.invoke("close", handle) end
  function rom.inits() return ipairs(rom.invoke("list", "boot")) end
  function rom.isDirectory(path) return rom.invoke("isDirectory", path) end

  local screen = component.list('screen', true)()
  for address in component.list('screen', true) do
    if #component.invoke(address, 'getKeyboards') > 0 then
      screen = address
    end
  end

  -- Report boot progress if possible.
  local gpu = component.list("gpu", true)()
  local w, h
  if gpu and screen then
    component.invoke(gpu, "bind", screen)
    w, h = component.invoke(gpu, "maxResolution")
    component.invoke(gpu, "setResolution", w, h)
    component.invoke(gpu, "setBackground", background)
    component.invoke(gpu, "setForeground", foreground)
    component.invoke(gpu, "fill", 1, 1, w, h, " ")
  end

  local function centerText(y, text, color)
    if gpu and screen then
      local msgWidth = unicode.len(text)
      local x = math.floor(w / 2 - msgWidth / 2)
      component.invoke(gpu, "fill", 1, y, w, 1, " ")
      component.invoke(gpu, "setForeground", color)
      component.invoke(gpu, "set", x, y, text)
    end
  end

  local y = math.floor(h / 2 - 1)

  local function status(text)
    centerText(y, "MineOS", logoColor)
    centerText(y + 1, text, foreground)
  end

  status("Booting " .. _OSVERSION .. "...")

  -- Custom low-level loadfile/dofile implementation reading from our ROM.
  local function loadfile(file)
    status("Loading " .. file)
    local handle, reason = rom.open(file)
    if not handle then
      error(reason)
    end
    local buffer = ""
    repeat
      local data, reason = rom.read(handle)
      if not data and reason then
        error(reason)
      end
      buffer = buffer .. (data or "")
    until not data
    rom.close(handle)
    return load(buffer, "=" .. file)
  end

  local function dofile(file)
    local program, reason = loadfile(file)
    if program then
      local result = table.pack(pcall(program))
      if result[1] then
        return table.unpack(result, 2, result.n)
      else
        error(result[2])
      end
    else
      error(reason)
    end
  end

  status("Initializing package management")

  -- Load file system related libraries we need to load other stuff moree
  -- comfortably. This is basically wrapper stuff for the file streams
  -- provided by the filesystem components.
  local package = dofile("/lib/package.lua")

  do
    -- Unclutter global namespace now that we have the package module.
    _G.component = nil
    _G.computer = nil
    _G.process = nil
    _G.unicode = nil

    -- Initialize the package module with some of our own APIs.
    package.loaded.component = component
    package.loaded.computer = computer
    package.loaded.unicode = unicode
    package.preload["buffer"] = loadfile("/lib/buffer.lua")
    package.preload["filesystem"] = loadfile("/lib/filesystem.lua")

    -- Inject the package and io modules into the global namespace, as in Lua.
    _G.package = package
    _G.io = loadfile("/lib/io.lua")()

    --mark modules for delay loaded api
    -- package.delayed["text"] = true
    -- package.delayed["sh"] = true
    -- package.delayed["transforms"] = true
    -- package.delayed["term"] = true
  end

  status("Initializing file system")

  -- Mount the ROM and temporary file systems to allow working on the file
  -- system module from this point on.
  require("filesystem").mount(computer.getBootAddress(), "/")
  package.preload={}

  status("Running boot scripts")

  -- Run library startup scripts. These mostly initialize event handlers.
  local scripts = {}
  for _, file in rom.inits() do
    local path = "boot/" .. file
    if not rom.isDirectory(path) then
      table.insert(scripts, path)
    end
  end
  table.sort(scripts)
  for i = 1, #scripts do
    dofile(scripts[i])
  end

  status("Initializing components")

  local primaries = {}
  for c, t in component.list() do
    local s = component.slot(c)
    if not primaries[t] or (s >= 0 and s < primaries[t].slot) then
      primaries[t] = {address=c, slot=s}
    end
    computer.pushSignal("component_added", c, t)
  end
  for t, c in pairs(primaries) do
    component.setPrimary(t, c.address)
  end
end

-- MineOS Init data
do
  -- –ó–∞–≥—Ä—É–∂–∞–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏, –¥–∞–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ø–æ—Ç–µ—Ä—å –ø–∞–º—è—Ç–∏
  local shell = require("shell"); shell.setWorkingDirectory("")
  local ecs = require("ECSAPI")
  local component = require("component")

  -- –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –û–°
  ecs.loadOSSettings()
  _G._OSLANGUAGE = _G.OSSettings.language

  -- –í—ã—Å—Ç–∞–≤–ª—è–µ–º –∞–¥–µ–∫–≤–∞—Ç–Ω—ã–π –º–∞—Å—à—Ç–∞–± –º–æ–Ω–∏—Ç–æ—Ä–∞
  ecs.fadeOut(background, 0x1b1b1b, 0.05)
  -- component.gpu.setBackground(background)
  component.gpu.fill(1, 1, 160, 50, " ")
  ecs.setScale(1)

  -- –ó–∞–≤–µ—Ä—à–∞–µ–º —Ä–∞–±–æ—Ç—É —Å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–µ–π
  os.sleep(0.1) -- Allow signal processing by libraries.
  require("computer").pushSignal("init")
  os.sleep(0.1) -- Allow init processing.
  runlevel = 1
end

while true do
  local result, reason = pcall(loadfile("bin/sh.lua"))
  if not result then
    io.stderr:write((reason ~= nil and tostring(reason) or "unknown error") .. "\n")
    io.write("Press any key to continue.\n")
    os.sleep(0.5)
    require("event").pull("key")
  end
end
Dlib/Flib/ECSAPI.luaUP

local advancedLua = require("advancedLua")
local component = require("component")
local term = require("term")
local unicode = require("unicode")
local event = require("event")
local fs = require("filesystem")
local shell = require("shell")
local keyboard = require("keyboard")
local computer = require("computer")
local serialization = require("serialization")


local gpu = component.gpu
local ecs = {}

----------------------------------------------------------------------------------------------------

ecs.windowColors = {
	background = 0xeeeeee,
	usualText = 0x444444,
	subText = 0x888888,
	tab = 0xaaaaaa,
	title = 0xffffff,
	shadow = 0x444444,
}

ecs.colors = {
	white = 0xffffff,
	orange = 0xF2B233,
	magenta = 0xE57FD8,
	lightBlue = 0x99B2F2,
	yellow = 0xDEDE6C,
	lime = 0x7FCC19,
	pink = 0xF2B2CC,
	gray = 0x4C4C4C,
	lightGray = 0x999999,
	cyan = 0x4C99B2,
	purple = 0xB266E5,
	blue = 0x3366CC,
	brown = 0x7F664C,
	green = 0x57A64E,
	red = 0xCC4C4C,
    black = 0x000000,
	["0"] = 0xffffff,
	["1"] = 0xF2B233,
	["2"] = 0xE57FD8,
	["3"] = 0x99B2F2,
	["4"] = 0xDEDE6C,
	["5"] = 0x7FCC19,
	["6"] = 0xF2B2CC,
	["7"] = 0x4C4C4C,
	["8"] = 0x999999,
	["9"] = 0x4C99B2,
	["a"] = 0xB266E5,
	["b"] = 0x3366CC,
	["c"] = 0x7F664C,
	["d"] = 0x57A64E,
	["e"] = 0xCC4C4C,
	["f"] = 0x000000
}

----------------------------------------------------------------------------------------------------

--–ê–¥–µ–∫–≤–∞—Ç–Ω—ã–π –∑–∞–ø—Ä–æ—Å –∫ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä—É –≤–º–µ—Å—Ç–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–≥–æ Internet API, –±—Ä–æ—Å–∞—é—â–µ–≥–æ stderr, –∫–æ–≥–¥–∞ –µ–º—É –≤–∑–¥—É–º–∞–µ—Ç—Å—è
function ecs.internetRequest(url)
	local success, response = pcall(component.internet.request, url)
	if success then
		local responseData = ""
		while true do
			local data, responseChunk = response.read()	
			if data then
				responseData = responseData .. data
			else
				if responseChunk then
					return false, responseChunk
				else
					return true, responseData
				end
			end
		end
	else
		return false, reason
	end
end

--–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞ —Å –∏–Ω–µ—Ç–∞
function ecs.getFileFromUrl(url, path)
	local success, response = ecs.internetRequest(url)
	if success then
		fs.makeDirectory(fs.path(path) or "")
		local file = io.open(path, "w")
		file:write(response)
		file:close()
	else
		ecs.error("Could not connect to to URL address \"" .. url .. "\"")
		return
	end
end

--–û—Ç–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º
function ecs.disableInterrupting()
	_G.eventInterruptBackup = package.loaded.event.shouldInterrupt 
	_G.eventSoftInterruptBackup = package.loaded.event.shouldSoftInterrupt 
	
	package.loaded.event.shouldInterrupt = function () return false end
	package.loaded.event.shouldSoftInterrupt = function () return false end
end

--–í–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º
function ecs.enableInterrupting()
	if _G.eventInterruptBackup then
		package.loaded.event.shouldInterrupt = _G.eventInterruptBackup 
		package.loaded.event.shouldSoftInterrupt = _G.eventSoftInterruptBackup
	else
		error("Cant't enable interrupting beacause of it's already enabled.")
	end
end

function ecs.getScaledResolution(scale, debug)
	--–ë–∞–∑–æ–≤–∞—è –∫–æ—Ä—Ä–µ–∫—Ü–∏—è –º–∞—Å—à—Ç–∞–±–∞, —á—Ç–æ–±—ã –≤—Å—è–∫–∏–µ —É–º–Ω–∏–∫–∏ –Ω–µ –ø–∏—Å–∞–ª–∏ —Å–≤–æ–∏–º–∏ –ø–æ–≥–∞–Ω—ã–º–∏ —Ä—É—á–æ–Ω–∫–∞–º–∏, —á–µ–≥–æ –Ω–µ —Å–ª–µ–¥—É–µ—Ç
	if scale > 1 then
		scale = 1
	elseif scale < 0.1 then
		scale = 0.1
	end

	--–ü—Ä–æ—Å—á–µ—Ç –º–æ–Ω–∏—Ç–æ—Ä–∞ –≤ –ø—Å–µ–≤–¥–æ–ø–∏–∫—Å–µ–ª—è—Ö - –∑–∞–±–µ–π, –¥–∞–∂–µ –æ–±—ä—è—Å–Ω—è—Ç—å –Ω–µ –±—É–¥—É, —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–∞–∫ —á–∞—Å—ã
	local function calculateAspect(screens)
	  local abc = 12

	  if screens == 2 then
	    abc = 28
	  elseif screens > 2 then
	    abc = 28 + (screens - 2) * 16
	  end

	  return abc
	end

	--–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø—Ä–æ–ø–æ—Ä—Ü–∏—é –º–æ–Ω–∏—Ç–æ—Ä–∞ –≤ –ø—Å–µ–≤–¥–æ–ø–∏–∫—Å–µ–ª—è—Ö
	local xScreens, yScreens = component.proxy(component.gpu.getScreen()).getAspectRatio()
	local xPixels, yPixels = calculateAspect(xScreens), calculateAspect(yScreens)
	local proportion = xPixels / yPixels

	--–ü–æ–ª—É—á–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≤–æ–∑–º–æ–∂–Ω–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –¥–∞–Ω–Ω–æ–π –≤–∏–¥–µ–æ–∫–∞—Ä—Ç—ã
	local xMax, yMax = component.gpu.maxResolution()

	--–ü–æ–ª—É—á–∞–µ–º —Ç–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–æ–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –º–æ–Ω–∏—Ç–æ—Ä–∞ —Å —É—á–µ—Ç–æ–º –µ–≥–æ –ø—Ä–æ–ø–æ—Ä—Ü–∏–∏, –Ω–æ –±–µ–∑ —É—á–µ—Ç–∞ –ª–∏–º–∏—Ç–∞ –≤–∏–¥–µ–æ–∫–∞—Ä—Ç—ã
	local newWidth, newHeight
	if proportion >= 1 then
		newWidth = xMax
		newHeight = math.floor(newWidth / proportion / 2)
	else
		newHeight = yMax
		newWidth = math.floor(newHeight * proportion * 2)
	end

	--–ü–æ–ª—É—á–∞–µ–º –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ –º–æ–Ω–∏—Ç–æ—Ä–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –≤–∏–¥–µ–æ–∫–∞—Ä—Ç—ã
	local optimalNewWidth, optimalNewHeight = newWidth, newHeight

	if optimalNewWidth > xMax then
		local difference = newWidth / xMax
		optimalNewWidth = xMax
		optimalNewHeight = math.ceil(newHeight / difference)
	end

	if optimalNewHeight > yMax then
		local difference = newHeight / yMax
		optimalNewHeight = yMax
		optimalNewWidth = math.ceil(newWidth / difference)
	end

	--–ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –∏–¥–µ–∞–ª—å–Ω–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –ø–æ –∑–∞–¥–∞–Ω–Ω–æ–º—É –º–∞—Å—à—Ç–∞–±—É
	local finalNewWidth, finalNewHeight = math.floor(optimalNewWidth * scale), math.floor(optimalNewHeight * scale)

	--–í—ã–≤–æ–¥–∏–º –∏–Ω—Ñ—É, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
	if debug then
		print(" ")
		print("–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ: "..xMax.."x"..yMax)
		print("–ü—Ä–æ–ø–æ—Ä—Ü–∏—è –º–æ–Ω–∏—Ç–æ—Ä–∞: "..xPixels.."x"..yPixels)
		print("–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –ø—Ä–æ–ø–æ—Ä—Ü–∏–∏: "..proportion)
		print(" ")
		print("–¢–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ: "..newWidth.."x"..newHeight)
		print("–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ: "..optimalNewWidth.."x"..optimalNewHeight)
		print(" ")
		print("–ù–æ–≤–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ: "..finalNewWidth.."x"..finalNewHeight)
		print(" ")
	end

	return finalNewWidth, finalNewHeight
end

--–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–∞—Å—à—Ç–∞–±–∞ –º–æ–Ω–∏—Ç–æ—Ä–∞
function ecs.setScale(scale, debug)
	--–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ
	component.gpu.setResolution(ecs.getScaledResolution(scale, debug))
end

function ecs.rebindGPU(address)
	component.gpu.bind(address)
end

--–ü–æ–ª—É—á–∞–µ–º –≤—Å—é –∏–Ω—Ñ—É –æ–± –æ–ø–µ—Ä–∞—Ç–∏–≤–∫—É –≤ –∫–∏–ª–æ–±–∞–π—Ç–∞—Ö
function ecs.getInfoAboutRAM()
	local free = math.floor(computer.freeMemory() / 1024)
	local total = math.floor(computer.totalMemory() / 1024)
	local used = total - free

	return free, total, used
end

--–ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∂–µ—Å—Ç–∫–∏—Ö –¥–∏—Å–∫–∞—Ö
function ecs.getHDDs()
	local candidates = {}
	for address in component.list("filesystem") do
	  local proxy = component.proxy(address)
	  if proxy.address ~= computer.tmpAddress() and proxy.getLabel() ~= "internet" then
	    local isFloppy, spaceTotal = false, math.floor(proxy.spaceTotal() / 1024)
	    if spaceTotal < 600 then isFloppy = true end
	    table.insert(candidates, {
	    	["spaceTotal"] = spaceTotal,
	    	["spaceUsed"] = math.floor(proxy.spaceUsed() / 1024),
	    	["label"] = proxy.getLabel(),
	    	["address"] = proxy.address,
	    	["isReadOnly"] = proxy.isReadOnly(),
	    	["isFloppy"] = isFloppy,
	    })
	  end
	end
	return candidates
end

--–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å –¥–∏—Å–∫
function ecs.formatHDD(address)
	local proxy = component.proxy(address)
	local list = proxy.list("")
	ecs.info("auto", "auto", "", "Formatting disk...")
	for _, file in pairs(list) do
		if type(file) == "string" then
			if not proxy.isReadOnly(file) then proxy.remove(file) end
		end
	end
	list = nil
end

--–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∏–º—è –∂–µ—Å—Ç–∫–æ–≥–æ –¥–∏—Å–∫–∞
function ecs.setHDDLabel(address, label)
	local proxy = component.proxy(address)
	proxy.setLabel(label or "Untitled")
end

--–ù–∞–π—Ç–∏ –º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø—É—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∞–¥—Ä–µ—Å–∞ –¥–∏—Å–∫–∞
function ecs.findMount(address)
  for fs1, path in fs.mounts() do
    if fs1.address == component.get(address) then
      return path
    end
  end
end

function ecs.getArraySize(array)
	local size = 0
	for key in pairs(array) do
		size = size + 1
	end
	return size
end

--–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª—ã —Å –æ–¥–Ω–æ–≥–æ –¥–∏—Å–∫–∞ –Ω–∞ –¥—Ä—É–≥–æ–π —Å –∑–∞–º–µ–Ω–æ–π
function ecs.duplicateFileSystem(fromAddress, toAddress)
	local source, destination = ecs.findMount(fromAddress), ecs.findMount(toAddress)
	ecs.info("auto", "auto", "", "Copying file system...")
	shell.execute("bin/cp -rx "..source.."* "..destination)
end

--–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞ —Å –ø–∞—Å—Ç–µ–±–∏–Ω–∞
function ecs.getFromPastebin(paste, path)
	local url = "http://pastebin.com/raw.php?i=" .. paste
	ecs.getFileFromUrl(url, path)
end

--–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞ —Å –≥–∏—Ç—Ö–∞–±–∞
function ecs.getFromGitHub(url, path)
	url = "https://raw.githubusercontent.com/" .. url
	ecs.getFileFromUrl(url, path)
end

--–ó–∞–≥—Ä—É–∑–∏—Ç—å –û–°-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
function ecs.getOSApplication(application)
    --–ï—Å–ª–∏ —ç—Ç–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    if application.type == "Application" then
		--–£–¥–∞–ª—è–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ, –µ—Å–ª–∏ –æ–Ω–æ —É–∂–µ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–ª–æ –∏ —Å–æ–∑–¥–∞–µ–º –≤—Å–µ –Ω—É–∂–Ω—ã–µ –ø–∞–ø–æ—á–∫–∏
		application.name = "/" .. application.name
		fs.remove(application.name .. ".app")
		fs.makeDirectory(application.name .. ".app/Resources")
		
		--–ó–∞–≥—Ä—É–∂–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª –∏ –∏–∫–æ–Ω–∫—É
		ecs.getFromGitHub(application.url, application.name .. ".app/" .. fs.name(application.name .. ".lua"))
		ecs.getFromGitHub(application.icon, application.name .. ".app/Resources/Icon.pic")

		--–ï—Å–ª–∏ –µ—Å—Ç—å —Ä–µ—Å—É—Ä—Å—ã, —Ç–æ –∑–∞–≥—Ä—É–∂–∞–µ–º —Ä–µ—Å—É—Ä—Å—ã
		if application.resources then
			for i = 1, #application.resources do
				ecs.getFromGitHub(application.resources[i].url, application.name .. ".app/Resources/" .. application.resources[i].name)
			end
		end

		--–ï—Å–ª–∏ –µ—Å—Ç—å —Ñ–∞–π–ª "–æ –ø—Ä–æ–≥—Ä–∞–º–º–µ", —Ç–æ –≥—Ä—É–∑–∏–º –∏ –µ–≥–æ
		if application.about then
			ecs.getFromGitHub(application.about .. _G.OSSettings.language .. ".txt", application.name .. ".app/Resources/About/" .. _G.OSSettings.language .. ".txt")
		end 

		--–ï—Å–ª–∏ –∏–º–µ–µ—Ç—Å—è —Ä–µ–∂–∏–º —Å–æ–∑–¥–∞–Ω–∏—è —è—Ä–ª—ã–∫–∞, —Ç–æ —Å–æ–∑–¥–∞–µ–º –µ–≥–æ
		if application.createShortcut then
			local desktopPath = "MineOS/Desktop/"
			
			if application.createShortcut == "desktop" then
				ecs.createShortCut(desktopPath .. fs.name(application.name) .. ".lnk", application.name .. ".app")
			end
		end

	--–ï—Å–ª–∏ —Ç–∏–ø = –¥—Ä—É–≥–æ–π, —á—É–∂–æ–π, –∞ –º–± –∏ —Å–≤–æ–π –ø–∞—Å—Ç–µ–±–∏–Ω
	elseif application.type == "Pastebin" then
		ecs.getFromPastebin(application.url, application.name)
		
	--–ï—Å–ª–∏ –ø—Ä–æ—Å—Ç–æ –∫–∞–∫–æ–π-—Ç–æ —Å–∫—Ä–∏–ø—Ç
	elseif application.type == "Script" or application.type == "Library" or application.type == "Icon" or application.type == "Wallpaper" then
		ecs.getFromGitHub(application.url, application.name)
	
	--–ê –µ—Å–ª–∏ –≤–∞—â–µ –∫–∞–∫–∞—è-—Ç–æ –∞–±—Å—Ç—Ä–∞–∫—Ç–Ω–∞—è —Ö—É–π–Ω—è, –ª–∏–±–æ —Å—Å—ã–ª–∫–∞ –Ω–∞ –≤–µ–±, —Ç–æ –∑–∞–≥—Ä—É–∂–∞–µ–º –ø–æ –£–†–õ-–∫–µ
	else
		ecs.getFileFromUrl(application.url, application.name)
	end
end

--–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π, –∫–æ—Ç–æ—Ä—ã–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è –æ–±–Ω–æ–≤–∏—Ç—å
function ecs.getAppsToUpdate(debug)
	--–ó–∞–¥–∞–µ–º —Å—Ç–∞—Ä—Ç–æ–≤—ã–µ –ø—É—Ç–∏
	local pathToApplicationsFile = "MineOS/System/OS/Applications.txt"
	local pathToSecondApplicationsFile = "MineOS/System/OS/Applications2.txt"
	--–ü—É—Ç—å –∫ —Ñ–∞–π–ª-–ª–∏—Å—Ç—É –Ω–∞ –ø–∞—Å—Ç–µ–±–∏–Ω–µ
	local paste = "3j2x4dDn"
	--–í—ã–≤–æ–¥–∏–º –∏–Ω—Ñ—É
	local oldPixels
	if debug then oldPixels = ecs.info("auto", "auto", " ", "Checking for updates...") end
	--–ü–æ–ª—É—á–∞–µ–º —Å–≤–µ–∂–µ–Ω—å–∫–∏–π —Ñ–∞–π–ª
	ecs.getFromPastebin(paste, pathToSecondApplicationsFile)
	--–ß–∏—Ç–∞–µ–º –æ–±–∞ —Ñ–∞–π–ª–∞
	local file = io.open(pathToApplicationsFile, "r")
	local applications = serialization.unserialize(file:read("*a"))
	file:close()
	--–ò –≤—Ç–æ—Ä–æ–π
	file = io.open(pathToSecondApplicationsFile, "r")
	local applications2 = serialization.unserialize(file:read("*a"))
	file:close()

	local countOfUpdates = 0

	--–ü—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞–µ–º —Å–≤–µ–∂–µ–Ω—å–∫–∏–π —Ñ–∞–π–ª–∏–∫ –∏ –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º, —á–µ –≤ –Ω–µ–º –Ω–æ–≤–æ–≥–æ, –≤—Å–µ —Å—Ç–∞—Ä–æ–µ —É–¥–∞–ª—è–µ–º
	local i = 1
	while true do
		--–†–∞–∑—Ä—ã–≤ —Ü–∏–∫–ª–∞
		if i > #applications2 then break end
		--–ù–æ–≤–∞—è –≤–µ—Ä—Å–∏—è —Ñ–∞–π–ª–∞
		local newVersion, oldVersion = applications2[i].version, 0
		--–ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ä—É—é –≤–µ—Ä—Å–∏—é —ç—Ç–æ–≥–æ —Ñ–∞–π–ª–∞
		for j = 1, #applications do
			if applications2[i].name == applications[j].name then
				oldVersion = applications[j].version or 0
				break
			end
		end
		--–ï—Å–ª–∏ –Ω–æ–≤–∞—è –≤–µ—Ä—Å–∏—è –Ω–æ–≤–µ–µ, —á–µ–º —Å—Ç–∞—Ä–∞—è, —Ç–æ –¥–æ–±–∞–≤–∏—Ç—å –≤ –º–∞—Å—Å–∏–≤ —Ç–æ, —á—Ç–æ –Ω—É–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å
		if newVersion > oldVersion then
			applications2[i].needToUpdate = true
			countOfUpdates = countOfUpdates + 1
		end

		i = i + 1
	end
	--–ï—Å–ª–∏ —á–µ—Ç —Ä–∏—Å–æ–≤–∞–ª–æ—Å—å, —Ç–æ —Å—Ç–µ—Ä–µ—Ç—å –Ω–∞ —Ö–µ—Ä
	if oldPixels then ecs.drawOldPixels(oldPixels) end
	--–í–æ–∑–≤—Ä–∞—â–∞–µ–º –º–∞—Å—Å–∏–≤ —Å —Ç–µ–º, —á–µ –Ω—É–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å –∏ –ø—Ä–æ—Å—Ç–æ —Å—Ç–∞—Ä—ã–π –∞–ø–ø–ª–∏–∫–∞—à–Ω—Å –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
	return applications2, countOfUpdates
end

--–°–¥–µ–ª–∞—Ç—å —Å—Ç—Ä–æ–∫—É –ø—Ä–∏–≥–æ–¥–Ω–æ–π –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –û–ø–µ–Ω–ö–æ–º–ø–∞—Ö
--–ó–∞–º–µ–Ω—è–µ—Ç —Ç–∞–±—Å—ã –Ω–∞ –ø—Ä–æ–±–µ–ª—ã –∏ –≤–∏–Ω–¥–æ–≤—ã–π –≤–æ–∑–≤—Ä–∞—Ç –∫–∞—Ä–µ—Ç–∫–∏ –Ω–∞ —á–µ–ª–æ–≤–µ—á–µ—Å–∫–∏–π UNIX-–æ–≤—Å–∫–∏–π
function ecs.stringOptimize(sto4ka, indentatonWidth)
    sto4ka = string.gsub(sto4ka, "\r\n", "\n")
    sto4ka = string.gsub(sto4ka, "	", string.rep(" ", indentatonWidth or 2))
    return stro4ka
end

--–ò–ó –î–ï–°–Ø–¢–ò–ß–ù–û–ô –í –®–ï–°–¢–ù–ê–î–¶–ê–¢–ò–†–ò–ß–ù–£–Æ
function ecs.decToBase(IN,BASE)
    local hexCode = "0123456789ABCDEFGHIJKLMNOPQRSTUVW"
    OUT = ""
    local ostatok = 0
    while IN>0 do
        ostatok = math.fmod(IN,BASE) + 1
        IN = math.floor(IN/BASE)
        OUT = string.sub(hexCode,ostatok,ostatok)..OUT
    end
    if #OUT == 1 then OUT = "0"..OUT end
    if OUT == "" then OUT = "00" end
    return OUT
end

--–ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ HEX-–ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –≤ —Å—Ç—Ä–æ–∫–æ–≤—É—é
function ecs.HEXtoString(color, bitCount, withNull)
	local stro4ka = string.format("%X",color)
	local sStro4ka = unicode.len(stro4ka)
	if sStro4ka < bitCount then
		stro4ka = string.rep("0", bitCount - sStro4ka) .. stro4ka
	end
	sStro4ka = nil
	if withNull then return "0x"..stro4ka else return stro4ka end
end

--–ö–õ–ò–ö–ù–£–õ–ò –õ–ò –í –ó–û–ù–£
function ecs.clickedAtArea(x,y,sx,sy,ex,ey)
  if (x >= sx) and (x <= ex) and (y >= sy) and (y <= ey) then return true end    
  return false
end

--–ó–∞–ª–∏–≤–∫–∞ –≤—Å–µ–≥–æ —ç–∫—Ä–∞–Ω–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–º —Ü–≤–µ—Ç–æ–º
function ecs.clearScreen(color)
  if color then component.gpu.setBackground(color) end
  term.clear()
end

--–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–∏–∫—Å–µ–ª—è –Ω—É–∂–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞
function ecs.setPixel(x,y,color)
  component.gpu.setBackground(color)
  component.gpu.set(x,y," ")
end

--–ü—Ä–æ—Å—Ç–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ü–≤–µ—Ç–æ–≤ –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É, –∏–±–æ —è –ª–µ–Ω–∏–≤—ã–π
function ecs.setColor(background, foreground)
	component.gpu.setBackground(background)
	component.gpu.setForeground(foreground)
end

--–¶–≤–µ—Ç–Ω–æ–π —Ç–µ–∫—Å—Ç
function ecs.colorText(x,y,textColor,text)
  component.gpu.setForeground(textColor)
  component.gpu.set(x,y,text)
end

--–¶–≤–µ—Ç–Ω–æ–π —Ç–µ–∫—Å—Ç —Å –∂–æ–ø–∫–æ–π!
function ecs.colorTextWithBack(x,y,textColor,backColor,text)
  component.gpu.setForeground(textColor)
  component.gpu.setBackground(backColor)
  component.gpu.set(x,y,text)
end

--–ò–Ω–≤–µ—Ä—Å–∏—è —Ü–≤–µ—Ç–∞
function ecs.invertColor(color)
  return 0xffffff - color
end

--–ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Ç–µ–∫—Å—Ç, –ø–æ–¥—Å—Ç—Ä–∞–∏–≤–∞—é—â–∏–π—Å—è –ø–æ–¥ —Ñ–æ–Ω
function ecs.adaptiveText(x,y,text,textColor)
  component.gpu.setForeground(textColor)
  x = x - 1
  for i=1,unicode.len(text) do
    local info = {component.gpu.get(x+i,y)}
    component.gpu.setBackground(info[3])
    component.gpu.set(x+i,y,unicode.sub(text,i,i))
  end
end

--–ö–æ—Å—Ç—ã–ª—å–Ω–∞—è –∑–∞–º–µ–Ω–∞ –æ–±—ã—á–Ω–æ–º—É string.find()
--–†–∞–±–æ—Ç–∞–µ—Ç –º–µ–¥–ª–µ–Ω–Ω–µ–µ, –Ω–æ —Ö–æ—Ç—è –±—ã –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —é–Ω–∏–∫–æ–¥
function unicode.find(str, pattern, init, plain)
	if init then
		if init < 0 then
			init = -#unicode.sub(str,init)
		elseif init > 0 then
			init = #unicode.sub(str,1,init-1)+1
		end
	end
	
	a, b = string.find(str, pattern, init, plain)
	
	if a then
		local ap,bp = str:sub(1,a-1), str:sub(a,b)
		a = unicode.len(ap)+1
		b = a + unicode.len(bp)-1
		return a,b
	else
		return a
	end
end

--–£–º–Ω—ã–π —Ç–µ–∫—Å—Ç –ø–æ –∞–Ω–∞–ª–æ–≥–∏–∏ —Å –º–∞–π–Ω—á–∞—Ç–æ–≤—Å–∫–∏–º. –°—Ç–∞–≤–∏—à—å —Å–∏–º–≤–æ–ª –ø–∞—Ä–∞–≥—Ä–∞—Ñ–∞, —É–∫–∞–∑—ã–≤–∞–µ—à—å —Ö—É–π–Ω—é - –∏ —Ö—É—è–∫—Å! –†–∞–±–æ—Ç–∞–µ—Ç!
function ecs.smartText(x, y, text)
	local sText = unicode.len(text)
	local specialSymbol = "¬ß"
	--–†–∞–∑–±–∏—Ä–∞–µ–º –ø–æ –∫—É—Å–æ—á–∫–∞–º —Å—Ç—Ä–æ–∫—É –∏ –ø–æ–ª—É—á–∞–µ–º —Ü–≤–µ—Ç–∞
	local massiv = {}
	local iterator = 1
	local currentColor = component.gpu.getForeground()
	while iterator <= sText do
		local symbol = unicode.sub(text, iterator, iterator)
		if symbol == specialSymbol then
			currentColor = ecs.colors[unicode.sub(text, iterator + 1, iterator + 1) or "f"]
			iterator = iterator + 1
		else
			table.insert(massiv, {symbol, currentColor})
		end
		symbol = nil
		iterator = iterator + 1
	end
	x = x - 1
	for i = 1, #massiv do
		if currentColor ~= massiv[i][2] then currentColor = massiv[i][2]; component.gpu.setForeground(massiv[i][2]) end
		component.gpu.set(x + i, y, massiv[i][1])
	end
end

--–ê–Ω–∞–ª–æ–≥ —É–º–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞, –Ω–æ –∏—Å–ø–æ–ª—å–∑—É—é—â–∏–π HEX-—Ü–≤–µ—Ç–∞ –¥–ª—è –∫–æ–¥–∏—Ä–æ–≤–∫–∏
function ecs.formattedText(x, y, text, limit)
	--–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–ª–∏–Ω—ã —Å—Ç—Ä–æ–∫–∏
	limit = limit or math.huge
	--–°—Ç–∞—Ä—Ç–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è –∫—É—Ä—Å–æ—Ä–∞ –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
	local xPos = x
	--–°–æ–∑–¥–∞–µ–º –º–∞—Å—Å–∏–≤ —Å–∏–º–≤–æ–ª–æ–≤ –¥–∞–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
	local symbols = {}
	for i = 1, unicode.len(text) do table.insert(symbols, unicode.sub(text, i, i)) end
	--–ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –≤—Å–µ —Å–∏–º–≤–æ–ª—ã —Å—Ç—Ä–æ–∫–∏, –ø–æ–∫–∞ –Ω–µ –ø–µ—Ä–µ–±–µ—Ä–µ–º –≤—Å–µ –∏–ª–∏ –Ω–µ –¥–æ—Å—Ç–∏–≥–Ω–µ–º —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞
	local i = 1
	while i <= #symbols and i <= limit do
		--–ï—Å–ª–∏ –Ω–∞—Ö–æ–¥–∏–º —Å–∏–º–≤–æ–ª –ø–∞—Ä–∞–≥—Ä–∞—Ñ–∞, —Ç–æ
		if symbols[i] == "¬ß" then
			--–ú–µ–Ω—è–µ–º —Ü–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ –Ω–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π
			component.gpu.setForeground(tonumber("0x" .. symbols[i+1] .. symbols[i+2] .. symbols[i+3] .. symbols[i+4] .. symbols[i+5] .. symbols[i+6]))
			--–£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ª–∏–º–∏—Ç –Ω–∞ 7, —Ç.–∫.
			limit = limit + 7
			--–°–¥–≤–∏–≥–∞–µ–º –∏—Ç–µ—Ä–∞—Ç–æ—Ä —Ü–∏–∫–ª–∞ –Ω–∞ 7
			i = i + 7
		end
		--–†–∏—Å—É–µ–º —Å–∏–º–≤–æ–ª –Ω–∞ –Ω—É–∂–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
		component.gpu.set(xPos, y, symbols[i])
		--–£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∫—É—Ä—Å–æ—Ä–∞ –∏ –∏—Ç–µ—Ä–∞—Ç–æ—Ä –Ω–∞ 1
		xPos = xPos + 1
		i = i + 1
	end
end

--–ò–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ü–≤–µ—Ç–∞ —Ñ–æ–Ω–∞
function ecs.invertedText(x,y,symbol)
  local info = {component.gpu.get(x,y)}
  ecs.adaptiveText(x,y,symbol,ecs.invertColor(info[3]))
end

--–ê–¥–∞–ø—Ç–∏–≤–Ω–æ–µ –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ —á–∏—Å–ª–∞
function ecs.adaptiveRound(chislo)
  local celaya,drobnaya = math.modf(chislo)
  if drobnaya >= 0.5 then
    return (celaya + 1)
  else
    return celaya
  end
end

--–û–∫—Ä—É–≥–ª–µ–Ω–∏–µ –¥–æ –æ–ø—Ä–µ–¥. –∫–æ–ª-–≤–∞ –∑–Ω–∞–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π
function ecs.round(num, idp)
	local mult = 10^(idp or 0)
	return math.floor(num * mult + 0.5) / mult
end

--–û–±—ã—á–Ω—ã–π –∫–≤–∞–¥—Ä–∞—Ç —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞
function ecs.square(x,y,width,height,color)
  component.gpu.setBackground(color)
  component.gpu.fill(x,y,width,height," ")
end

--–Æ–Ω–∏–∫–æ–¥–æ–≤—Å–∫–∞—è —Ä–∞–º–∫–∞
function ecs.border(x, y, width, height, back, fore)
	local stringUp = "‚îå"..string.rep("‚îÄ", width - 2).."‚îê"
	local stringDown = "‚îî"..string.rep("‚îÄ", width - 2).."‚îò"
	component.gpu.setForeground(fore)
	component.gpu.setBackground(back)
	component.gpu.set(x, y, stringUp)
	component.gpu.set(x, y + height - 1, stringDown)

	local yPos = 1
	for i = 1, (height - 2) do
		component.gpu.set(x, y + yPos, "‚îÇ")
		component.gpu.set(x + width - 1, y + yPos, "‚îÇ")
		yPos = yPos + 1
	end
end

--–ö–Ω–æ–ø–∫–∞ –≤ –≤–∏–¥–µ —Ç–µ–∫—Å—Ç–∞ –≤ —Ä–∞–º–∫–µ
function ecs.drawFramedButton(x, y, width, height, text, color)
	ecs.border(x, y, width, height, component.gpu.getBackground(), color)
	component.gpu.fill(x + 1, y + 1, width - 2, height - 2, " ")
	x = x + math.floor(width / 2 - unicode.len(text) / 2)
	y = y + math.floor(width / 2 - 1)
	component.gpu.set(x, y, text)
end

--–Æ–Ω–∏–∫–æ–¥–æ–≤—Å–∫–∏–π —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å
function ecs.separator(x, y, width, back, fore)
	ecs.colorTextWithBack(x, y, fore, back, string.rep("‚îÄ", width))
end

--–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–π –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–µ (x, y, xy)
function ecs.centerText(mode,coord,text)
	local dlina = unicode.len(text)
	local xSize,ySize = component.gpu.getResolution()

	if mode == "x" then
		component.gpu.set(math.floor(xSize/2-dlina/2),coord,text)
	elseif mode == "y" then
		component.gpu.set(coord,math.floor(ySize/2),text)
	else
		component.gpu.set(math.floor(xSize/2-dlina/2),math.floor(ySize/2),text)
	end
end

--–û—Ç—Ä–∏—Å–æ–≤–∫–∞ "–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è" –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –º–∞—Å—Å–∏–≤—É
function ecs.drawCustomImage(x,y,pixels)
	x = x - 1
	y = y - 1
	local pixelsWidth = #pixels[1]
	local pixelsHeight = #pixels
	local xEnd = x + pixelsWidth
	local yEnd = y + pixelsHeight

	for i=1,pixelsHeight do
		for j=1,pixelsWidth do
			if pixels[i][j][3] ~= "#" then
				if component.gpu.getBackground() ~= pixels[i][j][1] then component.gpu.setBackground(pixels[i][j][1]) end
				if component.gpu.getForeground() ~= pixels[i][j][2] then component.gpu.setForeground(pixels[i][j][2]) end
				component.gpu.set(x+j,y+i,pixels[i][j][3])
			end
		end
	end

	return (x+1),(y+1),xEnd,yEnd
end

--–ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ —Å—Ç–∞—Ä—Ç–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç. Core-—Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—Å–µ—Ö –º–æ–∏—Ö –ø—Ä–æ–≥—Ä–∞–º–º
function ecs.correctStartCoords(xStart,yStart,xWindowSize,yWindowSize)
	local xSize,ySize = component.gpu.getResolution()
	if xStart == "auto" then
		xStart = math.floor(xSize/2 - xWindowSize/2)
	end
	if yStart == "auto" then
		yStart = math.ceil(ySize/2 - yWindowSize/2)
	end
	return xStart,yStart
end

--–ó–∞–ø–æ–º–Ω–∏—Ç—å –æ–±–ª–∞—Å—Ç—å –ø–∏–∫—Å–µ–ª–µ–π –∏ –≤–æ–∑–≤—Ä–∞—Ç–∏—Ç—å –µ–µ –≤ –≤–∏–¥–µ –º–∞—Å—Å–∏–≤–∞
function ecs.rememberOldPixels(x, y, x2, y2)
	local newPNGMassiv = { ["backgrounds"] = {} }
	local xSize, ySize = component.gpu.getResolution()
	newPNGMassiv.x, newPNGMassiv.y = x, y

	--–ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –≤–µ—Å—å –º–∞—Å—Å–∏–≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–≥–æ PNG-–≤–∏–¥–∞ –ø–æ –≤—ã—Å–æ—Ç–µ
	local xCounter, yCounter = 1, 1
	for j = y, y2 do
		xCounter = 1
		for i = x, x2 do

			if (i > xSize or i < 0) or (j > ySize or j < 0) then
				error("Can't remember pixel, because it's located behind the screen: x("..i.."), y("..j..") out of xSize("..xSize.."), ySize("..ySize..")\n")
			end

			local symbol, fore, back = component.gpu.get(i, j)

			newPNGMassiv["backgrounds"][back] = newPNGMassiv["backgrounds"][back] or {}
			newPNGMassiv["backgrounds"][back][fore] = newPNGMassiv["backgrounds"][back][fore] or {}

			table.insert(newPNGMassiv["backgrounds"][back][fore], {xCounter, yCounter, symbol} )

			xCounter = xCounter + 1
			back, fore, symbol = nil, nil, nil
		end

		yCounter = yCounter + 1
	end

	xSize, ySize = nil, nil
	return newPNGMassiv
end

--–ù–∞—Ä–∏—Å–æ–≤–∞—Ç—å –∑–∞–ø–æ–º–Ω–µ–Ω–Ω—ã–µ —Ä–∞–Ω–µ–µ –ø–∏–∫—Å–µ–ª–∏ –∏–∑ –º–∞—Å—Å–∏–≤–∞
function ecs.drawOldPixels(massivSudaPihay)
	--–ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –º–∞—Å—Å–∏–≤ —Å —Ñ–æ–Ω–∞–º–∏
	for back, backValue in pairs(massivSudaPihay["backgrounds"]) do
		component.gpu.setBackground(back)
		for fore, foreValue in pairs(massivSudaPihay["backgrounds"][back]) do
			component.gpu.setForeground(fore)
			for pixel = 1, #massivSudaPihay["backgrounds"][back][fore] do
				if massivSudaPihay["backgrounds"][back][fore][pixel][3] ~= transparentSymbol then
					component.gpu.set(massivSudaPihay.x + massivSudaPihay["backgrounds"][back][fore][pixel][1] - 1, massivSudaPihay.y + massivSudaPihay["backgrounds"][back][fore][pixel][2] - 1, massivSudaPihay["backgrounds"][back][fore][pixel][3])
				end
			end
		end
	end
end

--–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–ª–∏–Ω—ã —Å—Ç—Ä–æ–∫–∏. –ú–∞—Å—Ç-—Ö–µ–≤ —Ñ—É–Ω–∫—Ü–∏—è.
function ecs.stringLimit(mode, text, size, noDots)
	if unicode.len(text) <= size then return text end
	local length = unicode.len(text)
	if mode == "start" then
		if noDots then
			return unicode.sub(text, length - size + 1, -1)
		else
			return "‚Ä¶" .. unicode.sub(text, length - size + 2, -1)
		end
	else
		if noDots then
			return unicode.sub(text, 1, size)
		else
			return unicode.sub(text, 1, size - 1) .. "‚Ä¶"
		end
	end
end

--–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–µ–µ —Ä–µ–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –∫–æ–º–ø—å—é—Ç–µ—Ä–∞, —Ö–æ—Å—Ç—è—â–µ–≥–æ —Å–µ—Ä–≤–µ—Ä –º–∞–π–Ω–∞
function ecs.getHostTime(timezone)
	timezone = timezone or 2
	--–°–æ–∑–¥–∞–µ–º —Ñ–∞–π–ª —Å –∑–∞–ø–∏—Å–∞–Ω–Ω–æ–π –≤ –Ω–µ–≥–æ –ø–∞—Ä–∞—à–µ–π
    local file = io.open("HostTime.tmp", "w")
    file:write("")
    file:close()
    --–ö–æ—Ä—Ä–µ–∫—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —á–∞—Å–æ–≤–æ–≥–æ –ø–æ—è—Å–∞
    local timeCorrection = timezone * 3600
    --–ü–æ–ª—É—á–∞–µ–º –¥–∞—Ç—É –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–∞ –≤ —é–Ω–∏–∫—Å-–≤–∏–¥–µ
    local lastModified = tonumber(string.sub(fs.lastModified("HostTime.tmp"), 1, -4)) + timeCorrection
    --–£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª, –∏–±–æ –Ω–∞ —Ö—É–π –æ–Ω –Ω–∞–º –Ω–µ –Ω—É–∂–µ–Ω
    fs.remove("HostTime.tmp")
    --–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —é–Ω–∏–∫—Å-–≤—Ä–µ–º—è –≤ –Ω–æ—Ä–º –≤—Ä–µ–º—è
    local year, month, day, hour, minute, second = os.date("%Y", lastModified), os.date("%m", lastModified), os.date("%d", lastModified), os.date("%H", lastModified), os.date("%M", lastModified), os.date("%S", lastModified)
    --–í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤—Å–µ
    return tonumber(day), tonumber(month), tonumber(year), tonumber(hour), tonumber(minute), tonumber(second)
end

--–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–∫–æ–∫ —Ñ–∞–π–ª–æ–≤ –∏–∑ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏, –∫–æ—Å—Ç—ã–ª—å
function ecs.getFileList(path)
	local list = fs.list(path)
	local massiv = {}
	for file in list do
		--if string.find(file, "%/$") then file = unicode.sub(file, 1, -2) end
		table.insert(massiv, file)
	end
	list = nil
	return massiv
end

--–ü–æ–ª—É—á–∏—Ç—å —Ñ–∞–π–ª–æ–≤–æ–µ –¥—Ä–µ–≤–æ. –°–∏–ª—å–Ω–æ –Ω–∞–≥—Ä—É–∂–∞–µ—Ç —Å–∏—Å—Ç–µ–º—É, —Ç–æ–ª—å–∫–æ –¥–ª—è –¥–µ–±–∞–≥–∞!
function ecs.getFileTree(path)
	local massiv = {}
	local list = ecs.getFileList(path)
	for key, file in pairs(list) do
		if fs.isDirectory(path.."/"..file) then
			table.insert(massiv, getFileTree(path.."/"..file))
		else
			table.insert(massiv, file)
		end
	end
	list = nil

	return massiv
end

--–ü–æ–∏—Å–∫ –ø–æ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–µ
function ecs.find(path, cheBudemIskat)
	--–ú–∞—Å—Å–∏–≤, –≤ –∫–æ—Ç–æ—Ä–æ–º –±—É–¥—É—Ç –Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –≤—Å–µ –Ω–∞–π–¥–µ–Ω–Ω—ã–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è
	local massivNaydennogoGovna = {}
	--–ö–æ—Å—Ç—ã–ª—å, –Ω–æ —É–¥–æ–±–Ω—ã–π
	local function dofind(path, cheBudemIskat)
		--–ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
		local list = ecs.getFileList(path)
		--–ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã —Ñ–∞–π–ª –ª–∏—Å—Ç–∞
		for key, file in pairs(list) do
			--–ü—É—Ç—å –∫ —Ñ–∞–π–ª—É
			local pathToFile = path..file
			--–ï—Å–ª–∏ –Ω–∞—à–ª–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –≤ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞, —Ç–æ –≤—ã–¥–∞–µ—Ç –ø—É—Ç—å –∫ —ç—Ç–æ–º—É —Ñ–∞–π–ª—É
			if string.find(unicode.lower(file), unicode.lower(cheBudemIskat)) then
				table.insert(massivNaydennogoGovna, pathToFile)
			end
			--–ê–Ω–∞–ª–∏–∑, —á—Ç–æ –¥–µ–ª–∞—Ç—å –¥–∞–ª—å—à–µ
			if fs.isDirectory(pathToFile) then
				dofind(pathToFile, cheBudemIskat)
			end
			--–û—á–∏—â–∞–µ–º –æ–ø–µ—Ä–∞—Ç–∏–≤–∫—É
			pathToFile = nil
		end
		--–û—á–∏—â–∞–µ–º –æ–ø–µ—Ä–∞—Ç–∏–≤–∫—É
		list = nil
	end
	--–í—ã–ø–æ–ª–Ω—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é
	dofind(path, cheBudemIskat)
	--–í–æ–∑–≤—Ä–∞—â–∞–µ–º, —á–µ –Ω–∞—à–ª–æ
	return massivNaydennogoGovna
end

--–ü–æ–ª—É—á–µ–Ω–∏–µ —Ñ–æ—Ä–º–∞—Ç–∞ —Ñ–∞–π–ª–∞
function ecs.getFileFormat(path)
	local name = fs.name(path)
	local starting, ending = string.find(name, "(.)%.[%d%w]*$")
	if starting == nil then
		return nil
	else
		return unicode.sub(name,starting + 1, -1)
	end
	name, starting, ending = nil, nil, nil
end

--–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —Å–∫—Ä—ã—Ç—ã–π –ª–∏ —Ñ–∞–π–ª (.–ø–∏–¥–æ—Ä, .—Ö—É–π = true; –ø–∏–¥–æ—Ä, —Ö—É–π = false)
function ecs.isFileHidden(path)
	local name = fs.name(path)
	local starting, ending = string.find(name, "^%.(.*)$")
	if starting == nil then
		return false
	else
		return true
	end
	name, starting, ending = nil, nil, nil
end

--–°–∫—Ä—ã—Ç—å —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞
function ecs.hideFileFormat(path)
	local name = fs.name(path)
	local fileFormat = ecs.getFileFormat(name)
	if fileFormat == nil then
		return name
	else
		return unicode.sub(name, 1, unicode.len(name) - unicode.len(fileFormat))
	end
end

--–û–∂–∏–¥–∞–Ω–∏–µ –∫–ª–∏–∫–∞ –ª–∏–±–æ –Ω–∞–∂–∞—Ç–∏—è –∫–∞–∫–æ–π-–ª–∏–±–æ –∫–ª–∞–≤–∏—à–∏
function ecs.waitForTouchOrClick()
	while true do
		local e = { event.pull() }
		if e[1] == "key_down" or e[1] == "touch" then break end
	end
end

--–¢–æ –∂–µ —Å–∞–º–æ–µ, –Ω–æ –≤ —Å–æ–∫—Ä–∞—â–µ–Ω–Ω–æ–º –≤–∞—Ä–∏–∞–Ω—Ç–µ
function ecs.wait()
	ecs.waitForTouchOrClick()
end

--–ù–∞—Ä–∏—Å–æ–≤–∞—Ç—å –∫–Ω–æ–ø–æ—á–∫–∏ –∑–∞–∫—Ä—ã—Ç–∏—è –æ–∫–Ω–∞
function ecs.drawCloses(x, y, active)
	local symbol = "‚Ææ"
	ecs.colorText(x, y , (active == 1 and ecs.colors.blue) or 0xCC4C4C, symbol)
	ecs.colorText(x + 2, y , (active == 2 and ecs.colors.blue) or 0xDEDE6C, symbol)
	ecs.colorText(x + 4, y , (active == 3 and ecs.colors.blue) or 0x57A64E, symbol)
end

--–ù–∞—Ä–∏—Å–æ–≤–∞—Ç—å –≤–µ—Ä—Ö–Ω—é—é –æ–∫–æ–Ω–Ω—É—é –ø–∞–Ω–µ–ª—å —Å –≤—ã–±–æ—Ä–æ–º –æ–±—ä–µ–∫—Ç–æ–≤
function ecs.drawTopBar(x, y, width, selectedObject, background, foreground, ...)
	local objects = { ... }
	ecs.square(x, y, width, 3, background)
	local widthOfObjects = 0
	local spaceBetween = 2
	for i = 1, #objects do
		widthOfObjects = widthOfObjects + unicode.len(objects[i][1]) + spaceBetween
	end
	local xPos = x + math.floor(width / 2 - widthOfObjects / 2)
	for i = 1, #objects do
		if i == selectedObject then
			ecs.square(xPos, y, unicode.len(objects[i][1]) + spaceBetween, 3, ecs.colors.blue)
			component.gpu.setForeground(0xffffff)
		else
			component.gpu.setBackground(background)
			component.gpu.setForeground(foreground)
		end
		component.gpu.set(xPos + spaceBetween / 2, y + 2, objects[i][1])
		component.gpu.set(xPos + math.ceil(unicode.len(objects[i][1]) / 2), y + 1, objects[i][2])

		xPos = xPos + unicode.len(objects[i][1]) + spaceBetween
	end
end

--–ù–∞—Ä–∏—Å–æ–≤–∞—Ç—å —Ç–æ–ø-–º–µ–Ω—é, –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –ø–æ–ª–æ—Å–∫–∞ —Ç–∞–∫–∞—è —Å —Ç–µ–∫—Å—Ç–∞–º–∏
function ecs.drawTopMenu(x, y, width, color, selectedObject, ...)
	local objects = { ... }
	local objectsToReturn = {}
	local xPos = x + 2
	local spaceBetween = 2
	ecs.square(x, y, width, 1, color)
	for i = 1, #objects do
		if i == selectedObject then
			ecs.square(xPos - 1, y, unicode.len(objects[i][1]) + spaceBetween, 1, ecs.colors.blue)
			component.gpu.setForeground(0xffffff)
			component.gpu.set(xPos, y, objects[i][1])
			component.gpu.setForeground(objects[i][2])
			component.gpu.setBackground(color)
		else
			if component.gpu.getForeground() ~= objects[i][2] then component.gpu.setForeground(objects[i][2]) end
			component.gpu.set(xPos, y, objects[i][1])
		end
		objectsToReturn[objects[i][1]] = { xPos, y, xPos + unicode.len(objects[i][1]) - 1, y, i }
		xPos = xPos + unicode.len(objects[i][1]) + spaceBetween
	end
	return objectsToReturn
end

--–§—É–Ω–∫—Ü–∏—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –∫–Ω–æ–ø–∫–∏ —É–∫–∞–∑–∞–Ω–Ω–æ–π —à–∏—Ä–∏–Ω—ã
function ecs.drawButton(x,y,width,height,text,backColor,textColor)
	x,y = ecs.correctStartCoords(x,y,width,height)

	local textPosX = math.floor(x + width / 2 - unicode.len(text) / 2)
	local textPosY = math.floor(y + height / 2)
	ecs.square(x,y,width,height,backColor)
	ecs.colorText(textPosX,textPosY,textColor,text)

	return x, y, (x + width - 1), (y + height - 1)
end

--–û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∫–Ω–æ–ø–∫–∏ —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º–∏ –æ—Ç—Å—Ç—É–ø–∞–º–∏ –æ—Ç —Ç–µ–∫—Å—Ç–∞
function ecs.drawAdaptiveButton(x,y,offsetX,offsetY,text,backColor,textColor)
	local length = unicode.len(text)
	local width = offsetX*2 + length
	local height = offsetY*2 + 1

	x,y = ecs.correctStartCoords(x,y,width,height)

	ecs.square(x,y,width,height,backColor)
	ecs.colorText(x+offsetX,y+offsetY,textColor,text)

	return x,y,(x+width-1),(y+height-1)
end

--–û—Ç—Ä–∏—Å–æ–≤–∫–∞ –æ–∫–æ–Ω–Ω–æ–π "—Ç–µ–Ω–∏"
function ecs.windowShadow(x,y,width,height)
	component.gpu.setBackground(ecs.windowColors.shadow)
	component.gpu.fill(x+width,y+1,2,height," ")
	component.gpu.fill(x+1,y+height,width,1," ")
end

--–ü—Ä–æ—Å—Ç–æ –±–µ–ª–æ–µ –æ–∫–æ—à–∫–æ —Å —Ç–µ–Ω—å—é
function ecs.blankWindow(x,y,width,height)
	local oldPixels = ecs.rememberOldPixels(x,y,x+width+1,y+height)

	ecs.square(x,y,width,height,ecs.windowColors.background)

	ecs.windowShadow(x,y,width,height)

	return oldPixels
end

--–ë–µ–ª–æ–µ –æ–∫–æ—à–∫–æ, –Ω–æ —É–∂–µ —Å —Ç–∏—Ç–ª–æ–º –≤–≤–µ—Ä—Ö—É!
function ecs.emptyWindow(x,y,width,height,title)

	local oldPixels = ecs.rememberOldPixels(x,y,x+width+1,y+height)

	--–û–ö–ù–û
	component.gpu.setBackground(ecs.windowColors.background)
	component.gpu.fill(x,y+1,width,height-1," ")

	--–¢–ê–ë –°–í–ï–†–•–£
	component.gpu.setBackground(ecs.windowColors.tab)
	component.gpu.fill(x,y,width,1," ")

	--–¢–ò–¢–õ
	component.gpu.setForeground(ecs.windowColors.title)
	local textPosX = x + math.floor(width/2-unicode.len(title)/2) -1
	component.gpu.set(textPosX,y,title)

	--–¢–ï–ù–¨
	ecs.windowShadow(x,y,width,height)

	return oldPixels

end

function ecs.getWordsArrayFromString(s)
	local words = {} 
	for word in string.gmatch(s, "[^%s]+") do table.insert(words, word) end
	return words
end

--–ú–æ—è –ª—é–±–∏–º–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ—à–∏–±–∫–∏ C:
function ecs.error(...)
	local args = {...}
	local text = ""
	if #args > 1 then
		for i = 1, #args do
			--text = text .. "[" .. i .. "] = " .. tostring(args[i])
			if type(args[i]) == "string" then args[i] = "\"" .. args[i] .. "\"" end 
			text = text .. tostring(args[i])
			if i ~= #args then text = text .. ", " end
		end
	else
		text = tostring(args[1])
	end
	ecs.universalWindow("auto", "auto", math.ceil(component.gpu.getResolution() * 0.45), ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x880000, "–û—à–∏–±–∫–∞!"}, {"EmptyLine"}, {"WrappedText", 0x262626, text}, {"EmptyLine"}, {"Button", {0x880000, 0xffffff, "OK!"}})
end

--–û—á–∏—Å—Ç–∏—Ç—å —ç–∫—Ä–∞–Ω, —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–æ–º—Ñ–æ—Ä—Ç–Ω—ã–µ —Ü–≤–µ—Ç–∞ –∏ –ø–æ—Å—Ç–∞–≤–∏—Ç—å –∫—É—Ä—Å–æ–∫ –Ω–∞ 1, 1
function ecs.prepareToExit(color1, color2)
	term.setCursor(1, 1)
	ecs.clearScreen(color1 or 0x333333)
	component.gpu.setForeground(color2 or 0xffffff)
	component.gpu.set(1, 1, "")
end

--–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –∏–∑ —é–Ω–∏–∫–æ–¥–∞ –≤ —Å–∏–º–≤–æ–ª. –í—Ä–æ–¥–µ –Ω–æ—Ä–º, –∞ –≤—Ä–æ–¥–µ –∏ –Ω–µ –Ω–æ—Ä–º. –ù–æ –ø–æ–ª–µ–∑–Ω–æ.
function ecs.convertCodeToSymbol(code)
	local symbol
	if code ~= 0 and code ~= 13 and code ~= 8 and code ~= 9 and code ~= 200 and code ~= 208 and code ~= 203 and code ~= 205 and not keyboard.isControlDown() then
		symbol = unicode.char(code)
		if keyboard.isShiftPressed then symbol = unicode.upper(symbol) end
	end
	return symbol
end

--–®–∫–∞–ª–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ - –º–∞—Å—Ç-—Ö–µ–≤!
function ecs.progressBar(x, y, width, height, background, foreground, percent)
	local activeWidth = math.ceil(width * percent / 100)
	ecs.square(x, y, width, height, background)
	ecs.square(x, y, activeWidth, height, foreground)
end

--–û–∫–æ—à–∫–æ —Å –ø—Ä–æ–≥—Ä–µ—Å—Å–±–∞—Ä–æ–º! –î–∞–≤–Ω–æ —Ö–æ—Ç–µ–ª
function ecs.progressWindow(x, y, width, percent, text, returnOldPixels)
	local height = 6
	local barWidth = width - 6

	x, y = ecs.correctStartCoords(x, y, width, height)

	local oldPixels
	if returnOldPixels then
		oldPixels = ecs.rememberOldPixels(x, y, x + width + 1, y + height)
	end

	ecs.emptyWindow(x, y, width, height, " ")
	ecs.colorTextWithBack(x + math.floor(width / 2 - unicode.len(text) / 2), y + 4, 0x000000, ecs.windowColors.background, text)
	ecs.progressBar(x + 3, y + 2, barWidth, 1, 0xCCCCCC, ecs.colors.blue, percent)

	return oldPixels
end

--–§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤–≤–æ–¥–∞ —Ç–µ–∫—Å—Ç–∞ –≤ –º–∏–Ω–∏-–ø–æ–ª–µ.
function ecs.inputText(x, y, limit, cheBiloVvedeno, background, foreground, justDrawNotEvent, maskTextWith)
	limit = limit or 10
	cheBiloVvedeno = cheBiloVvedeno or ""
	background = background or 0xffffff
	foreground = foreground or 0x000000

	component.gpu.setBackground(background)
	component.gpu.setForeground(foreground)
	component.gpu.fill(x, y, limit, 1, " ")

	local text = cheBiloVvedeno

	local function draw()
		term.setCursorBlink(false)

		local dlina = unicode.len(text)
		local xCursor = x + dlina
		if xCursor > (x + limit - 1) then xCursor = (x + limit - 1) end

		if maskTextWith then
			component.gpu.set(x, y, ecs.stringLimit("start", string.rep("‚óè", dlina), limit))
		else
			component.gpu.set(x, y, ecs.stringLimit("start", text, limit))
		end

		term.setCursor(xCursor, y)

		term.setCursorBlink(true)
	end

	draw()

	if justDrawNotEvent then term.setCursorBlink(false); return cheBiloVvedeno end

	while true do
		local e = {event.pull()}
		if e[1] == "key_down" then
			if e[4] == 14 then
				term.setCursorBlink(false)
				text = unicode.sub(text, 1, -2)
				if unicode.len(text) < limit then component.gpu.set(x + unicode.len(text), y, " ") end
				draw()
			elseif e[4] == 28 then
				term.setCursorBlink(false)
				return text
			else
				local symbol = ecs.convertCodeToSymbol(e[3])
				if symbol then
					text = text..symbol
					draw()
				end
			end
		elseif e[1] == "touch" then
			term.setCursorBlink(false)
			return text
		elseif e[1] == "clipboard" then
			if e[3] then
				text = text..e[3]
				draw()
			end
		end
	end
end

--–°–ø—Ä–æ—Å–∏—Ç—å, –∑–∞–º–µ–Ω—è—Ç—å –ª–∏ —Ñ–∞–π–ª (–µ—Å–ª–∏ —Ç–∞–∫–æ–≤–æ–π —É–∂–µ –∏–º–µ–µ—Ç—Å—è)
function ecs.askForReplaceFile(path, includeForAllButton)
	local cyka = {
		{"EmptyLine"}, 
		{"CenterText", 0x262626, "–§–∞–π–ª \"".. fs.name(path) .. "\" —É–∂–µ –∏–º–µ–µ—Ç—Å—è –≤ —ç—Ç–æ–º –º–µ—Å—Ç–µ."}, 
		{"CenterText", 0x262626, "–ó–∞–º–µ–Ω–∏—Ç—å –µ–≥–æ –ø–µ—Ä–µ–º–µ—â–∞–µ–º—ã–º –æ–±—ä–µ–∫—Ç–æ–º?"},
		{"EmptyLine"}
	}
	if includeForAllButton then table.insert(cyka, {"Switch", 0xF2B233, 0xffffff, 0x262626, "–î–ª—è –≤—Å–µ—Ö", true}) end
	table.insert(cyka, {"Button", {0x444444, 0xFFFFFF, "–ó–∞–º–µ–Ω–∏—Ç—å"}, {0x666666, 0xFFFFFF, "–û—Ç–º–µ–Ω–∞"}})

	local action = ecs.universalWindow("auto", "auto", 46, ecs.windowColors.background, true, table.unpack(cyka))
	if action[includeForAllButton and 2 or 1] == "–ó–∞–º–µ–Ω–∏—Ç—å" then
		return 1, action[includeForAllButton and 1]
	else
		return 2, action[includeForAllButton and 1]
	end
end

--–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∏–º—è —Ñ–∞–π–ª–∞ –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –∫—Ä–∏—Ç–µ—Ä–∏—è–º
function ecs.checkName(name, path)
	--–ï—Å–ª–∏ –≤–≤–µ–ª–∏ —Ö—É–π–Ω—é –∫–∞–∫—É—é-—Ç–æ, —Ç–æ
	if name == "" or name == " " or name == nil then
		ecs.error("–ù–µ–≤–µ—Ä–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞.")
		return false
	else
		--–ï—Å–ª–∏ —Ñ–∞–π–ª —Å –Ω–æ–≤—ã–º –ø—É—Ç–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —Ç–æ
		if fs.exists(path .. name) then
			ecs.error("–§–∞–π–ª \"".. name .. "\" —É–∂–µ –∏–º–µ–µ—Ç—Å—è –≤ —ç—Ç–æ–º –º–µ—Å—Ç–µ.")
			return false
		--–ê –µ—Å–ª–∏ –≤—Å–µ –∑–∞–µ–±–æ–∫, —Ç–æ
		else
			return true
		end
	end
end

--–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ (–¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–∫–∏)
function ecs.rename(mainPath)
	--–ó–∞–¥–∞–µ–º —Å—Ç–∞—Ä—Ç–æ–≤—É—é —â–Ω—è–≥—É
	local name = fs.name(mainPath)
	path = fs.path(mainPath)
	--–†–∏—Å—É–µ–º –æ–∫–æ—à–∫–æ –≤–≤–æ–¥–∞ –Ω–æ–≤–æ–≥–æ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
	local inputs = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x262626, "–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å"}, {"EmptyLine"}, {"Input", 0x262626, 0x880000, name}, {"EmptyLine"}, {"Button", {0xbbbbbb, 0xffffff, "OK"}})
	--–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤—ã–≤–∞–µ–º
	if ecs.checkName(inputs[1], path) then
		fs.rename(mainPath, path .. inputs[1])
	end
end

--–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –ø–∞–ø–∫—É (–¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–∫–∏)
function ecs.newFolder(path)
	--–†–∏—Å—É–µ–º –æ–∫–æ—à–∫–æ –≤–≤–æ–¥–∞ –Ω–æ–≤–æ–≥–æ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
	local inputs = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x262626, "–ù–æ–≤–∞—è –ø–∞–ø–∫–∞"}, {"EmptyLine"}, {"Input", 0x262626, 0x880000, ""}, {"EmptyLine"}, {"Button", {0xbbbbbb, 0xffffff, "OK"}})

	if ecs.checkName(inputs[1], path) then
		fs.makeDirectory(path .. inputs[1])
	end
end

--–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —Ñ–∞–π–ª (–¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–∫–∏)
function ecs.newFile(path)
	--–†–∏—Å—É–µ–º –æ–∫–æ—à–∫–æ –≤–≤–æ–¥–∞ –Ω–æ–≤–æ–≥–æ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
	local inputs = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x262626, "–ù–æ–≤—ã–π —Ñ–∞–π–ª"}, {"EmptyLine"}, {"Input", 0x262626, 0x880000, ""}, {"EmptyLine"}, {"Button", {0xbbbbbb, 0xffffff, "OK"}})

	if ecs.checkName(inputs[1], path) then
		local MineOSCore = require("MineOSCore")
		MineOSCore.safeLaunch(MineOSCore.paths.applications .. "/MineCode IDE.app/MineCode IDE.lua", "open", path .. inputs[1])
	end
end

--–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ (–¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–∫–∏)
function ecs.newApplication(path, startName)
	--–†–∏—Å—É–µ–º –æ–∫–æ—à–∫–æ –≤–≤–æ–¥–∞ –Ω–æ–≤–æ–≥–æ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
	local inputs
	if not startName then
		inputs = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x262626, "–ù–æ–≤–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ"}, {"EmptyLine"}, {"Input", 0x262626, 0x880000, "–í–≤–µ–¥–∏—Ç–µ –∏–º—è"}, {"EmptyLine"}, {"Button", {0xbbbbbb, 0xffffff, "OK"}})
	end

	if ecs.checkName(inputs[1] .. ".app", path) then
		local name = path .. inputs[1] .. ".app/Resources/"
		fs.makeDirectory(name)
		fs.copy("MineOS/System/OS/Icons/SampleIcon.pic", name .. "Icon.pic")
		local file = io.open(path .. inputs[1] .. ".app/" .. inputs[1] .. ".lua", "w")
		file:write("local ecs = require(\"ECSAPI\")", "\n")
		file:write("ecs.universalWindow(\"auto\", \"auto\", 30, 0xeeeeee, true, {\"EmptyLine\"}, {\"CenterText\", 0x262626, \"Hello world!\"}, {\"EmptyLine\"}, {\"Button\", {0x880000, 0xffffff, \"Hello!\"}})", "\n")
		file:close()
	end
end

--–°–æ–∑–¥–∞—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –õ–£–ê-—Ñ–∞–π–ª–∞
function ecs.newApplicationFromLuaFile(pathToLuaFile, pathWhereToCreateApplication)
	local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x000000, "–ù–æ–≤–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ"}, {"EmptyLine"}, {"Input", 0x262626, 0x880000, "–ò–º—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"}, {"Input", 0x262626, 0x880000, "–ü—É—Ç—å –∫ –∏–∫–æ–Ω–∫–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"}, {"EmptyLine"}, {"Button", {0xbbbbbb, 0xffffff, "OK"}})
	data[1] = data[1] or "MyApplication"
	data[2] = data[2] or "MineOS/System/OS/Icons/SampleIcon.pic"
	if fs.exists(data[2]) then
		fs.makeDirectory(pathWhereToCreateApplication .. "/" .. data[1] .. ".app/Resources")
		fs.copy(pathToLuaFile, pathWhereToCreateApplication .. "/" .. data[1] .. ".app/" .. data[1] .. ".lua")
		fs.copy(data[2], pathWhereToCreateApplication .. "/" .. data[1] .. ".app/Resources/Icon.pic")

		--ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x000000, "–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ!"}, {"EmptyLine"}, {"Button", {ecs.colors.green, 0xffffff, "OK"}})
	else
		ecs.error("–£–∫–∞–∑–∞–Ω–Ω—ã–π —Ñ–∞–π–ª –∏–∫–æ–Ω–∫–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.")
		return
	end
end

--–ü—Ä–æ—Å—Ç–æ–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–µ –æ–∫–æ—à–µ—á–∫–æ. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ä—ã–µ –ø–∏–∫—Å–µ–ª–∏ - –º–∞–ª–æ –ª–∏ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è.
function ecs.info(x, y, title, text)
	x = x or "auto"
	y = y or "auto"
	title = title or " "
	text = text or "Sample text"

	local width = unicode.len(text) + 4
	local height = 4
	x, y = ecs.correctStartCoords(x, y, width, height)

	local oldPixels = ecs.rememberOldPixels(x, y, x + width + 1, y + height)

	ecs.emptyWindow(x, y, width, height, title)
	ecs.colorTextWithBack(x + 2, y + 2, ecs.windowColors.usualText, ecs.windowColors.background, text)

	return oldPixels
end

--–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —Å–∫—Ä–æ–ª–ª–±–∞—Ä. –ú–∞—Å—Ç-—Ö–µ–≤!
function ecs.srollBar(x, y, width, height, countOfAllElements, currentElement, backColor, frontColor)
	local sizeOfScrollBar = math.ceil(1 / countOfAllElements * height)
	local displayBarFrom = math.floor(y + height * ((currentElement - 1) / countOfAllElements))

	ecs.square(x, y, width, height, backColor)
	ecs.square(x, displayBarFrom, width, sizeOfScrollBar, frontColor)

	sizeOfScrollBar, displayBarFrom = nil, nil
end

--–û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø–æ–ª—è —Å —Ç–µ–∫—Å—Ç–æ–º. –°—é–¥–∞ –ø–∏—Ö–∞—Ç—å –º–∞—Å—Å–∏–≤ –≤–∏–¥–∞ {"—Å—Ç—Ä–æ–∫–∞1", "—Å—Ç—Ä–æ–∫–∞2", "—Å—Ç—Ä–æ–∫–∞3", ...}
function ecs.textField(x, y, width, height, lines, displayFrom, background, foreground, scrollbarBackground, scrollbarForeground)
	x, y = ecs.correctStartCoords(x, y, width, height)

	background = background or 0xffffff
	foreground = foreground or ecs.windowColors.usualText

	local sLines = #lines
	local lineLimit = width - 3

	--–ü–∞—Ä—Å–∏–º —Å—Ç—Ä–æ–∫–∏
	local line = 1
	while lines[line] do
		local sLine = unicode.len(lines[line])
		if sLine > lineLimit then
			local part1, part2 = unicode.sub(lines[line], 1, lineLimit), unicode.sub(lines[line], lineLimit + 1, -1)
			lines[line] = part1
			table.insert(lines, line + 1, part2)
			part1, part2 = nil, nil
		end
		line = line + 1
		sLine = nil
	end
	line = nil

	ecs.square(x, y, width - 1, height, background)
	ecs.srollBar(x + width - 1, y, 1, height, sLines, displayFrom, scrollbarBackground, scrollbarForeground)

	component.gpu.setBackground(background)
	component.gpu.setForeground(foreground)
	local yPos = y
	for i = displayFrom, (displayFrom + height - 1) do
		if lines[i] then
			component.gpu.set(x + 1, yPos, lines[i])
			yPos = yPos + 1
		else
			break
		end
	end

	return sLines
end

--–ü–æ–ª—É—á–µ–Ω–∏–µ –≤–µ—Ä–Ω–æ–≥–æ –∏–º–µ–Ω–∏ —è–∑—ã–∫–∞. –ü—Ä–æ—Å—Ç–æ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏. (–¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–∫–∏)
function ecs.getCorrectLangName(pathToLangs)
	local language = _G.OSSettings.language .. ".lang"
	if not fs.exists(pathToLangs .. "/" .. language) then
		language = "English.lang"
	end
	return language
end

--–ß—Ç–µ–Ω–∏–µ —è–∑—ã–∫–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞  (–¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–∫–∏)
function ecs.readCorrectLangFile(pathToLangs)
	local lang
	
	local language = ecs.getCorrectLangName(pathToLangs)

	lang = config.readAll(pathToLangs .. "/" .. language)

	return lang
end

-------------------------–í–°–ï –î–õ–Ø –û–°–ö–ò-------------------------------------------------------------------------------

function ecs.searchInArray(array, textToSearch)
	local newArray = {}
	for i = 1, #array do
		if string.find(unicode.lower(array[i]), unicode.lower(textToSearch)) then table.insert(newArray, array[i]) end
	end
	return newArray
end

function ecs.sortFiles(path, fileList, sortingMethod, showHiddenFiles)
	local sortedFileList = {}
	if sortingMethod == "type" or sortingMethod == 0 then
		local typeList = {}
		for i = 1, #fileList do
			local fileFormat = ecs.getFileFormat(fileList[i]) or "Script"
			if fs.isDirectory(path .. fileList[i]) and fileFormat ~= ".app" then fileFormat = "Folder" end
			typeList[fileFormat] = typeList[fileFormat] or {}
			table.insert(typeList[fileFormat], fileList[i])
		end

		if typeList["Folder"] then
			for i = 1, #typeList["Folder"] do
				table.insert(sortedFileList, typeList["Folder"][i])
			end
			typeList["Folder"] = nil
		end

		for fileFormat in pairs(typeList) do
			for i = 1, #typeList[fileFormat] do
				table.insert(sortedFileList, typeList[fileFormat][i])
			end
		end
	elseif sortingMethod == "name" or sortingMethod == 1 then
		sortedFileList = fileList
	elseif sortingMethod == "date" or sortingMethod == 2 then
		for i = 1, #fileList do
			fileList[i] = {fileList[i], fs.lastModified(path .. fileList[i])}
		end
		table.sort(fileList, function(a,b) return a[2] > b[2] end)
		for i = 1, #fileList do
			table.insert(sortedFileList, fileList[i][1])
		end
	else
		error("Unknown sorting method: " .. tostring(sortingMethod))
	end

	local i = 1
	while i <= #sortedFileList do
		if not showHiddenFiles and ecs.isFileHidden(sortedFileList[i]) then
			table.remove(sortedFileList, i)
		else
			i = i + 1
		end
	end

	return sortedFileList
end

--–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –û–°
function ecs.saveOSSettings()
	local pathToOSSettings = "MineOS/System/OS/OSSettings.cfg"
	if not _G.OSSettings then error("–ú–∞—Å—Å–∏–≤ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –û–° –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ –ø–∞–º—è—Ç–∏!") end
	fs.makeDirectory(fs.path(pathToOSSettings))
	local file = io.open(pathToOSSettings, "w")
	file:write(serialization.serialize(_G.OSSettings))
	file:close()
end

--–ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –û–°, –∞ –µ—Å–ª–∏ –µ–≥–æ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —Ç–æ —Å–æ–∑–¥–∞—Ç—å
function ecs.loadOSSettings()
	local pathToOSSettings = "MineOS/System/OS/OSSettings.cfg"
	if fs.exists(pathToOSSettings) then
		local file = io.open(pathToOSSettings, "r")
		_G.OSSettings = serialization.unserialize(file:read("*a"))
		file:close()
	else
		_G.OSSettings = { showHelpOnApplicationStart = true, language = "Russian" }
		ecs.saveOSSettings()
	end
end

--–û—Ç–æ–±—Ä–∞–∑–∏—Ç—å –æ–∫–Ω–æ —Å —Å–æ–¥–µ—Ä–∂–∏–º—ã–º —Ñ–∞–π–ª–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏
function ecs.applicationHelp(pathToApplication)
	local pathToAboutFile = pathToApplication .. "/resources/About/" .. _G.OSSettings.language .. ".txt"
	if _G.OSSettings and _G.OSSettings.showHelpOnApplicationStart and fs.exists(pathToAboutFile) then
		local applicationName = fs.name(pathToApplication)
		local file = io.open(pathToAboutFile, "r")
		local text = ""
		for line in file:lines() do text = text .. line .. " " end
		file:close()

		local data = ecs.universalWindow("auto", "auto", 30, 0xeeeeee, true,
			{"EmptyLine"},
			{"CenterText", 0x000000, "–û –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ " .. applicationName},
			{"EmptyLine"},
			{"TextField", 16, 0xFFFFFF, 0x262626, 0xcccccc, 0x353535, text},
			{"EmptyLine"},
			{"Button", {ecs.colors.orange, 0x262626, "OK"}, {0x999999, 0xffffff, "–ë–æ–ª—å—à–µ –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å"}}
		)
		if data[1] ~= "OK" then
			_G.OSSettings.showHelpOnApplicationStart = false
			ecs.saveOSSettings()
		end
	end
end

function ecs.correctFileNameIfFileExists(path, requestedName)
	local number = 1
	local fileFormat = ecs.getFileFormat(requestedName) or ""
	requestedName = ecs.hideFileFormat(requestedName)
	while true do
		local finalFileName = requestedName .. string.rep("-copy", number) .. fileFormat
		if fs.exists(path .. "/" .. finalFileName) then
			number = number + 1
		else
			return finalFileName
		end
	end
end

--–°–æ–∑–¥–∞—Ç—å —è—Ä–ª—ã–∫ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –ø—Ä–æ–≥–∏ (–¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–∫–∏)
function ecs.createShortCut(pathToShortcut, pathToFile)
	local pathToPathToShortcut = fs.path(pathToShortcut) or "/"
	fs.makeDirectory(pathToPathToShortcut)
	if fs.exists(pathToShortcut) then
		pathToShortcut = ecs.correctFileNameIfFileExists(pathToPathToShortcut, pathToShortcut)
	end

	local file = io.open(pathToShortcut, "w")
	file:write("return ", "\"", pathToFile, "\"")
	file:close()
end

--–ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –æ —Ñ–∞–π–ª–µ –∏–∑ —è—Ä–ª—ã–∫–∞ (–¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–∫–∏)
function ecs.readShortcut(path)
	local success, filename = pcall(loadfile(path))
	if success then
		return filename
	else
		error("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞ —è—Ä–ª—ã–∫–∞. –í–µ—Ä–æ—è—Ç–Ω–æ, –æ–Ω —Å–æ–∑–¥–∞–Ω –∫—Ä–∏–≤–æ, –ª–∏–±–æ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ –ø–∞–ø–∫–µ \"" .. fs.path(path) or "" .. "\"")
	end
end

--–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ (–¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–∫–∏)
function ecs.editFile(path)
	ecs.prepareToExit()
	shell.execute("edit " .. path)
end

--–ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ –∏ –ø–∞–ø–æ–∫
function ecs.copy(from, toFolder)
	fs.makeDirectory(toFolder)

	if fs.isDirectory(from) then
		local currentAction, yesToAllAction
		local function recursiveFolderCopy(from, to)
			for file in fs.list(from) do
				local finalFromName = from .. "/" .. file
				local finalToName = to .. "/" .. file

				if fs.exists(finalToName) then
					if not yesToAllAction then
						currentAction, yesToAll = ecs.askForReplaceFile(finalToName, true)
						if yesToAll == true then yesToAllAction = true end
					end
				else
					currentAction = 1
				end

				if currentAction == 1 then
					if fs.isDirectory(finalFromName) then
						fs.makeDirectory(finalToName)
						recursiveFolderCopy(finalFromName, finalToName)
					else
						fs.copy(finalFromName, finalToName)
					end
				end
			end
		end

		recursiveFolderCopy(from, toFolder .. fs.name(from))
	else
		local to = toFolder .. "/" .. fs.name(from)
		local action = 1
		if fs.exists(to) then action = ecs.askForReplaceFile(to) end
		if action == 1 then fs.copy(from, to) end
	end
end

-- –ê–Ω–∏–º–∞—Ü–∏—è –∑–∞—Ç—É—Ö–∞–Ω–∏—è —ç–∫—Ä–∞–Ω–∞
function ecs.fadeOut(startColor, targetColor, speed)
	local xSize, ySize = component.gpu.getResolution()
	while startColor >= targetColor do
		component.gpu.setBackground(startColor)
		component.gpu.fill(1, 1, xSize, ySize, " ")
		startColor = startColor - 0x111111
		os.sleep(speed or 0)
	end
end

-- –ê–Ω–∏–º–∞—Ü–∏—è –∑–∞–≥–æ—Ä–∞–Ω–∏—è —ç–∫—Ä–∞–Ω–∞
function ecs.fadeIn(startColor, targetColor, speed)
	local xSize, ySize = component.gpu.getResolution()
	while startColor <= targetColor do
		component.gpu.setBackground(startColor)
		component.gpu.fill(1, 1, xSize, ySize, " ")
		startColor = startColor + 0x111111
		os.sleep(speed or 0)
	end
end

-- –ê–Ω–∏–º–∞—Ü–∏—è –≤—ã—Ö–æ–¥–∞ –≤ –æ–ª–¥—Å–∫—É–ª-—Ç–µ–ª–µ–≤–∏–∑–∏–æ–Ω–Ω–æ–º —Å—Ç–∏–ª–µ
function ecs.TV(speed, targetColor)
	local xSize, ySize = component.gpu.getResolution()
	local xCenter, yCenter = math.floor(xSize / 2), math.floor(ySize / 2)
	component.gpu.setBackground(targetColor or 0x000000)
	
	for y = 1, yCenter do
		component.gpu.fill(1, y - 1, xSize, 1, " ")
		component.gpu.fill(1, ySize - y + 1, xSize, 1, " ")
		os.sleep(speed or 0)
	end
	
	for x = 1, xCenter - 1 do
		component.gpu.fill(x, yCenter, 1, 1, " ")
		component.gpu.fill(xSize - x + 1, yCenter, 1, 1, " ")
		os.sleep(speed or 0)
	end
	os.sleep(0.3)
	component.gpu.fill(1, yCenter, xSize, 1, " ")
end



---------------------------------------------–û–ö–û–®–ï–ß–ö–ò------------------------------------------------------------


--–û–ø–∏—Å–∞–Ω–∏–µ –Ω–∏–∂–µ, –µ–±–∞–Ω–∞. –ù–∏–∂–µ - —ç—Ç–æ –∑–Ω–∞—á–∏—Ç –≤ —Å–∞–º–æ–π –∂–æ–ø–µ –∫–æ–¥–∞!
function ecs.universalWindow(x, y, width, background, closeWindowAfter, ...)
	local objects = {...}
	local countOfObjects = #objects

	local pressedButton
	local pressedMultiButton

	--–ó–∞–¥–∞–µ–º –≤—ã—Å–æ—Ç–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –æ–±—ä–µ–∫—Ç–æ–≤
	local objectsHeights = {
		["button"] = 3,
		["centertext"] = 1,
		["emptyline"] = 1,
		["input"] = 3,
		["slider"] = 3,
		["select"] = 3,
		["selector"] = 3,
		["separator"] = 1,
		["switch"] = 1,
		["color"] = 3,
	}

	--–°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —à–∏—Ä–∏–Ω—É, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
	local function correctWidth(newWidthForAnalyse)
		width = math.max(width, newWidthForAnalyse)
	end

	--–ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —à–∏—Ä–∏–Ω—É
	for i = 1, countOfObjects do
		local objectType = string.lower(objects[i][1])
		
		if objectType == "centertext" then
			correctWidth(unicode.len(objects[i][3]) + 2)
		elseif objectType == "slider" then --!!!!!!!!!!!!!!!!!! –í–û–¢ –¢–£–¢ –ù–ï –ó–ê–ë–£–î–¨ –§–ò–ö–°–ê–ù–£–¢–¨
			correctWidth(unicode.len(objects[i][7]..tostring(objects[i][5].." ")) + 2)
		elseif objectType == "select" then
			for j = 4, #objects[i] do
				correctWidth(unicode.len(objects[i][j]) + 2)
			end
		--elseif objectType == "selector" then
			
		--elseif objectType == "separator" then
			
		elseif objectType == "textfield" then
			correctWidth(5)
		elseif objectType == "wrappedtext" then
			correctWidth(6)
		elseif objectType == "button" then
			--–ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —à–∏—Ä–∏–Ω—É
			local widthOfButtons = 0
			local maxButton = 0
			for j = 2, #objects[i] do
				maxButton = math.max(maxButton, unicode.len(objects[i][j][3]) + 2)
			end
			widthOfButtons = maxButton * #objects[i]
			correctWidth(widthOfButtons)
		elseif objectType == "switch" then
			local dlina = unicode.len(objects[i][5]) + 2 + 10 + 4
			correctWidth(dlina)
		elseif objectType == "color" then 
			correctWidth(unicode.len(objects[i][2]) + 6)
		end
	end

	--–°—á–∏—Ç–∞–µ–º –≤—ã—Å–æ—Ç—É —ç—Ç–æ–π —Ö—É–π–Ω–∏
	local height = 0
	for i = 1, countOfObjects do
		local objectType = string.lower(objects[i][1])
		if objectType == "select" then
			height = height + (objectsHeights[objectType] * (#objects[i] - 3))
		elseif objectType == "textfield" then
			height = height + objects[i][2]
		elseif objectType == "wrappedtext" then
			--–ó–∞—Ä–∞–Ω–µ–µ –ø–∞—Ä—Å–∏–º —Ç–µ–∫—Å—Ç –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω–Ω—ã–π
			objects[i].wrapped = string.wrap({objects[i][3]}, width - 4)
			objects[i].height = #objects[i].wrapped
			height = height + objects[i].height
		else
			height = height + objectsHeights[objectType]
		end
	end

	--–ö–æ–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —Å—Ç–∞—Ä—Ç–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
	x, y = ecs.correctStartCoords(x, y, width, height)
	--–ó–∞–ø–æ–º–∏–Ω–∞–µ–º –∏–Ω—Ñ—É –æ —Ç–æ–º, —á—Ç–æ –±—ã–ª–æ –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω–æ, –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ
	local oldPixels, oldBackground, oldForeground
	if closeWindowAfter then
		oldBackground = component.gpu.getBackground()
		oldForeground = component.gpu.getForeground()
		oldPixels = ecs.rememberOldPixels(x, y, x + width - 1, y + height - 1)
	end
	--–°—á–∏—Ç–∞–µ–º –≤—Å–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –æ–±—ä–µ–∫—Ç–æ–≤
	objects[1].y = y
	if countOfObjects > 1 then
		for i = 2, countOfObjects do
			local objectType = string.lower(objects[i - 1][1])
			if objectType == "select" then
				objects[i].y = objects[i - 1].y + (objectsHeights[objectType] * (#objects[i - 1] - 3))
			elseif objectType == "textfield" then
				objects[i].y = objects[i - 1].y + objects[i - 1][2]
			elseif objectType == "wrappedtext" then
				objects[i].y = objects[i - 1].y + objects[i - 1].height
			else
				objects[i].y = objects[i - 1].y + objectsHeights[objectType]
			end
		end
	end

	--–û–±—ä–µ–∫—Ç—ã –¥–ª—è —Ç–∞—á–∞
	local obj = {}
	local function newObj(class, name, ...)
		obj[class] = obj[class] or {}
		obj[class][name] = {...}
	end

	--–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞ –ø–æ –Ω–æ–º–µ—Ä—É
	local function displayObject(number, active)
		local objectType = string.lower(objects[number][1])
				
		if objectType == "centertext" then
			local xPos = x + math.floor(width / 2 - unicode.len(objects[number][3]) / 2)
			component.gpu.setForeground(objects[number][2])
			component.gpu.setBackground(background)
			component.gpu.set(xPos, objects[number].y, objects[number][3])
		
		elseif objectType == "input" then

			if active then
				--–†–∞–º–æ—á–∫–∞
				ecs.border(x + 1, objects[number].y, width - 2, objectsHeights.input, background, objects[number][3])
				--–¢–µ—Å—Ç–∏–∫
				objects[number][4] = ecs.inputText(x + 3, objects[number].y + 1, width - 6, "", background, objects[number][3], false, objects[number][5])
			else
				--–†–∞–º–æ—á–∫–∞
				ecs.border(x + 1, objects[number].y, width - 2, objectsHeights.input, background, objects[number][2])
				--–¢–µ–∫—Å—Ç–∏–∫
				component.gpu.set(x + 3, objects[number].y + 1, ecs.stringLimit("start", objects[number][4], width - 6))
				ecs.inputText(x + 3, objects[number].y + 1, width - 6, objects[number][4], background, objects[number][2], true, objects[number][5])
			end

			newObj("Inputs", number, x + 1, objects[number].y, x + width - 2, objects[number].y + 2)

		elseif objectType == "slider" then
			local widthOfSlider = width - 2
			local xOfSlider = x + 1
			local yOfSlider = objects[number].y + 1
			local countOfSliderThings = objects[number][5] - objects[number][4]
			local showSliderValue= objects[number][7]

			local dolya = widthOfSlider / countOfSliderThings
			local position = math.floor(dolya * objects[number][6])
			--–ö–æ—Å—Ç—ã–ª—å
			if (xOfSlider + position) > (xOfSlider + widthOfSlider - 1)	then position = widthOfSlider - 2 end

			--–î–≤–µ –ª–∏–Ω–∏–∏
			ecs.separator(xOfSlider, yOfSlider, position, background, objects[number][3])
			ecs.separator(xOfSlider + position, yOfSlider, widthOfSlider - position, background, objects[number][2])
			--–°–ª—É–¥–∏—Ä
			ecs.square(xOfSlider + position, yOfSlider, 2, 1, objects[number][3])

			--–¢–µ–∫—Å—Ç–∏–∫ –ø–æ–¥ —Å–ª—É–¥–∏—Ä–æ–º
			if showSliderValue then
				local text = showSliderValue .. tostring(objects[number][6]) .. (objects[number][8] or "")
				local textPos = (xOfSlider + widthOfSlider / 2 - unicode.len(text) / 2)
				ecs.square(x, yOfSlider + 1, width, 1, background)
				ecs.colorText(textPos, yOfSlider + 1, objects[number][2], text)
			end

			newObj("Sliders", number, xOfSlider, yOfSlider, x + widthOfSlider, yOfSlider, dolya)

		elseif objectType == "select" then
			local usualColor = objects[number][2]
			local selectionColor = objects[number][3]

			objects[number].selectedData = objects[number].selectedData or 1

			local symbol = "‚úî"
			local yPos = objects[number].y
			for i = 4, #objects[number] do
				--–ö–æ—Ä–æ–±–∫–∞ –¥–ª—è –≥–∞–ª–æ—á–∫–∏
				ecs.border(x + 1, yPos, 5, 3, background, usualColor)
				--–¢–µ–∫—Å—Ç
				component.gpu.set(x + 7, yPos + 1, objects[number][i])
				--–ì–∞–ª–æ—á–∫–∞
				if objects[number].selectedData == (i - 3) then
					ecs.colorText(x + 3, yPos + 1, selectionColor, symbol)
				else
					component.gpu.set(x + 3, yPos + 1, "  ")
				end

				obj["Selects"] = obj["Selects"] or {}
				obj["Selects"][number] = obj["Selects"][number] or {}
				obj["Selects"][number][i - 3] = { x + 1, yPos, x + width - 2, yPos + 2 }

				yPos = yPos + objectsHeights.select
			end

		elseif objectType == "selector" then
			local borderColor = objects[number][2]
			local arrowColor = objects[number][3]
			local selectorWidth = width - 2
			objects[number].selectedElement = objects[number].selectedElement or objects[number][4]

			local topLine = "‚îå" .. string.rep("‚îÄ", selectorWidth - 6) .. "‚î¨‚îÄ‚îÄ‚îÄ‚îê"
			local midLine = "‚îÇ" .. string.rep(" ", selectorWidth - 6) .. "‚îÇ   ‚îÇ"
			local botLine = "‚îî" .. string.rep("‚îÄ", selectorWidth - 6) .. "‚î¥‚îÄ‚îÄ‚îÄ‚îò"

			local yPos = objects[number].y

			local function bordak(borderColor)
				component.gpu.setBackground(background)
				component.gpu.setForeground(borderColor)
				component.gpu.set(x + 1, objects[number].y, topLine)
				component.gpu.set(x + 1, objects[number].y + 1, midLine)
				component.gpu.set(x + 1, objects[number].y + 2, botLine)
				component.gpu.set(x + 3, objects[number].y + 1, ecs.stringLimit("start", objects[number].selectedElement, width - 6))
				ecs.colorText(x + width - 4, objects[number].y + 1, arrowColor, "‚ñº")
			end

			bordak(borderColor)
		
			--–í—ã–ø–∞–¥–∞—é—â–∏–π —Å–ø–∏—Å–æ–∫, —Å–∞–º—ã–π –≥–µ–º–æ—Ä, –±–ª—è–¥—å
			if active then
				local xPos, yPos = x + 1, objects[number].y + 3
				local spisokWidth = width - 2
				local countOfElements = #objects[number] - 3
				local spisokHeight = countOfElements + 1
				local oldPixels = ecs.rememberOldPixels( xPos, yPos, xPos + spisokWidth - 1, yPos + spisokHeight - 1)

				local coords = {}

				bordak(arrowColor)

				--–†–∞–º–∫—É —Ä–∏—Å—É–µ–º –ø–æ–≤–µ—Ä—Ö —Ñ–æ–Ω–∏–∫–∞
				local topLine = "‚îú"..string.rep("‚îÄ", spisokWidth - 6).."‚î¥‚îÄ‚îÄ‚îÄ‚î§"
				local midLine = "‚îÇ"..string.rep(" ", spisokWidth - 2).."‚îÇ"
				local botLine = "‚îî"..string.rep("‚îÄ", selectorWidth - 2) .. "‚îò"
				ecs.colorTextWithBack(xPos, yPos - 1, arrowColor, background, topLine)
				for i = 1, spisokHeight - 1 do
					component.gpu.set(xPos, yPos + i - 1, midLine)
				end
				component.gpu.set(xPos, yPos + spisokHeight - 1, botLine)

				--–≠–ª–µ–º–µ–Ω—Ç—ã —Ä–∏—Å—É–µ–º
				xPos = xPos + 2
				for i = 1, countOfElements do
					ecs.colorText(xPos, yPos, borderColor, ecs.stringLimit("start", objects[number][i + 3], spisokWidth - 4))
					coords[i] = {xPos - 1, yPos, xPos + spisokWidth - 4, yPos}
					yPos = yPos + 1
				end

				--–û–±—Ä–∞–±–æ—Ç–∫–∞
				local exit
				while true do
					if exit then break end
					local e = {event.pull()}
					if e[1] == "touch" then
						for i = 1, #coords do
							if ecs.clickedAtArea(e[3], e[4], coords[i][1], coords[i][2], coords[i][3], coords[i][4]) then
								ecs.square(coords[i][1], coords[i][2], spisokWidth - 2, 1, ecs.colors.blue)
								ecs.colorText(coords[i][1] + 1, coords[i][2], 0xffffff, objects[number][i + 3])
								os.sleep(0.3)
								objects[number].selectedElement = objects[number][i + 3]
								exit = true
								break
							end
						end
					end
				end

				ecs.drawOldPixels(oldPixels)
			end

			newObj("Selectors", number, x + 1, objects[number].y, x + width - 2, objects[number].y + 2)

		elseif objectType == "separator" then
			ecs.separator(x, objects[number].y, width, background, objects[number][2])
		
		elseif objectType == "textfield" then
			newObj("TextFields", number, x + 1, objects[number].y, x + width - 2, objects[number].y + objects[number][2] - 1)
			if not objects[number].strings then objects[number].strings = string.wrap({objects[number][7]}, width - 3) end
			objects[number].displayFrom = objects[number].displayFrom or 1
			ecs.textField(x, objects[number].y, width, objects[number][2], objects[number].strings, objects[number].displayFrom, objects[number][3], objects[number][4], objects[number][5], objects[number][6])
		
		elseif objectType == "wrappedtext" then
			component.gpu.setBackground(background)
			component.gpu.setForeground(objects[number][2])
			for i = 1, #objects[number].wrapped do
				component.gpu.set(x + 2, objects[number].y + i - 1, objects[number].wrapped[i])
			end

		elseif objectType == "button" then

			obj["MultiButtons"] = obj["MultiButtons"] or {}
			obj["MultiButtons"][number] = {}

			local widthOfButton = math.floor(width / (#objects[number] - 1))

			local xPos, yPos = x, objects[number].y
			for i = 1, #objects[number] do
				if type(objects[number][i]) == "table" then
					local x1, y1, x2, y2 = ecs.drawButton(xPos, yPos, widthOfButton, 3, objects[number][i][3], objects[number][i][1], objects[number][i][2])
					table.insert(obj["MultiButtons"][number], {x1, y1, x2, y2, widthOfButton})
					xPos = x2 + 1

					if i == #objects[number] then
						ecs.square(xPos, yPos, x + width - xPos, 3, objects[number][i][1])
						obj["MultiButtons"][number][i - 1][5] = obj["MultiButtons"][number][i - 1][5] + x + width - xPos
					end

					x1, y1, x2, y2 = nil, nil, nil, nil
				end
			end

		elseif objectType == "switch" then

			local xPos, yPos = x + 2, objects[number].y
			local activeColor, passiveColor, textColor, text, state = objects[number][2], objects[number][3], objects[number][4], objects[number][5], objects[number][6]
			local switchWidth = 8
			ecs.colorTextWithBack(xPos, yPos, textColor, background, text)

			xPos = x + width - switchWidth - 2
			if state then
				ecs.square(xPos, yPos, switchWidth, 1, activeColor)
				ecs.square(xPos + switchWidth - 2, yPos, 2, 1, passiveColor)
				--ecs.colorTextWithBack(xPos + 4, yPos, passiveColor, activeColor, "ON")
			else
				ecs.square(xPos, yPos, switchWidth, 1, passiveColor - 0x444444)
				ecs.square(xPos, yPos, 2, 1, passiveColor)
				--ecs.colorTextWithBack(xPos + 4, yPos, passiveColor, passiveColor - 0x444444, "OFF")
			end
			newObj("Switches", number, xPos, yPos, xPos + switchWidth - 1, yPos)

		elseif objectType == "color" then
			local xPos, yPos = x + 1, objects[number].y
			local blendedColor = require("colorlib").alphaBlend(objects[number][3], 0xFFFFFF, 180)
			local w = width - 2

			ecs.colorTextWithBack(xPos, yPos + 2, blendedColor, background, string.rep("‚ñÄ", w))
			ecs.colorText(xPos, yPos, objects[number][3], string.rep("‚ñÑ", w))
			ecs.square(xPos, yPos + 1, w, 1, objects[number][3])		

			ecs.colorText(xPos + 1, yPos + 1, 0xffffff - objects[number][3], objects[number][2])
			newObj("Colors", number, xPos, yPos, x + width - 2, yPos + 2)
		end
	end

	--–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤—Å–µ—Ö –æ–±—ä–µ–∫—Ç–æ–≤
	local function displayAllObjects()
		for i = 1, countOfObjects do
			displayObject(i)
		end
	end

	--–ü–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –º–∞—Å—Å–∏–≤ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–π
	local function getReturn()
		local massiv = {}

		for i = 1, countOfObjects do
			local type = string.lower(objects[i][1])

			if type == "button" then
				table.insert(massiv, pressedButton)
			elseif type == "input" then
				table.insert(massiv, objects[i][4])
			elseif type == "select" then
				table.insert(massiv, objects[i][objects[i].selectedData + 3])
			elseif type == "selector" then
				table.insert(massiv, objects[i].selectedElement)
			elseif type == "slider" then
				table.insert(massiv, objects[i][6])
			elseif type == "switch" then
				table.insert(massiv, objects[i][6])
			elseif type == "color" then
				table.insert(massiv, objects[i][3])	
			else
				table.insert(massiv, nil)
			end
		end

		return massiv
	end

	local function redrawBeforeClose()
		if closeWindowAfter then
			ecs.drawOldPixels(oldPixels)
			component.gpu.setBackground(oldBackground)
			component.gpu.setForeground(oldForeground)
		end
	end

	--–†–∏—Å—É–µ–º –æ–∫–Ω–æ
	ecs.square(x, y, width, height, background)
	displayAllObjects()

	while true do
		local e = {event.pull()}
		if e[1] == "touch" or e[1] == "drag" then

			--–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–ª–∏–∫ –Ω–∞ –∫–Ω–æ–ø–∫–∏
			if obj["MultiButtons"] then
				for key in pairs(obj["MultiButtons"]) do
					for i = 1, #obj["MultiButtons"][key] do
						if ecs.clickedAtArea(e[3], e[4], obj["MultiButtons"][key][i][1], obj["MultiButtons"][key][i][2], obj["MultiButtons"][key][i][3], obj["MultiButtons"][key][i][4]) then
							ecs.drawButton(obj["MultiButtons"][key][i][1], obj["MultiButtons"][key][i][2], obj["MultiButtons"][key][i][5], 3, objects[key][i + 1][3], objects[key][i + 1][2], objects[key][i + 1][1])
							os.sleep(0.3)
							pressedButton = objects[key][i + 1][3]
							redrawBeforeClose()
							return getReturn()
						end
					end
				end
			end

			--–ê —Ç–µ–ø–µ—Ä—å –∫–ª–∏–∫ –Ω–∞ –∏–Ω–ø—É—Ç—ã!
			if obj["Inputs"] then
				for key in pairs(obj["Inputs"]) do
					if ecs.clickedAtArea(e[3], e[4], obj["Inputs"][key][1], obj["Inputs"][key][2], obj["Inputs"][key][3], obj["Inputs"][key][4]) then
						displayObject(key, true)
						displayObject(key)
						break
					end
				end
			end

			--–ê —Ç–µ–ø–µ—Ä—å –≥–∞–ª–æ—á–∫–æ–≤—ã–±–æ—Ä!
			if obj["Selects"] then
				for key in pairs(obj["Selects"]) do
					for i in pairs(obj["Selects"][key]) do
						if ecs.clickedAtArea(e[3], e[4], obj["Selects"][key][i][1], obj["Selects"][key][i][2], obj["Selects"][key][i][3], obj["Selects"][key][i][4]) then
							objects[key].selectedData = i
							displayObject(key)
							break
						end
					end
				end
			end

			--–•–º, –∞ –≤–æ—Ç –∏ —Å–µ–ª–µ–∫—Ç–æ—Ä –ø–æ–¥—ä–µ—Ö–∞–ª!
			if obj["Selectors"] then
				for key in pairs(obj["Selectors"]) do
					if ecs.clickedAtArea(e[3], e[4], obj["Selectors"][key][1], obj["Selectors"][key][2], obj["Selectors"][key][3], obj["Selectors"][key][4]) then
						displayObject(key, true)
						displayObject(key)
						break
					end
				end
			end

			--–°–ª–∞–π–¥–µ—Ä—ã, –µ–ø—Ç–∞! "–ü–æ—Ç–Ω—ã–π –º–∞—Ç–∞–Ω", –≤—Å–µ –¥–µ–ª—ã
			if obj["Sliders"] then
				for key in pairs(obj["Sliders"]) do
					if ecs.clickedAtArea(e[3], e[4], obj["Sliders"][key][1], obj["Sliders"][key][2], obj["Sliders"][key][3], obj["Sliders"][key][4]) then
						local xOfSlider, dolya = obj["Sliders"][key][1], obj["Sliders"][key][5]
						local currentPixels = e[3] - xOfSlider
						local currentValue = math.floor(currentPixels / dolya)
						--–ö–æ—Å—Ç—ã–ª—å
						if e[3] == obj["Sliders"][key][3] then currentValue = objects[key][5] end
						objects[key][6] = currentValue or objects[key][6]
						displayObject(key)
						break
					end
				end
			end

			if obj["Switches"] then
				for key in pairs(obj["Switches"]) do
					if ecs.clickedAtArea(e[3], e[4], obj["Switches"][key][1], obj["Switches"][key][2], obj["Switches"][key][3], obj["Switches"][key][4]) then
						objects[key][6] = not objects[key][6]
						displayObject(key)
						break
					end
				end
			end

			if obj["Colors"] then
				for key in pairs(obj["Colors"]) do
					if ecs.clickedAtArea(e[3], e[4], obj["Colors"][key][1], obj["Colors"][key][2], obj["Colors"][key][3], obj["Colors"][key][4]) then
						local oldColor = objects[key][3]
						objects[key][3] = 0xffffff - objects[key][3]
						displayObject(key)
						os.sleep(0.3)
						objects[key][3] = oldColor
						displayObject(key)

						local paletteWidth, paletteHeight = 75, 27
						local screenWidth, screenHeight = component.gpu.getResolution()
						local paletteX, paletteY = math.floor(screenWidth / 2 - paletteWidth / 2), math.floor(screenHeight / 2 - paletteHeight / 2)
						local oldPixels = ecs.rememberOldPixels(paletteX, paletteY, paletteX + paletteWidth - 1, paletteY + paletteHeight - 1)
						local color = require("palette").draw("auto", "auto", objects[key][3])
						ecs.drawOldPixels(oldPixels)
						objects[key][3] = color or oldColor

						displayObject(key)
						break
					end
				end
			end

		elseif e[1] == "scroll" then
			if obj["TextFields"] then
				for key in pairs(obj["TextFields"]) do
					if ecs.clickedAtArea(e[3], e[4], obj["TextFields"][key][1], obj["TextFields"][key][2], obj["TextFields"][key][3], obj["TextFields"][key][4]) then
						if e[5] == 1 then
							if objects[key].displayFrom > 1 then objects[key].displayFrom = objects[key].displayFrom - 1; displayObject(key) end
						else
							if objects[key].displayFrom < #objects[key].strings then objects[key].displayFrom = objects[key].displayFrom + 1; displayObject(key) end
						end
					end
				end
			end
		elseif e[1] == "key_down" then
			if e[4] == 28 then
				redrawBeforeClose()
				return getReturn()
			end
		end
	end
end

--–î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω–æ–µ –æ–∫–Ω–æ, –ø–æ–∫–∞–∑—ã–≤–∞—é—â–µ–µ –≤—Å—é –º–æ—â—å universalWindow
function ecs.demoWindow()
	--–û—á–∏—â–∞–µ–º —ç–∫—Ä–∞–Ω –ø–µ—Ä–µ–¥ —é–∑–∞–Ω–∏–µ–º –æ–∫–Ω–∞ –∏ —Å—Ç–∞–≤–∏–º –∫—É—Ä—Å–æ—Ä –Ω–∞ 1, 1
	ecs.prepareToExit()
	--–†–∏—Å—É–µ–º –æ–∫–Ω–æ –∏ –ø–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ—Å–ª–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –Ω–∏–º
	local data = ecs.universalWindow("auto", "auto", 36, 0xeeeeee, true,
		{"EmptyLine"},
		{"CenterText", 0x880000, "–ó–¥–æ—Ä–æ–≤–æ, –µ–±–∞–Ω–∞!"},
		{"EmptyLine"},
		{"Input", 0x262626, 0x880000, "–°—é–¥–∞ –≤–≤–æ–¥–∏—Ç—å –º–æ–∂–Ω–æ"},
		{"Selector", 0x262626, 0x880000, "–í—ã–±–æ—Ä —Ñ–æ—Ä–º–∞—Ç–∞", "PNG", "JPG", "GIF", "PSD"},
		{"EmptyLine"},
		{"WrappedText", 0x262626, "–¢–µ—Å—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–µ—Ä–µ–Ω–æ—Å–∞ –±—É–∫–≤ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —à–∏—Ä–∏–Ω—ã –¥–∞–Ω–Ω–æ–≥–æ –æ–∫–Ω–∞. –ü–æ–∫–∞ —á—Ç–æ —Ç—É–ø–æ —Ä–µ–∂–µ—Ç –Ω–∞ –∫—É—Å–∫–∏, –Ω–µ –æ—Å–æ–±–æ –∫—Ä–∞—Å–∏–≤–æ."},
		{"EmptyLine"},
		{"Select", 0x262626, 0x880000, "–Ø –ø–∏–¥–æ—Ä", "–Ø –Ω–µ –ø–∏–¥–æ—Ä"},
		{"Slider", 0x262626, 0x880000, 1, 100, 50, "–£–±–∏—Ç–æ ", " –º–ª–∞–¥–µ–Ω—Ü–µ–≤"},
		{"EmptyLine"},
		{"Separator", 0xaaaaaa},
		{"Switch", 0xF2B233, 0xffffff, 0x262626, "‚úà –ê–≤–∏–∞—Ä–µ–∂–∏–º", false},
		{"EmptyLine"},
		{"Switch", 0x3366CC, 0xffffff, 0x262626, "‚òæ  –ù–µ –±–µ—Å–ø–æ–∫–æ–∏—Ç—å", true},
		{"Separator", 0xaaaaaa},
		{"EmptyLine"},
		{"TextField", 5, 0xffffff, 0x262626, 0xcccccc, 0x3366CC, "–¢–µ—Å—Ç —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ –ø–æ–ª—è. –ü–æ —Å—É—Ç–∏ —ç—Ç–æ —Ç–æ—Ç –∂–µ —Å–∞–º—ã–π WrappedText, —Ä–∞–∑–≤–µ —á—Ç–æ —ç—Ç–∞ —Ö—Ä–µ–Ω—å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∞ –ø–æ –≤—ã—Å–æ—Ç–µ, –∏ –µ–µ –º–æ–∂–Ω–æ —Å–∫—Ä–æ–ª–ª–∏—Ç—å. –ù—É –∂–µ, –ø–æ—Å–∫—Ä–æ–ª–ª—å –º–µ–Ω—è! –°–∫—Ä–æ–ª–ª—å –º–µ–Ω—è –ø–æ–ª–Ω–æ—Å—Ç—å—é! –ú–æ—è –∂–∞–¥–Ω–∞—è –ø–∏–∑–¥–∞ –∂–∞–∂–¥–µ—Ç —Ç–≤–æ–π —Ö—É–π!"},
		{"Color", "–¶–≤–µ—Ç —Ñ–æ–Ω–∞", 0xFF0000},
		{"EmptyLine"},
		{"Button", {0x57A64E, 0xffffff, "–î–∞"}, {0xF2B233, 0xffffff, "–ù–µ—Ç"}, {0xCC4C4C, 0xffffff, "–û—Ç–º–µ–Ω–∞"}}
	)
	--–ï—â–µ —Ä–∞–∑–æ–∫
	ecs.prepareToExit()
	--–í—ã–≤–æ–¥–∏–º –¥–∞–Ω–Ω—ã–µ
	print(" ")
	print("–í—ã–≤–æ–¥ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –æ–∫–Ω–∞:")
	for i = 1, #data do print("["..i.."] = "..tostring(data[i])) end
	print(" ")
end

-- ecs.demoWindow()

--[[
–§—É–Ω–∫—Ü–∏—è universalWindow(x, y, width, background, closeWindowAfter, ...)

	–≠—Ç–æ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –º–æ–¥—É–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ —É–¥–æ–±–Ω–æ–≥–æ –∏ –±—ã—Å—Ç—Ä–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
	–Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–π –≤–∞–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏. –° –µ–µ –ø–æ–º–æ—â—å—é –≤–≤–æ–¥–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã, –æ—Å—É—â–µ—Å—Ç–≤–ª—è—Ç—å –≤—ã–±–æ—Ä
	–∏–∑ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤, —Ä–∏—Å–æ–≤–∞—Ç—å –∫—Ä–∞—Å–∏–≤—ã–µ –∫–Ω–æ–ø–∫–∏, –æ—Ç—Ä–∏—Å–æ–≤—ã–≤–∞—Ç—å –æ–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç,
	–æ—Ç—Ä–∏—Å–æ–≤—ã–≤–∞—Ç—å —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –ø–æ–ª—è —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –ø—Ä–æ–∫—Ä—É—Ç–∫–∏, —Ä–∏—Å–æ–≤–∞—Ç—å —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏ –∏ –ø—Ä–æ—á–µ–µ.
	–õ—é–±–æ–π –æ–±—ä–µ–∫—Ç –≤—ã–¥–µ–ª—è–µ—Ç—Å—è —Å –ø–æ–º–æ—â—å—é –∫–ª–∏–∫–∞ –º—ã—à–∏, –ø–æ—Å–ª–µ —á–µ–≥–æ —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–∏—Å—Ç—É–ø–∞–µ—Ç –∫ —Ä–∞–±–æ—Ç–µ
	—Å —ç—Ç–∏–º –æ–±—ä–µ–∫—Ç–æ–º.
 
–ê—Ä–≥—É–º–µ–Ω—Ç—ã —Ñ—É–Ω–∫—Ü–∏–∏:

	x –∏ y: —ç—Ç–æ —á–∏—Å–ª–∞, –æ–±–æ–∑–Ω–∞—á–∞—é—â–∏–µ —Å—Ç–∞—Ä—Ç–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ª–µ–≤–æ–≥–æ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É–≥–ª–∞ –¥–∞–Ω–Ω–æ–≥–æ –æ–∫–Ω–∞.
	–í–º–µ—Å—Ç–æ —Ü–∏—Ñ—Ä –≤—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç–µ –Ω–∞–ø–∏—Å–∞—Ç—å "auto" - –∏ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–∞–∑–º–µ—Å—Ç–∏—Ç –æ–∫–Ω–æ
	–ø–æ —Ü–µ–Ω—Ç—Ä—É —ç–∫—Ä–∞–Ω–∞ –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–µ. –ò–ª–∏ –ø–æ –æ–±–µ–∏–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º, –µ—Å–ª–∏ –≤–∞–º —É–≥–æ–¥–Ω–æ.
	 
	width: —ç—Ç–æ —à–∏—Ä–∏–Ω–∞ –æ–∫–Ω–∞, –∫–æ—Ç–æ—Ä—É—é –≤—ã –º–æ–∂–µ—Ç–µ –∑–∞–¥–∞—Ç—å –ø–æ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–º—É –∂–µ–ª–∞–Ω–∏—é. –ï—Å–ª–∏ –Ω–µ–∫—Ç–æ—Ä—ã–µ
	–æ–±—ä–µ–∫—Ç—ã —Ç—Ä–µ–±—É—é—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è –æ–∫–Ω–∞, —Ç–æ –æ–∫–Ω–æ –±—É–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–æ –¥–æ –Ω—É–∂–Ω–æ–π —à–∏—Ä–∏–Ω—ã.
	–î–∞, –≤–æ—Ç —Ç–∞–∫–∞—è –≤–æ—Ç —Ç–∞–≤—Ç–æ–ª–æ–≥–∏—è ;)

	background: –±–∞–∑–æ–≤—ã–π —Ü–≤–µ—Ç –æ–∫–Ω–∞ (—Ü–≤–µ—Ç —Ñ–æ–Ω–∞, –∫–æ–º—É –∫–∞–∫ –ø–æ–Ω—è—Ç–Ω–µ–µ).

	closeWindowAfter: e—Å–ª–∏ true, —Ç–æ –æ–∫–Ω–æ –ø–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—é —Ñ—É–Ω–∫—Ü–∏–∏ –±—É–¥–µ—Ç –≤—ã–≥—Ä—É–∂–µ–Ω–æ, –∞ –Ω–∞ –µ–≥–æ –º–µ—Å—Ç–µ
	–æ—Ç—Ä–∏—Å—É—é—Ç—Å—è –ø–∏–∫—Å–µ–ª–∏, –∫–æ—Ç–æ—Ä—ã–µ –∏–º–µ–ª–∏—Å—å –Ω–∞ —ç–∫—Ä–∞–Ω–µ –¥–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏. –£–¥–æ–±–Ω–æ, –µ—Å–ª–∏ –Ω–µ —Ö–æ—á–µ—à—å
	–ø–∞—Ä–∏—Ç—å—Å—è —Å –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞.

	... : –º–Ω–æ–≥–æ—Ç–æ—á–∏–µ–º —Ç—É—Ç —è–≤–ª—è–µ—Ç—Å—è –ø–µ—Ä–µ—á–µ–Ω—å –æ–±—ä–µ–∫—Ç–æ–≤, —É–∫–∞–∑–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é. –ö–∞–∂–¥—ã–π –æ–±—ä–µ–∫—Ç
	—è–≤–ª—è–µ—Ç—Å—è –º–∞—Å—Å–∏–≤–æ–º –∏ –∏–º–µ–µ—Ç —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ù–∏–∂–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω—ã –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Ç–∏–ø—ã –æ–±—ä–µ–∫—Ç–æ–≤.
		
		{"Button", {–¶–≤–µ—Ç –∫–Ω–æ–ø–∫–∏1, –¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ –Ω–∞ –∫–Ω–æ–ø–∫–µ1, –°–∞–º —Ç–µ–∫—Å—Ç1}, {–¶–≤–µ—Ç –∫–Ω–æ–ø–∫–∏2, –¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ –Ω–∞ –∫–Ω–æ–ø–∫–µ2, –°–∞–º —Ç–µ–∫—Å—Ç2}, ...}

			–≠—Ç–æ –æ–±—ä–µ–∫—Ç –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è –∫–Ω–æ–ø–æ–∫. –ö–∞–∂–¥–∞—è –∫–Ω–æ–ø–∫–∞ - —ç—Ç–æ –º–∞—Å—Å–∏–≤, —Å–æ—Å—Ç–æ—è—â–∏–π –∏–∑ —Ç—Ä–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤:
			—Ü–≤–µ—Ç–∞ –∫–Ω–æ–ø–∫–∏, —Ü–≤–µ—Ç–∞ —Ç–µ–∫—Å—Ç–∞ –Ω–∞ –∫–Ω–æ–ø–∫–µ –∏ —Å–∞–º–æ–≥–æ —Ç–µ–∫—Å—Ç–∞. –ö–Ω–æ–ø–æ–∫ –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ,
			–æ–¥–Ω–∞–∫–æ —á–µ–º –∏—Ö –±–æ–ª—å—à–µ, —Ç–µ–º –±–æ–ª—å—à–µ–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–∞ –ø–æ —à–∏—Ä–∏–Ω–µ.

			–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –æ–±—ä–µ–∫—Ç.

		{"Input", –¶–≤–µ—Ç —Ä–∞–º–∫–∏ –∏ —Ç–µ–∫—Å—Ç–∞, –¶–≤–µ—Ç –ø—Ä–∏ –≤—ã–¥–µ–ª–µ–Ω–∏–∏, –°—Ç–∞—Ä—Ç–æ–≤—ã–π —Ç–µ–∫—Å—Ç [, –ú–∞—Å–∫–∏—Ä–æ–≤–∞—Ç—å —Å–∏–º–≤–æ–ª–æ–º]}

			–û–±—ä–µ–∫—Ç –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è –ø–æ–ª–µ–π –≤–≤–æ–¥–∞ —Ç–µ–∫—Å—Ç–æ–≤–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏. –£–¥–æ–±–Ω–æ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –∏–ª–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤,
			–û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∞—Ä–≥—É–º–µ–Ω—Ç "–ú–∞—Å–∫–∏—Ä–æ–≤–∞—Ç—å —Å–∏–º–≤–æ–ª–æ–º" –ø–æ–ª–µ–∑–µ–Ω, –µ—Å–ª–∏ –≤—ã –¥–µ–ª–∞–µ—Ç–µ –ø–æ–ª–µ –¥–ª—è –≤–≤–æ–¥–∞ –ø–∞—Ä–æ–ª—è.
			–ù–∏–∫—Ç–æ –Ω–µ —É–≤–∏–¥–∏—Ç –≤–∞—à —Ç–µ–∫—Å—Ç. –í –∫–∞—á–µ—Å—Ç–≤–µ –¥–∞–Ω–Ω–æ–≥–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è —Å–∏–º–≤–æ–ª, –Ω–∞–ø—Ä–∏–º–µ—Ä "*".

			–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –æ–±—ä–µ–∫—Ç.

		{"Selector", –¶–≤–µ—Ç —Ä–∞–º–∫–∏, –¶–≤–µ—Ç –ø—Ä–∏ –≤—ã–¥–µ–ª–µ–Ω–∏–∏, –í—ã–±–æ—Ä 1, –í—ã–±–æ—Ä 2, –í—ã–±–æ—Ä 3 ...}

			–í–Ω–µ—à–Ω–µ —Å—Ö–æ–∂ —Å –æ–±—ä–µ–∫—Ç–æ–º "Input", –æ–¥–Ω–∞–∫–æ –≤ —ç—Ç–æ–º —Å–ª—É—á–∞–µ –≤—ã –±—É–¥–µ—Ç–µ –≤—ã–±–∏—Ä–∞—Ç—å –æ–¥–∏–Ω –∏–∑ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö
			–≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –∏–∑ –≤—ã–ø–∞–¥–∞—é—â–µ–≥–æ —Å–ø–∏—Å–∫–∞. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤—ã–±—Ä–∞–Ω –ø–µ—Ä–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç.

			–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –æ–±—ä–µ–∫—Ç.

		{"Select", –¶–≤–µ—Ç —Ä–∞–º–∫–∏, –¶–≤–µ—Ç –≥–∞–ª–æ—á–∫–∏, –í—ã–±–æ—Ä 1, –í—ã–±–æ—Ä 2, –í—ã–±–æ—Ä 3 ...}

			–û–±—ä–µ–∫—Ç –≤—ã–±–æ—Ä–∞. –û—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç "Selector" —Ç–µ–º, —á—Ç–æ –∑–¥–µ—Å—å –≤—ã –≤—ã–±–∏—Ä–∞–µ—Ç–µ –æ–¥–∏–Ω –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤, –æ—Ç–º–µ—á–∞—è
			–µ–≥–æ –≥–∞–ª–æ—á–∫–æ–π. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤—ã–±—Ä–∞–Ω –ø–µ—Ä–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç.

			–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –æ–±—ä–µ–∫—Ç. 

		{"Slider", –¶–≤–µ—Ç –ª–∏–Ω–∏–∏ —Å–ª–∞–π–¥–µ—Ä–∞, –¶–≤–µ—Ç –ø–∏–º–ø–æ—á–∫–∏ —Å–ª–∞–π–¥–µ—Ä–∞, –ó–Ω–∞—á–µ–Ω–∏—è —Å–ª–∞–π–¥–µ—Ä–∞ –û–¢, –ó–Ω–∞—á–µ–Ω–∏—è —Å–ª–∞–π–¥–µ—Ä–∞ –î–û, –¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ [, –¢–µ–∫—Å—Ç-–ø–æ–¥—Å–∫–∞–∑–∫–∞ –î–û] [, –¢–µ–∫—Å—Ç-–ø–æ–¥—Å–∫–∞–∑–∫–∞ –ü–û–°–õ–ï]}

			–ü–æ–ª–∑—É–Ω–æ–∫, –ø–æ–∑–≤–æ–ª—è—é—â–∏–π –∑–∞–¥–∞–≤–∞—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–µ–≥–æ-–ª–∏–±–æ –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª–µ. –ò–º–µ—é—Ç—Å—è –¥–≤–∞
			–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–∞, –ø–æ–∑–≤–æ–ª—è—é—â–∏—Ö —á–µ—Ç–∫–æ –ø–æ–Ω–∏–º–∞—Ç—å, —Å —á–µ–º –∏–º–µ–Ω–Ω–æ –º—ã –∏–º–µ–µ–º –¥–µ–ª–æ.

			–ö –ø—Ä–∏–º–µ—Ä—É, –µ—Å–ª–∏ –∞—Ä–≥—É–º–µ–Ω—Ç "–¢–µ–∫—Å—Ç-–ø–æ–¥—Å–∫–∞–∑–∫–∞ –î–û" –±—É–¥–µ—Ç —Ä–∞–≤–µ–Ω "–°—ä–µ–¥–µ–Ω–æ ", –∞ –∞—Ä–≥—É–º–µ–Ω—Ç "–¢–µ–∫—Å—Ç-–ø–æ–¥—Å–∫–∞–∑–∫–∞ –ü–û–°–õ–ï"
			–±—É–¥–µ—Ç —Ä–∞–≤–µ–Ω " —è–±–ª–æ–∫", –∞ –∑–Ω–∞—á–µ–Ω–∏–µ —Å–ª–∞–π–¥–µ—Ä–∞ –±—É–¥–µ—Ç —Ä–∞–≤–Ω–æ 50, —Ç–æ –Ω–∞ —ç–∫—Ä–∞–Ω–µ –±—É–¥–µ—Ç –Ω–∞–ø–∏—Å–∞–Ω–æ "–°—ä–µ–¥–µ–Ω–æ 50 —è–±–ª–æ–∫".

			–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –æ–±—ä–µ–∫—Ç.

		{"Switch", –ê–∫—Ç–∏–≤–Ω—ã–π —Ü–≤–µ—Ç, –ü–∞—Å—Å–∏–≤–Ω—ã–π —Ü–≤–µ—Ç, –¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞, –¢–µ–∫—Å—Ç, –°–æ—Å—Ç–æ—è–Ω–∏–µ}

			 –ü–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å, –ø—Ä–∏–Ω–∏–º–∞—é—â–∏–π –¥–≤–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è: true –∏–ª–∏ false. –¢–µ–∫—Å—Ç - —ç—Ç–æ –≤—Å–µ–≥–æ –ª–∏—à—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è, –Ω–µ–∫–æ–µ
			 –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω–æ–≥–æ –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—è.

			 –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –æ–±—ä–µ–∫—Ç.  

		{"CenterText", –¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞, –°–∞–º —Ç–µ–∫—Å—Ç}

			–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞ –ø–æ —Ü–µ–Ω—Ç—Ä—É –æ–∫–Ω–∞. –ß–∏—Å—Ç–æ –¥–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω—ã—Ö —Ü–µ–ª–µ–π.

		{"WrappedText", –¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞, –¢–µ–∫—Å—Ç}

			–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –±–æ–ª—å—à–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Ç–µ–∫—Å—Ç–∞ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –ø–µ—Ä–µ–Ω–æ—Å–æ–º. –ü—Ä–æ—Ç–æ —Ä–µ–∂–µ—Ç —Å–ª–æ–≤–∞ –Ω–∞ –∫—É—Å–æ—á–∫–∏,
			–ø–µ—Ä–µ–Ω–æ—Å —Å–∏–º–≤–æ–ª–∏—á–µ—Å–∫–∏–π. –ß–∏—Å—Ç–æ –¥–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω—ã—Ö —Ü–µ–ª–µ–π.
 
        {"TextField", –í—ã—Å–æ—Ç–∞, –¶–≤–µ—Ç —Ñ–æ–Ω–∞, –¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞, –¶–≤–µ—Ç —Å–∫—Ä–æ–ª–ª–±–∞—Ä–∞, –¶–≤–µ—Ç –ø–∏–º–ø–æ—á–∫–∏ —Å–∫—Ä–æ–ª–ª–±–∞—Ä–∞, –°–∞–º —Ç–µ–∫—Å—Ç}
 
        	–¢–µ–∫—Å—Ç–æ–≤–æ–µ –ø–æ–ª–µ —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –ø—Ä–æ–∫—Ä—É—Ç–∫–∏. –û—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç "WrappedText"
        	—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –≤—ã—Å–æ—Ç–æ–π. –ß–∏—Å—Ç–æ –¥–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω—ã—Ö —Ü–µ–ª–µ–π.
   
        {"Separator", –¶–≤–µ—Ç —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è}
 
        	–õ–∏–Ω–∏—è-—Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å, –ø–æ–º–æ–≥–∞—é—â–∞—è –ª—É—á—à–µ –æ—Ç–¥–µ–ª—è—Ç—å –æ–±—ä–µ–∫—Ç—ã –¥—Ä—É–≥ –æ—Ç –¥—Ä—É–≥–∞. –î–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω—ã–π –æ–±—ä–µ–∫—Ç.
 
		{"EmptyLine"}
 
        	–ü—É—Å—Ç–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ, –ø–æ–º–æ–≥–∞—é—â–∞—è –ª—É—á—à–µ –æ—Ç–¥–µ–ª—è—Ç—å –æ–±—ä–µ–∫—Ç—ã –¥—Ä—É–≥ –æ—Ç –¥—Ä—É–≥–∞. –î–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω—ã–π –æ–±—ä–µ–∫—Ç.
 
		–ö–∞–∂–¥—ã–π –∏–∑ –æ–±—ä–µ–∫—Ç–æ–≤ —Ä–∏—Å—É–µ—Ç—Å—è –ø–æ –ø–æ—Ä—è–¥–∫—É —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑. –ö–∞–∂–¥—ã–π –æ–±—ä–µ–∫—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
		—É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –≤—ã—Å–æ—Ç—É –æ–∫–Ω–∞ –¥–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è. –ï—Å–ª–∏ –æ–±—ä–µ–∫—Ç–æ–≤ –±—É–¥–µ—Ç —É–∫–∞–∑–∞–Ω–æ —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ -
		—Ç.–µ. –µ—Å–ª–∏ –æ–∫–Ω–æ –≤—ã–ª–µ–∑–µ—Ç –∑–∞ –ø—Ä–µ–¥–µ–ª—ã —ç–∫—Ä–∞–Ω–∞, —Ç–æ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è —Å –æ—à–∏–±–∫–æ–π.

	–ß—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—è:
		
		–í–æ–∑–≤—Ä–∞—Ç–æ–º —è–≤–ª—è–µ—Ç—Å—è –º–∞—Å—Å–∏–≤, –ø—Ä–æ–Ω—É–º–µ—Ä–æ–≤–∞–Ω–Ω—ã–π –æ—Ç 1 –¥–æ <–∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –æ–±—ä–µ–∫—Ç–æ–≤>.
		–ö –ø—Ä–∏–º–µ—Ä—É, 1 –∏–Ω–¥–µ–∫—Å –¥–∞–Ω–Ω–æ–≥–æ –º–∞—Å—Å–∏–≤–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç 1 —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –æ–±—ä–µ–∫—Ç—É.
		–ö–∞–∂–¥—ã–π –∏–Ω–¥–µ–∫—Å –¥–∞–Ω–Ω–æ–≥–æ –º–∞—Å—Å–∏–≤–∞ –Ω–µ—Å–µ—Ç –≤ —Å–µ–±–µ –∫–∞–∫–∏–µ-—Ç–æ –¥–∞–Ω–Ω—ã–µ, –∫–æ—Ç–æ—Ä—ã–µ –≤—ã
		–≤–Ω–µ—Å–ª–∏ –≤ –æ–±—ä–µ–∫—Ç –≤–æ –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã —Ñ—É–Ω–∫—Ü–∏–∏.
		–ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ –≤ 1-—ã–π –æ–±—ä–µ–∫—Ç —Ç–∏–ø–∞ "Input" –≤—ã –≤–≤–µ–ª–∏ —Ñ—Ä–∞–∑—É "Hello world",
		—Ç–æ –ø–µ—Ä–≤—ã–π –∏–Ω–¥–µ–∫—Å –≤ –≤–æ–∑–≤—Ä–∞—â–µ–Ω–Ω–æ–º –º–∞—Å—Å–∏–≤–µ –±—É–¥–µ—Ç —Ä–∞–≤–µ–Ω "Hello world".
		–ö–æ–Ω–∫—Ä–µ—Ç–Ω–µ–µ —ç—Ç–æ –±—É–¥–µ—Ç –≤–æ—Ç —Ç–∞–∫: massiv[1] = "Hello world".

		–ï—Å–ª–∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å –æ–±—ä–µ–∫—Ç–æ–º –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ - –Ω–∞–ø—Ä–∏–º–µ—Ä, –∫–∞–∫ –≤ —Å–ª—É—á–∞–µ
		—Å EmptyLine, CenterText, TextField –∏–ª–∏ Separator, —Ç–æ –≤ –≤–æ–∑–≤—Ä–∞—â–µ–Ω–Ω–æ–º
		–º–∞—Å—Å–∏–≤–µ —ç—Ç–æ—Ç –æ–±—ä–µ–∫—Ç —É–∫–∞–∑—ã–≤–∞—Ç—å—Å—è –Ω–µ –±—É–¥–µ—Ç.

		–ì–æ—Ç–æ–≤—ã–µ –ø—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ —É–∫–∞–∑–∞–Ω—ã –Ω–∏–∂–µ –∏ –∑–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω—ã.
		–í—ã–±–∏—Ä–∞–π—Ç–µ –Ω—É–∂–Ω—ã–π –∏ —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ.
]]

--–§—É–Ω–∫—Ü–∏—è-–¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ç–æ—Ä, –ø–æ–∫–∞–∑—ã–≤–∞—é—â–∞—è –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã –≤ –æ–¥–Ω–æ–º –æ–∫–Ω–µ. –ö–æ–¥ –æ–∫–Ω–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤—ã—à–µ.
--ecs.demoWindow()

--–§—É–Ω–∫—Ü–∏—è, –ø—Ä–µ–¥–ª–∞–≥–∞—é—â–∞—è —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª –≤ –Ω—É–∂–Ω–æ–º –º–µ—Å—Ç–µ –≤ –Ω—É–∂–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ.
--ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x262626, "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫"}, {"EmptyLine"}, {"Input", 0x262626, 0x880000, "–ü—É—Ç—å"}, {"Selector", 0x262626, 0x880000, "PNG", "JPG", "PSD"}, {"EmptyLine"}, {"Button", {0xbbbbbb, 0xffffff, "OK!"}})

----------------------------------------------------------------------------------------------------

return ecs


Flib/GUI.lua	Flib/MineOSCore.luaÖ˛Dlib/OpenComputersGL/Flib/OpenComputersGL/Main.lua2À
-------------------------------------------------------- Libraries --------------------------------------------------------

local vector = require("vector")
local matrix = require("matrix")
local buffer = require("doubleBuffering")
local materials = require("OpenComputersGL/Materials")
local renderer = require("OpenComputersGL/Renderer")
local OCGL = {}

-------------------------------------------------------- Constants --------------------------------------------------------

OCGL.axis = {
	x = 1,
	y = 2,
	z = 3,
}

OCGL.vertices = {}
OCGL.triangles = {}
OCGL.lines = {}
OCGL.floatingTexts = {}

-------------------------------------------------------- Vertex field methods --------------------------------------------------------

function OCGL.rotateVector(vector, axis, angle)
	local sin, cos = math.sin(angle), math.cos(angle)
	if axis == OCGL.axis.x then
		vector[1], vector[2], vector[3] = vector[1], cos * vector[2] - sin * vector[3], sin * vector[2] + cos * vector[3]
	elseif axis == OCGL.axis.y then
		vector[1], vector[2], vector[3] = cos * vector[1] + sin * vector[3], vector[2], cos * vector[3] - sin * vector[1]
	elseif axis == OCGL.axis.z then
		vector[1], vector[2], vector[3] = cos * vector[1] - sin * vector[2], sin * vector[1] + cos * vector[2], vector[3]
	else
		error("Axis enum " .. tostring(axis) .. " doesn't exists")
	end
end

function OCGL.translate(xTranslation, yTranslation, zTranslation)
	for vertexIndex = 1, #OCGL.vertices do
		OCGL.vertices[vertexIndex][1], OCGL.vertices[vertexIndex][2], OCGL.vertices[vertexIndex][3] = OCGL.vertices[vertexIndex][1] + xTranslation, OCGL.vertices[vertexIndex][2] + yTranslation, OCGL.vertices[vertexIndex][3] + zTranslation
	end
end

function OCGL.rotate(axis, angle)
	for vertexIndex = 1, #OCGL.vertices do
		OCGL.rotateVector(OCGL.vertices[vertexIndex], axis, angle)
	end
end

-------------------------------------------------------- Render queue methods --------------------------------------------------------

function OCGL.newIndexedTriangle(indexOfVertex1, indexOfVertex2, indexOfVertex3, material)
	return { indexOfVertex1, indexOfVertex2, indexOfVertex3, material }
end

function OCGL.newIndexedLine(indexOfVertex1, indexOfVertex2, color)
	return { indexOfVertex1, indexOfVertex2, color }
end

function OCGL.newIndexedFloatingText(indexOfVertex, color, text)
	return {indexOfVertex, text, color}
end

function OCGL.pushTriangleToRenderQueue(vector3Vertex1, vector3Vertex2, vector3Vertex3, material, meshPointer, meshTriangleIndexPointer)
	table.insert(OCGL.vertices, vector3Vertex1)
	table.insert(OCGL.vertices, vector3Vertex2)
	table.insert(OCGL.vertices, vector3Vertex3)
	table.insert(OCGL.triangles, OCGL.newIndexedTriangle(OCGL.nextVertexIndex, OCGL.nextVertexIndex + 1, OCGL.nextVertexIndex + 2, material, meshPointer, meshTriangleIndexPointer))
	OCGL.nextVertexIndex = OCGL.nextVertexIndex + 3
end

function OCGL.pushLineToRenderQueue(vector3Vertex1, vector3Vertex2, color)
	table.insert(OCGL.vertices, vector3Vertex1)
	table.insert(OCGL.vertices, vector3Vertex2)
	table.insert(OCGL.lines, OCGL.newIndexedLine(OCGL.nextVertexIndex, OCGL.nextVertexIndex + 1, color))
	OCGL.nextVertexIndex = OCGL.nextVertexIndex + 2
end

function OCGL.pushFloatingTextToRenderQueue(vector3Vertex, color, text)
	table.insert(OCGL.vertices, vector3Vertex)
	table.insert(OCGL.floatingTexts, OCGL.newIndexedFloatingText(OCGL.nextVertexIndex, color, text))
	OCGL.nextVertexIndex = OCGL.nextVertexIndex + 1
end

-------------------------------------------------------- Rendering methods --------------------------------------------------------

OCGL.setViewport = renderer.setViewport

function OCGL.clearBuffer(backgroundColor)
	OCGL.nextVertexIndex, OCGL.vertices, OCGL.triangles, OCGL.lines, OCGL.floatingTexts = 1, {}, {}, {}, {}
	renderer.clearDepthBuffer()
	buffer.clear(backgroundColor)
end

function OCGL.createPerspectiveProjection() 
	local zNearDivZ
	for vertexIndex = 1, #OCGL.vertices do
		zNearDivZ = math.abs(renderer.viewport.projectionSurface / OCGL.vertices[vertexIndex][3])
		OCGL.vertices[vertexIndex][1] = zNearDivZ * OCGL.vertices[vertexIndex][1]
		OCGL.vertices[vertexIndex][2] = zNearDivZ * OCGL.vertices[vertexIndex][2]
		-- OCGL.vertices[vertexIndex][3] = zNearDivZ * OCGL.vertices[vertexIndex][3]
	end
end

function OCGL.render(renderMode)
	local vector3Vertex1, vector3Vertex2, vector3Vertex3, material = {}, {}, {}

	-- for lineIndex = 1, #OCGL.lines do
	-- 	vector3Vertex1, vector3Vertex2, material = OCGL.vertices[OCGL.lines[lineIndex][1]], OCGL.vertices[OCGL.lines[lineIndex][2]], OCGL.lines[lineIndex][3]

	-- 	if renderMode == renderer.renderModes.vertices then
	-- 		renderer.renderDot(vector3Vertex1, material)
	-- 		renderer.renderDot(vector3Vertex2, material)
	-- 	else
	-- 		renderer.renderLine(
	-- 			math.floor(vector3Vertex1[1]),
	-- 			math.floor(vector3Vertex1[2]),
	-- 			vector3Vertex1[3],
	-- 			math.floor(vector3Vertex2[1]),
	-- 			math.floor(vector3Vertex2[2]),
	-- 			vector3Vertex2[3],
	-- 			material
	-- 		)
	-- 	end
	-- end

	for floatingTextIndex = 1, #OCGL.floatingTexts do
		vector3Vertex1 = OCGL.vertices[OCGL.floatingTexts[floatingTextIndex][1]]
		renderer.renderFloatingText(
			renderer.viewport.xCenter + vector3Vertex1[1],
			renderer.viewport.yCenter - vector3Vertex1[2],
			vector3Vertex1[3],
			OCGL.floatingTexts[floatingTextIndex][2],
			OCGL.floatingTexts[floatingTextIndex][3]
		)
	end

	for triangleIndex = 1, #OCGL.triangles do
		material = OCGL.triangles[triangleIndex][4]
		vector3Vertex1[1], vector3Vertex1[2], vector3Vertex1[3] = renderer.viewport.xCenter + OCGL.vertices[OCGL.triangles[triangleIndex][1]][1], renderer.viewport.yCenter - OCGL.vertices[OCGL.triangles[triangleIndex][1]][2], OCGL.vertices[OCGL.triangles[triangleIndex][1]][3]
		vector3Vertex2[1], vector3Vertex2[2], vector3Vertex2[3] = renderer.viewport.xCenter + OCGL.vertices[OCGL.triangles[triangleIndex][2]][1], renderer.viewport.yCenter - OCGL.vertices[OCGL.triangles[triangleIndex][2]][2], OCGL.vertices[OCGL.triangles[triangleIndex][2]][3]
		vector3Vertex3[1], vector3Vertex3[2], vector3Vertex3[3] = renderer.viewport.xCenter + OCGL.vertices[OCGL.triangles[triangleIndex][3]][1], renderer.viewport.yCenter - OCGL.vertices[OCGL.triangles[triangleIndex][3]][2], OCGL.vertices[OCGL.triangles[triangleIndex][3]][3]
		
		if
			renderer.isVertexInViewRange(vector3Vertex1[1], vector3Vertex1[2], vector3Vertex1[3]) or
			renderer.isVertexInViewRange(vector3Vertex2[1], vector3Vertex2[2], vector3Vertex2[3]) or
			renderer.isVertexInViewRange(vector3Vertex3[1], vector3Vertex3[2], vector3Vertex3[3])
		then
			if renderMode == renderer.renderModes.material then
				if material.type == materials.types.solid then
					renderer.renderFilledTriangle(
						{
							vector3Vertex1,
							vector3Vertex2,
							vector3Vertex3
						},
						material.color
					)
				else
					error("Material type " .. tostring(material.type) .. " doesn't supported for rendering triangles")
				end
			elseif renderMode == renderer.renderModes.wireframe then
				renderer.renderLine(math.floor(vector3Vertex1[1]), math.floor(vector3Vertex1[2]), vector3Vertex1[3], math.floor(vector3Vertex2[1]), math.floor(vector3Vertex2[2]), vector3Vertex2[3], material.color or renderer.colors.wireframe)
				renderer.renderLine(math.floor(vector3Vertex2[1]), math.floor(vector3Vertex2[2]), vector3Vertex2[3], math.floor(vector3Vertex3[1]), math.floor(vector3Vertex3[2]), vector3Vertex3[3], material.color or renderer.colors.wireframe)
				renderer.renderLine(math.floor(vector3Vertex1[1]), math.floor(vector3Vertex1[2]), vector3Vertex1[3], math.floor(vector3Vertex3[1]), math.floor(vector3Vertex3[2]), vector3Vertex3[3], material.color or renderer.colors.wireframe)
			elseif renderMode == renderer.renderModes.vertices then
				renderer.renderDot(vector3Vertex1, material.color or renderer.colors.wireframe)
				renderer.renderDot(vector3Vertex2, material.color or renderer.colors.wireframe)
				renderer.renderDot(vector3Vertex3, material.color or renderer.colors.wireframe)
			else
				error("Rendermode enum " .. tostring(renderMode) .. " doesn't supported for rendering triangles")
			end
		end
	end
end

-------------------------------------------------------- Raycasting methods --------------------------------------------------------

local function vectorMultiply(a, b)
	return vector.newVector3(a[2] * b[3] - a[3] * b[2], a[3] * b[1] - a[1] * b[3], a[1] * b[2] - a[2] * b[1])
end

local function getVectorDistance(a)
	return math.sqrt(a[1] ^ 2 + a[2] ^ 2 + a[3] ^ 2)
end

-- –í —Å–ª—É—á–∞–µ –ø–æ–ø–∞–¥–∞–Ω–∏—è –ª—É—á–∏–∫–∞ —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ –≤–µ—Ä–Ω–µ—Ç —Å–∞–º —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫, –∞ —Ç–∞–∫–∂–µ –¥–∏—Å—Ç–∞–Ω—Ü–∏—é –¥–æ –µ–≥–æ –ø–ª–æ—Å–∫–æ—Å—Ç–∏
function OCGL.triangleRaycast(vector3RayStart, vector3RayEnd)
	local minimalDistance, closestTriangleIndex
	for triangleIndex = 1, #OCGL.triangles do
		-- –≠—Ç–æ –≤–µ—Ä—à–∏–Ω—ã —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞
		local A, B, C = OCGL.vertices[OCGL.triangles[triangleIndex][1]], OCGL.vertices[OCGL.triangles[triangleIndex][3]], OCGL.vertices[OCGL.triangles[triangleIndex][3]]
		-- ecs.error(A[1], A[2], A[3], vector3RayStart[1], vector3RayStart[2], vector3RayStart[3])
		-- –≠—Ç–æ —Ö–∑ —á–µ
		local ABC = vectorMultiply(vector.newVector3(C[1] - A[1], C[2] - A[2], C[3] - A[3]), vector.newVector3(B[1] - A[1], B[2] - A[2], B[3] - A[3]))
		-- –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —É–¥–∞–ª–µ–Ω–Ω–æ—Å—Ç—å –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–π –ø–ª–æ—Å–∫–æ—Å—Ç–∏ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ –æ—Ç —Å—Ç–∞—Ä—Ç–∞ –Ω–∞—à–µ–≥–æ –ª—É—á–∞
		local D = -ABC[1] * A[1] - ABC[2] * A[2] - ABC[3] * A[3]
		local firstPart = D + ABC[1] * vector3RayStart[1] + ABC[2] * vector3RayStart[2] + ABC[3] * vector3RayStart[3]
		local secondPart = ABC[1] * vector3RayStart[1] - ABC[1] * vector3RayEnd[1] + ABC[2] * vector3RayStart[2] - ABC[2] * vector3RayEnd[2] + ABC[3] * vector3RayStart[3] - ABC[3] * vector3RayEnd[3]
		
		-- ecs.error(firstPart, secondPart)

		-- if firstPart ~= 0 or secondPart ~= 0 then ecs.error(firstPart, secondPart) end
		-- –ï—Å–ª–∏ –Ω–∞—à –ª—É—á–∏–∫ –Ω–µ –ø–∞—Ä–∞–ª–ª–µ–ª–µ–Ω —Ç–æ–π –µ–±—É—á–µ–π –ø–ª–æ—Å–∫–æ—Å—Ç–∏ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞
		if secondPart ~= 0 then
			local distance = firstPart / secondPart
			-- –ò –µ—Å–ª–∏ —ç—Ç–æ—Ç –æ–±—ä–µ–∫—Ç –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –±–ª–∏–∂–µ –∫ —Å—Ç–∞—Ä—Ç—É –ª—É—á–∞, –Ω–µ–∂–µ–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â–∏–π
			if (distance >= 0 and distance <= 1) and (not minimalDistance or distance < minimalDistance) then
	
				-- –¢–æ —Å—á–∏—Ç–∞–µ–º —Ç–æ—á–∫—É –ø–æ–ø–∞–¥–∞–Ω–∏—è –ª—É—á–∞ –≤ –¥–∞–Ω–Ω—É—é –ø–ª–æ—Å–∫–æ—Å—Ç—å (–Ω–æ –Ω–∏ —Ö—É—è –Ω–µ —Ñ–∞–∫—Ç, —á—Ç–æ –æ–Ω –ø–æ–ø–∞–¥–µ—Ç –≤ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫!)
				local S = vector.newVector3(
					vector3RayStart[1] + (vector3RayEnd[1] - vector3RayStart[1]) * distance,
					vector3RayStart[2] + (vector3RayEnd[2] - vector3RayStart[2]) * distance,
					vector3RayStart[3] + (vector3RayEnd[3] - vector3RayStart[3]) * distance
				)

				-- –î–∞–ª–µ–µ —Å—á–∏—Ç–∞–µ–º —Å—É–º–º—É –ø–ª–æ—â–∞–¥–µ–π –ø–∞—Ä–∞–ª–ª–µ–ª–æ–≥—Ä–∞–º–º–æ–≤, –æ–±—Ä–∞–∑–æ–≤–∞–Ω–Ω—ã—Ö —Ç—Ä–µ–º—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞–º–∏, –æ–±—Ä–∞–∑–æ–≤–∞–≤—à–∏—Ö—Å—è –ø—Ä–∏ –ø–æ–ø–∞–¥–∞–Ω–∏–∏ —Ç–æ—á–∫–∏ –≤ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
				-- –ù—É—É—É —Ç–∏–ø –∫–∞—Ä–æ—á —Å–º–∞—Ä–∏: —Ç–æ—á–∫–∞ –µ–±–∞–Ω—É–ª–∞ –≤ —Ü–µ–Ω—Ç—Ä, –∏ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ —Ä–∞—Å–ø–∏–¥–æ—Ä–∞—Å–∏–ª–æ –Ω–∞ —Ç—Ä–∏ –º–µ–ª–∫–∏—Ö. –ù—É, –∏ —Ç—Ä–∏ –º–µ–ª–∫–∏—Ö –º–æ–≥—É—Ç –æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –ø–∞—Ä–∞–ª–ª–µ–ª–æ–≥—Ä–∞–º–º—ã —Å–≤–æ–∏
				-- –ò, –∫–∞—Ä–æ—á, –µ—Å–ª–∏ —Å—É–º–º–∞ —Ç—Ä–µ—Ö –ø–ª–æ—â–∞–¥–µ–π —ç—Ç–∏—Ö –º–µ–ª–∫–∏—Ö —É–µ–±–∫–æ–≤ –±—É–¥–µ—Ç —Å–∏–ª—å–Ω–æ –æ—Ç–ª–∏—á–∞—Ç—å—Å—è –æ—Ç –ø–ª–æ—â–∞–¥–∏ –∂–∏—Ä–Ω–æ–≥–æ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞, —Ç–æ –ª—É—á –Ω–µ –ø–æ–ø–∞–ª
				-- –ù—É, –∞ –ø–ª–æ—â–∞–¥—å —Å—á–∏—Ç–∞–µ—Ç—Å—è —á–µ—Ä–µ–∑ sqrt(x^2+y^2+z^2) –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –π–æ–±–∞-–≤–µ–∫—Ç–æ—Ä–∞

				---- *A                      *B


				--                  * Shotxyz


				---                   *C

				local SA = vector.newVector3(A[1] - S[1], A[2] - S[2], A[3] - S[3])
				local SB = vector.newVector3(B[1] - S[1], B[2] - S[2], B[3] - S[3])
				local SC = vector.newVector3(C[1] - S[1], C[2] - S[2], C[3] - S[3])
			
				local vectorDistanceSum = getVectorDistance(vectorMultiply(SA, SB)) + getVectorDistance(vectorMultiply(SB, SC)) + getVectorDistance(vectorMultiply(SC, SA))
				local ABCDistance = getVectorDistance(ABC)

				-- –í–æ—Ç —Ç—É—Ç –º—ã —á–µ–∫–∞–µ–º –ø–æ–≥—Ä–µ—à–Ω–æ—Å—Ç—å —Ä–∞—Å—á–µ—Ç–æ–≤. –ï—Å–ª–∏ –≤—Å–µ –∑–∞–µ–±–æ–∫, —Ç–æ –∫–∏–¥–∞–µ–º —ç—Ç–æ—Ç —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ –≤ "–ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–µ""
				if math.abs(vectorDistanceSum - ABCDistance) < 1 then
					closestTriangleIndex = triangleIndex
					minimalDistance = distance
				end
			end 
		end
	end

	-- ecs.error(closestTriangleIndex)
	if OCGL.triangles[closestTriangleIndex] then
		return OCGL.triangles[closestTriangleIndex][5], OCGL.triangles[closestTriangleIndex][6], minimalDistance
	end
end

-------------------------------------------------------- Constants --------------------------------------------------------

return OCGL
F!lib/OpenComputersGL/Materials.lua6

local materials = {}

------------------------------------------------------------------------------------------------------------------------

materials.types = {
	textured = 1,
	solid = 2,
}

function materials.newSolidMaterial(color)
	return {
		type = materials.types.solid,
		color = color
	}
end

function materials.newTexturedMaterial(texture)
	return {
		type = materials.types.textured,
		texture = texture
	}
end

------------------------------------------------------------------------------------------------------------------------

return materials

F lib/OpenComputersGL/Renderer.lua%ßDlib/PolyCatEngine/Flib/PolyCatEngine/Main.luaO=Flib/bigLetters.lua)“Flib/bit32.lua¬--[[ Backwards compat for Lua 5.3; only loaded in 5.3 because package.loaded is
     prepopulated with the existing global bit32 in 5.2. ]]

local bit32 = {}

-------------------------------------------------------------------------------

local function fold(init, op, ...)
  local result = init
  local args = table.pack(...)
  for i = 1, args.n do
    result = op(result, args[i])
  end
  return result
end

local function trim(n)
  return n & 0xFFFFFFFF
end

local function mask(w)
  return ~(0xFFFFFFFF << w)
end

function bit32.arshift(x, disp)
  return x // (2 ^ disp)
end

function bit32.band(...)
  return fold(0xFFFFFFFF, function(a, b) return a & b end, ...)
end

function bit32.bnot(x)
  return ~x
end

function bit32.bor(...)
  return fold(0, function(a, b) return a | b end, ...)
end

function bit32.btest(...)
  return bit32.band(...) ~= 0
end

function bit32.bxor(...)
  return fold(0, function(a, b) return a ~ b end, ...)
end

local function fieldargs(f, w)
  w = w or 1
  assert(f >= 0, "field cannot be negative")
  assert(w > 0, "width must be positive")
  assert(f + w <= 32, "trying to access non-existent bits")
  return f, w
end

function bit32.extract(n, field, width)
  local f, w = fieldargs(field, width)
  return (n >> f) & mask(w)
end

function bit32.replace(n, v, field, width)
  local f, w = fieldargs(field, width)
  local m = mask(w)
  return (n & ~(m << f)) | ((v & m) << f)
end

function bit32.lrotate(x, disp)
  if disp == 0 then return x
  elseif disp < 0 then return bit32.rrotate(x, -disp)
  else return trim((x << disp) | (x >> (32 - disp))) end
end

function bit32.lshift(x, disp)
  return trim(x << disp)
end

function bit32.rrotate(x, disp)
  if disp == 0 then return x
  elseif disp < 0 then return bit32.lrotate(x, -disp)
  else return trim((x >> disp) | (x << (32 - disp))) end
end

function bit32.rshift(x, disp)
  return trim(x >> disp)
end

-------------------------------------------------------------------------------

return bit32
Flib/buffer.lua. Flib/deflatelua.lua?KFlib/devfs.luaplocal fs = require("filesystem")

local proxy = {points={},address=require("guid").next()}

local nop = function()end

function proxy.getLabel()
  return "devfs"
end

function proxy.setLabel(value)
  error("drive does not support labeling")
end

function proxy.spaceTotal()
  return 0
end

function proxy.spaceUsed()
  return 0
end

function proxy.exists(path)
  return not not proxy.points[path]
end

function proxy.size(path)
  return 0
end

function proxy.isDirectory(path)
  return false
end

function proxy.lastModified(path)
  return fs.lastModified("/dev/")
end

function proxy.list()
  local keys = {}
  for k,v in pairs(proxy.points) do
    table.insert(keys, k)
  end
  return keys
end

function proxy.makeDirectory(path)
  return false
end

function proxy.remove(path)
  if not proxy.exists(path) then return false end
  proxy.points[path] = nil
  return true
end

function proxy.rename(from, to)
  return false
end

proxy.close = nop

function proxy.open(path, mode)
  checkArg(1, path, "string")

  local handle = proxy.points[path]
  if not handle then return nil, "device point [" .. path .. "] does not exist" end

  local msg = "device point [" .. path .. "] cannot be opened for "

  if mode == "r" then
    if not handle.read then
      return nil, msg .. "read"
    end
  else
    if not handle.write then
      return nil, msg .. "write"
    end
  end

  return handle
end

function proxy.read(h,...)
  return h:read(...)
end

function proxy.seek(h,...)
  return h:seek(...)
end

function proxy.write(h,...)
  return h:write(...)
end

function proxy.create(path, handle)
  handle.close = handle.close or nop
  proxy.points[path] = handle
  return true
end

proxy.create("null", {write = nop})
proxy.create("random", {read = function(_,n)
  local chars = {}
  for i=1,n do
    table.insert(chars,string.char(math.random(0,255)))
  end
  return table.concat(chars)
end})

return proxy
Flib/doubleBuffering.luaiZFlib/guid.lua€local guid = {}

function guid.toHex(n)
  if type(n) ~= 'number' then
    return nil, string.format("toHex only converts numbers to strings, %s is not a string, but a %s", tostring(n), type(n))
  end
  if n == 0 then
    return '0'
  end

  local hexchars = "0123456789abcdef"
  local result = ""
  local prefix = "" -- maybe later allow for arg to request 0x prefix
  if n < 0 then
    prefix = "-"
    n = -n
  end

  while n > 0 do
    local next = math.floor(n % 16) + 1 -- lua has 1 based array indices
    n = math.floor(n / 16)
    result = hexchars:sub(next, next) .. result
  end

  return prefix .. result
end

function guid.next()
  -- e.g. 3c44c8a9-0613-46a2-ad33-97b6ba2e9d9a
  -- 8-4-4-4-12
  local sets = {8, 4, 4, 12}
  local result = ""

  local i
  for _,set in ipairs(sets) do
    if result:len() > 0 then
      result = result .. "-"
    end
    for i = 1,set do
      result = result .. guid.toHex(math.random(0, 15))
    end
  end

  return result
end

return guid
Flib/image.lua€§Flib/pipes.lua%jF
lib/rc.luaì-- Keeps track of loaded scripts to retain local values between invocation
-- of their command callbacks.
local rc = {}
rc.loaded = {}

return rc

Flib/serialization.luap
require("advancedLua")
local serialization = {}

------------------------------------------------- Public methods -----------------------------------------------------------------

function serialization.serialize(...)
	return table.serialize(...)
end

function serialization.unserialize(...)
	return table.unserialize(...)
end

function serialization.serializeToFile(...)
	table.toFile(...)
end

function serialization.unserializeFromFile(...)
	return table.fromFIle(...)
end

----------------------------------------------------------------------------------------------------------------------

return serialization




F
lib/sh.luak€Flib/term.lua@´Flib/text.lua!ó